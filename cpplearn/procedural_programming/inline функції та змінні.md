---
date: 2024-09-22
tags:
  - Процедурне_програмування
  - Фундаментальні_типи_дани
---
Розглянемо випадок, коли вам потрібно написати деякий код для виконання деякого дискретного завдання, наприклад, прочитати вхідні дані від користувача, вивести щось у файл або обчислити певне значення. При реалізації цього коду у вас є, по суті, два варіанти:
- Напишіть код як частину існуючої функції (це називається написанням коду "на місці" або "в лінію").
- Створіть функцію (і, можливо, підфункції) для обробки завдання.
Написання функцій надає багато потенційних переваг, як і код у функції:
- Легше читати і розуміти в контексті всієї програми.
- Легше використовувати, оскільки ви можете викликати функцію, не розуміючи, як вона реалізована.
- Легше оновлювати, оскільки код у функції можна оновити в одному місці.
- Легше використовувати повторно, оскільки функції є модульними.

Однак недоліком використання функцій є те, що кожного разу, коли функція викликається, виникає певна кількість накладних витрат, пов'язаних з продуктивністю. Розглянемо наступний приклад:
```cpp
#include <iostream>

int min(int x, int y)
{
    return (x < y) ? x : y;
}

int main()
{
    std::cout << min(5, 6) << '\n';
    std::cout << min(3, 2) << '\n';
    return 0;
}
```
Коли відбувається виклик `min()`, процесор повинен запам'ятати адресу поточної інструкції, яку він виконує (щоб знати, куди повернутися пізніше), а також значення різних регістрів процесора (щоб їх можна було відновити після повернення). Потім параметри `x` та `y` мають бути створені, а потім ініціалізовані. Потім шлях виконання повинен переходити до коду функції `min()`. Коли функція завершується, програма повинна повернутися до місця виклику функції і скопіювати значення, що повертається, щоб його можна було вивести. Це потрібно робити для кожного виклику функції.
Уся додаткова робота, яка повинна виконуватися для налаштування, полегшення та/або очищення після виконання певної задачі (у цьому випадку виклику функції), називається накладними витратами.

Для великих функцій та/або функцій, що виконують складні завдання, накладні витрати на виклик функції зазвичай є незначними порівняно з часом, протягом якого функція виконується. Однак, для малих функцій (таких як `min()` вище), накладні витрати можуть бути більшими, ніж час, необхідний для виконання коду функції! У випадках, коли невелика функція викликається часто, використання функції може призвести до значного зниження продуктивності порівняно з написанням того самого коду на місці.
## Вбудоване розширення
На щастя, компілятор C++ має трюк, за допомогою якого він може уникнути таких накладних витрат: **вбудоване розширення** - це процес, при якому виклик функції замінюється кодом з визначення функції, що викликається.

Наприклад, якби компілятор розширив виклики `min()` у наведеному вище прикладі, то результуючий код виглядав би так:
```cpp
#include <iostream>

int main()
{
    std::cout << ((5 < 6) ? 5 : 6) << '\n';
    std::cout << ((3 < 2) ? 3 : 2) << '\n';
    return 0;
}
```
Зверніть увагу, що два виклики функції `min()` було замінено кодом у тілі функції `min(`) (зі значеннями аргументів, підставленими замість параметрів). Це дозволяє уникнути накладних витрат на ці виклики, зберігаючи при цьому результати роботи коду.
## Продуктивність вбудованого коду
Крім усунення витрат на виклик функції, вбудоване розширення може також дозволити компілятору більш ефективно оптимізувати результуючий код - наприклад, оскільки вираз `((5 < 6) ? 5 : 6)` тепер є константним виразом, компілятор може додатково оптимізувати перший оператор в `main()` до `std::cout << 5 << '\n';`.

Однак, вбудоване розширення має свої потенційні витрати: якщо тіло функції, що розширюється, займає більше інструкцій, ніж виклик функції, що замінюється, то кожне вбудоване розширення призводить до збільшення розміру виконуваного файлу. Більші виконувані файли, як правило, працюють повільніше (через те, що вони гірше поміщаються в кеші пам'яті).

Рішення про те, чи виграє функція від того, що її буде зроблено вбудованою (оскільки усунення накладних витрат на виклик функції переважає вартість більшого виконуваного файлу), не є простим. Інтегроване розширення може призвести до підвищення продуктивності, зниження продуктивності або взагалі не вплинути на продуктивність, залежно від відносної вартості виклику функції, розміру функції та інших оптимізацій, які можуть бути виконані.

Вбудоване розширення найкраще підходить для простих, коротких функцій (наприклад, не більше кількох операторів), особливо у випадках, коли один виклик функції може виконуватися більше одного разу (наприклад, виклики функції всередині циклу).
## Коли відбувається розширення в лінію
Кожна функція потрапляє в одну з двох категорій, де відбувається її виклик:
- Може бути розширено (більшість функцій знаходяться в цій категорії).
- Не можна розширити.

Більшість функцій належать до категорії "можна": їхні виклики можна розширювати, якщо і коли це вигідно. Для функцій цієї категорії сучасний компілятор оцінює кожну функцію і кожен виклик функції, щоб визначити, чи виграє цей виклик від вбудованого розширення. Компілятор може вирішити не розширювати жодного, деякі або всі виклики функції для даної функції.

> [!NOTE]
> Сучасні оптимізуючі компілятори приймають рішення про те, коли функції слід розширювати в лінію.
## Історично склалося так, що ключове слово `inline`
Історично склалося так, що компілятори або не мали можливості визначати, чи буде корисним вбудоване розширення, або робили це не дуже добре. З цієї причини у C++ було передбачено ключове слово `inline`, яке спочатку призначалося для підказки компілятору, що функція (ймовірно) виграє, якщо її буде розширено в лінію.

Функція, яка оголошена з використанням ключового слова `inline`, називається **вбудованою функцією**.

Ось приклад використання ключового слова `inline`:
```cpp
#include <iostream>

inline int min(int x, int y) // inline keyword means this function is an inline function
{
    return (x < y) ? x : y;
}

int main()
{
    std::cout << min(5, 6) << '\n';
    std::cout << min(3, 2) << '\n';
    return 0;
}
```
Однак, у сучасному C++ ключове слово `inline` більше не використовується для запиту на розширення функції в рядку. На це є декілька причин:
- Використання `inline` для запиту розширення `inline` є формою передчасної оптимізації, і неправильне використання може фактично зашкодити продуктивності.
- Ключове слово `inline` - це лише підказка, яка допомагає компілятору визначити, де виконати вбудоване розширення. Компілятор має повне право проігнорувати запит, і він цілком може це зробити. Компілятор також може виконати вбудоване розширення функцій, які не використовують ключове слово `inline`, як частину свого звичайного набору оптимізацій.
- Ключове слово `inline` визначено на неправильному рівні деталізації. Ми використовуємо ключове слово `inline` у визначенні функції, але насправді розширення `inline` визначається для кожного виклику функції. Розширення одних викликів функцій може бути корисним, а інших - шкідливим, і синтаксис не може на це вплинути.

Сучасні оптимізуючі компілятори зазвичай добре визначають, які виклики функцій слід робити `inline` - у більшості випадків краще, ніж людина. Як наслідок, компілятор, швидше за все, проігнорує або знецінить будь-яке використання `inline`, вимагаючи розширення ваших функцій.
> [!tip]
> Не використовуйте ключове слово `inline` для запиту вбудованого розширення для ваших функцій.
## Вбудоване ключове слово, в сучасному розумінні
У попередніх розділах ми згадували, що не слід реалізовувати функції (із зовнішнім зв'язуванням) у заголовних файлах, тому що коли ці заголовки будуть включені в декілька файлів `.cpp`, визначення функції буде скопійовано в декілька файлів `.cpp`. Потім ці файли будуть скомпільовані, і компонувальник видасть помилку, оскільки помітить, що ви визначили одну і ту ж функцію більше одного разу, що є порушенням правила одного визначення.

У сучасній C++ термін `inline` став означати "дозволено декілька визначень". Таким чином, вбудована функція - це функція, яку дозволено визначати в декількох одиницях перекладу (не порушуючи ООП).

До вбудованих функцій висуваються дві основні вимоги:
- Компілятор повинен бачити повне визначення вбудованої функції в кожній одиниці перекладу, де вона використовується (одного прямого оголошення недостатньо). Визначення може міститися після точки використання, якщо також передбачено пряме оголошення. В одній одиниці перекладу може бути лише одне таке визначення, інакше виникне помилка компіляції.
- Кожне визначення для вбудованої функції має бути ідентичним, інакше це призведе до невизначеної поведінки.

> [!NOTE]
> Компілятор повинен бачити повне визначення вбудованої функції, де б вона не використовувалася, і всі такі визначення повинні бути ідентичними (інакше це призведе до невизначеної поведінки).

Компонувальник об'єднає всі вбудовані визначення функцій для ідентифікатора в одне визначення (таким чином все ще виконуючи вимоги правила одного визначення).

Ось приклад:

main.cpp:
```cpp
#include <iostream>

double circumference(double radius); // forward declaration

inline double pi() { return 3.14159; }

int main()
{
    std::cout << pi() << '\n';
    std::cout << circumference(2.0) << '\n';

    return 0;
}
```
math.cpp
```cpp
inline double pi() { return 3.14159; }

double circumference(double radius)
{
    return 2.0 * pi() * radius;
}
```
Зверніть увагу, що обидва файли містять визначення функції `pi()` - однак, оскільки цю функцію було позначено як вбудовану, це допустимо, і компонувальник видалить їх дублювання. Якщо ви видалите ключове слово `inline` з обох визначень `pi()`, ви отримаєте порушення ОВВ (оскільки дублювання визначень не вбудованих функцій заборонено).

Хоча історичне використання `inline` (для виконання вбудованого розширення) і сучасне використання `inline` (для забезпечення декількох визначень) може здатися дещо не пов'язаним, вони тісно взаємопов'язані між собою.

> [!NOTE]
> Історично, скажімо, у нас була якась тривіальна функція, яка чудово підходила для вбудованого розширення, тому ми позначили її як вбудовану. Для того, щоб дійсно виконати вбудоване розширення виклику функції, компілятор повинен мати можливість бачити повне визначення цієї функції у кожному блоці трансляції, де вона використовується - інакше він не знатиме, чим замінити кожен виклик функції. Функція, визначена в іншому модулі трансляції, не може бути розширена у поточному модулі трансляції, що компілюється.
> 
> Зазвичай тривіальні вбудовані функції потрібні в декількох блоках перекладу. Але як тільки ми копіюємо визначення функції в кожну одиницю перекладу (згідно з попередньою вимогою), це призводить до порушення вимоги УСО, згідно з якою функція може мати лише одне визначення в програмі. Найкращим рішенням цієї проблеми було просто зробити вбудовані функції вільними від вимоги ОДР щодо наявності лише одного визначення для однієї програми.
> 
> Історично ми використовували `inline` для запиту вбудованого розширення, а звільнення від УСО було необхідним для того, щоб такі функції можна було вбудовувати в декілька перекладацьких одиниць. Сьогодні ми використовуємо `inline` для звільнення від УСО й не дозволяємо компілятору обробляти функції вбудованого розширення. Механіка роботи вбудованих функцій не змінилася, змінився наш підхід.
> 
> Вам може бути цікаво, чому вбудованим функціям було дозволено не підпадати під дію УСО, але не вбудовані функції все ще повинні дотримуватися цієї частини УСО. У випадку з неінтегрованими функціями ми очікуємо, що функція буде визначена лише один раз (в одній одиниці перекладу). Якщо компонувальник зустрічає кілька визначень не вбудованої функції, він вважає, що це пов'язано з конфліктом імен між двома незалежно визначеними функціями. І будь-який виклик неінтегрованої функції з більш ніж одним визначенням призведе до потенційної неоднозначності щодо того, яке визначення є правильним для виклику. Але з вбудованими функціями всі визначення вважаються такими, що стосуються однієї і тієї ж вбудованої функції, тому виклики функцій у межах цього блоку перекладу можна розширювати в рядку. А якщо виклик функції не розгорнуто в лінію, немає ніякої неоднозначності щодо того, з яким із кількох визначень правильно співвідносити виклик - підійде будь-яке з них!

Вбудовані функції зазвичай визначаються у заголовних файлах, де вони можуть бути `#include` у верхній частині будь-якого файлу коду, який повинен бачити повне визначення ідентифікатора. Це гарантує, що всі визначення ідентифікатора будуть ідентичними.

pi.h:
```cpp
#ifndef PI_H
#define PI_H

inline double pi() { return 3.14159; }

#endif
```
main.cpp:
```cpp
#include "pi.h" // will include a copy of pi() here
#include <iostream>

double circumference(double radius); // forward declaration

int main()
{
    std::cout << pi() << '\n';
    std::cout << circumference(2.0) << '\n';

    return 0;
}
```
math.cpp
```cpp
#include "pi.h" // will include a copy of pi() here

double circumference(double radius)
{
    return 2.0 * pi() * radius;
}
```
Це особливо корисно для бібліотек, що містять лише заголовки, які являють собою один або декілька заголовних файлів, що реалізують певні можливості (файли `.cpp` не включаються). Бібліотеки, що містять лише заголовки, популярні тим, що для їх використання не потрібно додавати до проекту вихідні файли, а також не потрібно нічого компонувати. Ви просто `#include` бібліотеку заголовків і можете використовувати її.
> [!NOTE]
> Наступні функції є неявно вбудованими:
> - Функції, визначені всередині визначення типу класу, структури або об'єднання
> - Функції `constexpr` / `consteval`
> - Функції, неявно інстанційовані з шаблонів функцій

Здебільшого не слід позначати функції або змінні як вбудовані, якщо тільки ви не визначаєте їх у заголовному файлі (і вони вже не є вбудованими неявно).

> [!tip]
> Уникайте використання ключового слова `inline`, якщо у вас немає для цього конкретної, вагомої причини (наприклад, ви визначаєте ці функції або змінні у заголовному файлі).
## Чому б не зробити всі функції вбудованими та визначеними у заголовному файлі?
Головним чином тому, що це може значно збільшити час компіляції.

Коли заголовок, що містить вбудовану функцію, `#include` у вихідному файлі, визначення цієї функції буде скомпільовано як частина цієї одиниці трансляції. Вбудована функція `#include` у 6 одиницях трансляції буде скомпільована 6 разів (до того, як компонувальник дедуплікує визначення). І навпаки, функція, визначена у вихідному файлі, буде скомпільована лише один раз, незалежно від того, до скількох одиниць трансляції включено її пряме оголошення.

По-друге, якщо функція, визначена у вихідному файлі, змінюється, перекомпілювати потрібно тільки цей файл. Якщо змінюється вбудована функція в заголовному файлі, перекомпіляції потребує кожен файл коду, який містить цей заголовок (безпосередньо або через інший заголовок). У великих проектах це може спричинити каскад перекомпіляцій і мати значні наслідки.
## Вбудовані змінні `C++17`
У наведеному вище прикладі `pi()` було написано як функцію, що повертає константне значення. Було б простіше, якби `pi` було реалізовано як змінну (`const`). Однак, до C++17 це було пов'язано з певними перешкодами та неефективністю.

У C++17 з'явилися вбудовані змінні, тобто змінні, які можна визначати у декількох файлах. Інлайн-змінні працюють подібно до інлайн-функцій і мають ті ж самі вимоги (компілятор повинен бачити ідентичне повне визначення скрізь, де використовується змінна).
> [!NOTE]
> Наступні змінні є неявно вбудованими:
> - Статичні члени даних constexpr
> 
> На відміну від функцій constexpr, змінні constexpr не є вбудованими за замовчуванням (за винятком зазначених вище)!

