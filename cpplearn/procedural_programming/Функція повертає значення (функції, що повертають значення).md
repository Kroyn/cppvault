---
date: 2024-09-06
tags:
  - Процедурне_програмування
  - Основи
---
Розглянемо наступну програму:

```cpp
#include <iostream>

int main()
{
	// get a value from the user
	std::cout << "Enter an integer: ";
	int num{};
	std::cin >> num;

	// print the value doubled
	std::cout << num << " doubled is: " << num * 2 << '\n';

	return 0;
}
```

Ця програма складається з двох концептуальних частин: Спочатку ми отримуємо значення від користувача. Потім ми повідомляємо користувачеві, що це значення є подвійним.

Хоча ця програма досить тривіальна, і нам не потрібно розбивати її на декілька функцій, але що, якби ми захотіли? Отримання цілого значення від користувача - це чітко визначена робота, яку ми хочемо, щоб виконувала наша програма, тому вона може стати гарним кандидатом на функцію.

Отже, давайте напишемо програму для цього:

```cpp
// This program doesn't work
#include <iostream>

void getValueFromUser()
{
 	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;
}

int main()
{
	getValueFromUser(); // Ask user for input

	int num{}; // How do we get the value from getValueFromUser() and use it to initialize this variable?

	std::cout << num << " doubled is: " << num * 2 << '\n';

	return 0;
}
```

Хоча ця програма є гарною спробою вирішення проблеми, вона не зовсім працює.

Коли викликається функція `getValueFromUser`, користувача, як і очікувалося, просять ввести ціле число. Але введене значення втрачається, коли `getValueFromUser` завершується і керування повертається до main. Змінна `num` ніколи не ініціалізується значенням, яке ввів користувач, і тому програма завжди виводить відповідь `0`.

Нам бракує способу для `getValueFromUser` повернути значення, введене користувачем, назад до `main`, щоб `main` міг використати ці дані.
## Значення, що повертаються
Коли ви пишете користувацьку функцію, ви можете визначити, чи буде ваша функція повертати значення тому, хто її викликає, чи ні. Щоб повернути значення користувачеві, потрібні дві речі.

По-перше, ваша функція повинна вказати, який тип значення буде повернуто. Це робиться шляхом встановлення типу повернення функції, тобто типу, визначеного перед назвою функції. У наведеному вище прикладі функція `getValueFromUser` має тип повернення `void` (це означає, що користувачеві не буде повернуто жодного значення), а функція `main` має тип повернення `int` (це означає, що користувачеві буде повернуто значення типу `int`). Зверніть увагу, що це не визначає, яке саме значення буде повернуто - це лише визначає тип значення, яке буде повернуто.

По-друге, всередині функції, яка повертає значення, ми використовуємо інструкцію `return`, щоб вказати конкретне значення, яке повертається користувачеві. Конкретне значення, що повертається з функції, називається значенням, що повертається. Коли інструкція `return` виконується, функція негайно завершує свою роботу, а значення, що повертається, копіюється з функції назад викликаючому користувачеві. Цей процес називається поверненням за значенням.

Функція, що повертає значення, буде повертати значення при кожному її виклику.

Давайте розглянемо просту функцію, яка повертає ціле значення, і приклад програми, яка її викликає:

```cpp
#include <iostream>

// int is the return type
// A return type of int means the function will return some integer value to the caller (the specific value is not specified here)
int returnFive()
{
    // the return statement indicates the specific value that will be returned
    return 5; // return the specific value 5 back to the caller
}

int main()
{
    std::cout << returnFive() << '\n'; // prints 5
    std::cout << returnFive() + 2 << '\n'; // prints 7

    returnFive(); // okay: the value 5 is returned, but is ignored since main() doesn't do anything with it

    return 0;
}
```

При запуску ця програма друкує:

```cpp
5
7
```

Виконання починається з вершини `main`. У першому операторі обчислюється виклик функції `returnFive`, в результаті чого викликається функція `returnFive`. Функція `returnFive` повертає користувачеві конкретне значення `5`, яке потім виводиться на консоль через `std::cout`.

У другому виклику функції обчислюється виклик функції `returnFive`, що призводить до повторного виклику функції `returnFive`. Функція `returnFive` повертає значення `5` тому, хто її викликав. Вираз `5 + 2` обчислюється для отримання результату `7`, який потім виводиться на консоль через `std::cout`.

У третьому операторі знову викликається функція `returnFive`, в результаті чого користувачеві повертається значення `5`. Однак функція main нічого не робить з поверненим значенням, тому далі нічого не відбувається (повернене значення ігнорується).

Зауваження: Значення, що повертаються, не буде надруковано, якщо тільки користувач не надішле їх на консоль за допомогою `std::cout`. В останньому випадку, наведеному вище, значення, що повертається, не надсилається до `std::cout`, тому нічого не виводиться.
## Виправлення нашої програми челенджів
Маючи це на увазі, ми можемо виправити програму, яку ми представили на початку уроку:

```cpp
#include <iostream>

int getValueFromUser() // this function now returns an integer value
{
 	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;

	return input; // return the value the user entered back to the caller
}

int main()
{
	int num { getValueFromUser() }; // initialize num with the return value of getValueFromUser()

	std::cout << num << " doubled is: " << num * 2 << '\n';

	return 0;
}
```

Коли ця програма буде виконана, перший оператор в main створить змінну типу `int` з іменем `num`. Коли програма перейде до ініціалізації `num`, вона побачить, що є виклик функції `getValueFromUser()`, тому вона виконає цю функцію. Функція `getValueFromUser` просить користувача ввести значення, а потім повертає це значення тому, хто її викликав (`main()`). Це повернуте значення використовується як значення ініціалізації для змінної num. num можна використовувати стільки разів, скільки потрібно в `main()`.

> [!NOTE] 
> Якщо вам потрібно використати значення, що повертається при виклику функції, більше одного разу, ініціалізуйте змінну зі значенням, що повертається, а потім використовуйте цю змінну стільки разів, скільки потрібно.

Складіть цю програму самостійно і запустіть її кілька разів, щоб довести собі, що вона працює.
## Повторний виклик main()
Тепер у вас є концептуальні інструменти для розуміння того, як насправді працює функція `main()`. Коли програма виконується, операційна система здійснює виклик функції `main()`. Потім виконання переходить на початок `main()`. Оператори в `main()` виконуються послідовно. Нарешті, `main()` повертає ціле значення (зазвичай `0`), і ваша програма завершується.

У C++ заборонено явно викликати функцію `main()`.

За домовленістю, код стану `0` означає, що програма працювала нормально (тобто програма виконувалася і поводилася, як очікувалося).

> [!tip] 
> Ваша main функція повинна повертати значення 0, якщо програма працює нормально.

Ненульовий код стану часто використовується для того, щоб вказати на якусь несправність (і хоча це чудово працює в більшості операційних систем, строго кажучи, це не гарантує, що він буде переноситися).

> [!NOTE]
> Стандарт C++ визначає значення лише 3 кодів стану: `0`, `EXIT_SUCCESS` та `EXIT_FAILURE`. `0` і `EXIT_SUCCESS` означають, що програма виконалася успішно. `EXIT_FAILURE` означає, що програма не виконалася успішно.
> `EXIT_SUCCESS` і `EXIT_FAILURE` є макросами препроцесора, визначеними у заголовку:

```cpp
#include <cstdlib> // for EXIT_SUCCESS and EXIT_FAILURE

int main()
{
    return EXIT_SUCCESS;
}
```
> Якщо ви хочете максимізувати портативність, вам слід використовувати тільки `0` або `EXIT_SUCCESS` для позначення успішного завершення, або `EXIT_FAILURE` для позначення невдалого завершення.

> [!NOTE] 
> Код стану передається назад до операційної системи. Зазвичай операційна система робить код стану доступним для тієї програми, яка запустила програму, що повертає код стану. Це забезпечує грубий механізм для будь-якої програми, яка запускає іншу програму, щоб визначити, чи успішно запущена програма працювала чи ні.
## Функція, що повертає значення, яка не повертає значення, призведе до невизначеної поведінки
Функція, яка повертає значення, називається **функцією, що повертає значення**. Функція є функцією, що повертає значення, якщо тип повернення відмінний від `void`.

Функція, що повертає значення, повинна повертати значення цього типу (за допомогою оператора return), інакше це призведе до невизначеної поведінки.

Ось приклад функції, яка призводить до невизначеної поведінки:

```cpp
#include <iostream>

int getValueFromUserUB() // this function returns an integer value
{
 	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;

	// note: no return statement
}

int main()
{
	int num { getValueFromUserUB() }; // initialize num with the return value of getValueFromUserUB()

	std::cout << num << " doubled is: " << num * 2 << '\n';

	return 0;
}
```

Сучасний компілятор повинен згенерувати попередження, оскільки `getValueFromUserUB` визначено як таку, що повертає тип `int`, але не передбачено оператора return. Запуск такої програми призведе до невизначеної поведінки, оскільки `getValueFromUserUB()` є функцією, яка повертає значення, але не повертає його.

У більшості випадків компілятори виявлять, якщо ви забули повернути значення. Однак у деяких складних випадках компілятор може бути не в змозі правильно визначити, чи повертає ваша функція значення чи ні у всіх випадках, тому не варто на це покладатися.

> [!tip] Title
> Переконайтеся, що ваші функції з типами повернення не void повертають значення у всіх випадках.
> 
> Неможливість повернути значення з функції, що повертає значення, призведе до невизначеної поведінки.
## Функція main неявно поверне 0, якщо не вказано оператор return
Єдиний виняток з правила, що функція, яка повертає значення, повинна повертати значення за допомогою оператора `return`, стосується функції `main()`. Функція `main()` неявно поверне значення `0`, якщо в ній не вказано оператор `return`. Тим не менш, найкращою практикою є явне повернення значення з `main`, як для демонстрації ваших намірів, так і для узгодженості з іншими функціями (які демонструватимуть невизначену поведінку, якщо не буде вказано значення, що повертається).
## Функції можуть повертати лише одне значення
Функція, що повертає значення, може повертати користувачеві лише одне значення при кожному виклику.

Зверніть увагу, що значення, яке повертається в операторі return, не обов'язково має бути буквальним - це може бути результат будь-якого допустимого виразу, включаючи змінну або навіть виклик іншої функції, яка повертає значення. У наведеному вище прикладі `getValueFromUser()` ми повернули змінну `input`, яка містила число, введене користувачем.

Існують різні способи обійти обмеження функцій, які можуть повертати лише одне значення, і ми розглянемо їх у наступних уроках.
## Автор функції може вирішити, що означає значення, яке повертається
Значення значення, що повертається функцією, визначається автором функції. Деякі функції використовують значення, що повертаються, як коди стану, щоб вказати, успішно вони виконалися чи ні. Інші функції повертають обчислене або вибране значення. Треті функції не повертають нічого (приклади таких функцій ми розглянемо у наступному уроці).

Через широке розмаїття можливостей, варто супроводжувати функцію коментарями, які вказують, що означають значення, які вона повертає. Наприклад:

```cpp
// Function asks user to enter a value
// Return value is the integer entered by the user from the keyboard
int getValueFromUser()
{
 	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;

	return input; // return the value the user entered back to the caller
}
```
## Повторне використання функцій
Тепер ми можемо проілюструвати хороший випадок повторного використання функцій. Розглянемо наступну програму:

```cpp
#include <iostream>

int main()
{
	int x{};
	std::cout << "Enter an integer: ";
	std::cin >> x;

	int y{};
	std::cout << "Enter an integer: ";
	std::cin >> y;

	std::cout << x << " + " << y << " = " << x + y << '\n';

	return 0;
}
```

Хоча ця програма працює, вона трохи надлишкова. Насправді, ця програма порушує один з центральних принципів хорошого програмування: **Не повторюйся** (часто скорочено **DRY**).

Чому повторюваний код - це погано? Якщо ми хочемо змінити текст "Введіть ціле число:" на щось інше, нам доведеться оновити його у двох місцях. А що, якби ми хотіли ініціалізувати 10 змінних замість 2? Це було б багато надлишкового коду (що зробило б наші програми довшими і складнішими для розуміння), а також багато місця, де могли б закрастися друкарські помилки.

Давайте оновимо цю програму, щоб використовувати нашу функцію `getValueFromUser`, яку ми розробили вище:

```cpp
#include <iostream>

int getValueFromUser()
{
 	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;

	return input;
}

int main()
{
    int x{ getValueFromUser() }; // first call to getValueFromUser
    int y{ getValueFromUser() }; // second call to getValueFromUser

    std::cout << x << " + " << y << " = " << x + y << '\n';

    return 0;
}
```

Ця програма виводить наступний результат:

```cpp
Enter an integer: 5
Enter an integer: 7
5 + 7 = 12
```

У цій програмі ми викликаємо `getValueFromUser` двічі, один раз для ініціалізації змінної `x`, і один раз для ініціалізації змінної `y`. Це позбавляє нас від дублювання коду для отримання даних від користувача і зменшує ймовірність помилки. Після того, як ми знаємо, що `getValueFromUser` працює, ми можемо викликати її стільки разів, скільки забажаємо.

У цьому полягає суть модульного програмування: можливість написати функцію, протестувати її, переконатися, що вона працює, а потім знати, що ми можемо використовувати її повторно стільки разів, скільки захочемо, і вона продовжуватиме працювати (доки ми не модифікуємо функцію - в цей момент нам доведеться повторно її протестувати).

> [!tip] 
> Дотримуйтесь DRY: "не повторюйся". Якщо вам потрібно зробити щось більше одного разу, подумайте, як модифікувати код, щоб прибрати якомога більше надмірності. Змінні можна використовувати для зберігання результатів обчислень, які потрібно використовувати більше одного разу (щоб не повторювати обчислення). Функції можна використовувати для визначення послідовності операторів, які ми хочемо виконати більше одного разу. А цикли (про які ми поговоримо у наступній главі) можна використовувати для виконання оператора більше одного разу.
> 
> Як і всі найкращі практики, DRY є рекомендацією, а не абсолютом. Читач Yariv зауважив, що DRY може зашкодити загальному розумінню, коли код розбивається на занадто малі частини.

> [!NOTE] 
> Протилежністю DRY є WET ("Пиши все двічі").
## Висновок
Значення, що повертаються, дозволяють функціям повертати єдине значення назад тому, хто їх викликає.

Функції дозволяють мінімізувати надмірність у наших програмах.