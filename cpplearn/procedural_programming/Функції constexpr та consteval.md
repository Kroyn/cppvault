---
date: 2024-09-23
tags:
  - Процедурне_програмування
  - Фундаментальні_типи_дани
---
Однією з проблем з константними виразами є те, що у константних виразах не допускаються виклики звичайних функцій. Це означає, що ми не можемо використовувати такі виклики функцій скрізь, де потрібен константний вираз.

Розглянемо наступну програму:
```cpp
#include <iostream>

int main()
{
    constexpr double radius { 3.0 };
    constexpr double pi { 3.14159265359 };
    constexpr double circumference { 2.0 * radius * pi };

    std::cout << "Our circle has circumference " << circumference << "\n";

    return 0;
}
```
Це дає результат:
```
Our circle has circumference 18.8496
```

Маючи складний ініціалізатор для `circumference` не дуже вдалий (і вимагає від нас обчислення двох допоміжних змінних, `radius` та `pi`). Тому давайте зробимо його функцією:
```cpp
#include <iostream>

double calcCircumference(double radius)
{
    constexpr double pi { 3.14159265359 };
    return 2.0 * pi * radius;
}

int main()
{
    constexpr double circumference { calcCircumference(3.0) }; // compile error

    std::cout << "Our circle has circumference " << circumference << "\n";

    return 0;
}
```
Цей код набагато чистіший. Він також не компілюється. Змінна `constexpr` `circumference` вимагає, щоб її ініціалізатор був константним виразом, а виклик `calcCircumference()` не є константним виразом.

У цьому конкретному випадку ми могли б зробити `circumference` неконстантним, і програма скомпілювалася б. Хоча ми втратили б переваги константних виразів, принаймні програма працювала б.

Однак, у C++ існують інші випадки (з якими ми познайомимося у майбутньому), коли у нас немає альтернативних варіантів, і нам підійде лише константний вираз. У таких випадках ми дуже хотіли б мати можливість використовувати функції, але виклики звичайних функцій просто не працюватимуть. Що ж нам робити?
## Функції `constexpr` можна використовувати у константних виразах
**Функція `constexpr`** - це функція, яку можна викликати у константному виразі.

Щоб зробити функцію константною, ми просто використовуємо ключове слово `constexpr` перед типом повернення функції.

> [!NOTE]
> Ключове слово `constexpr` використовується для сигналізації компілятору та іншим розробникам про те, що функцію можна використовувати у константному виразі.

Ось той самий приклад, що і вище, але з використанням функції `constexpr`:
```cpp
#include <iostream>

constexpr double calcCircumference(double radius) // now a constexpr function
{
    constexpr double pi { 3.14159265359 };
    return 2.0 * pi * radius;
}

int main()
{
    constexpr double circumference { calcCircumference(3.0) }; // now compiles

    std::cout << "Our circle has circumference " << circumference << "\n";

    return 0;
}
```
Оскільки `calcCircumference()` тепер є функцією `constexpr`, її можна використовувати у константному виразі, наприклад, в ініціалізаторі окружності.
## Функції `constexpr` можна обчислювати під час компіляції
Якщо константний вираз містить виклик функції `constexpr`, цей виклик функції `constexpr` має обчислюватися під час компіляції.

У нашому прикладі вище змінна `circumference` має тип `constexpr` і тому потребує ініціалізатора константного виразу. Оскільки `calcCircumference()` є частиною цього необхідного константного виразу, `calcCircumference()` має бути обчислена під час компіляції.

Коли виклик функції обчислюється під час компіляції, компілятор обчислює значення, що повертається під час виклику функції, а потім замінює виклик функції значенням, що повертається.

Отже, у нашому прикладі виклик `calcCircumference(3.0)` буде замінено на результат виклику функції, який дорівнює `18.8496`. Іншими словами, компілятор скомпілює це:
```cpp
#include <iostream>

constexpr double calcCircumference(double radius)
{
    constexpr double pi { 3.14159265359 };
    return 2.0 * pi * radius;
}

int main()
{
    constexpr double circumference { 18.8496 };

    std::cout << "Our circle has circumference " << circumference << "\n";

    return 0;
}
```
Для оцінки під час компіляції, дві інші речі також повинні бути істинними:
- Виклик функції `constexpr` повинен мати аргументи, які відомі під час компіляції (наприклад, константні вирази).
- Усі оператори та вирази у функції `constexpr` повинні бути обчислюваними під час компіляції.

Коли функція `constexpr` (або `consteval`) обчислюється під час компіляції, всі інші функції, які вона викликає, також мають бути обчислені під час компіляції (інакше початкова функція не зможе повернути результат під час компіляції).

> [!NOTE]
> Існують також деякі інші критерії, які зустрічаються рідше. З ними можна ознайомитися [тут](https://en.cppreference.com/w/cpp/language/constexpr).
## Функції `constexpr` також можна обчислювати під час виконання
Функції `constexpr` також можна обчислювати під час виконання, у цьому випадку вони повертатимуть неконтекстний результат. Наприклад:
```cpp
#include <iostream>

constexpr int greater(int x, int y)
{
    return (x > y ? x : y);
}

int main()
{
    int x{ 5 }; // not constexpr
    int y{ 6 }; // not constexpr

    std::cout << greater(x, y) << " is greater!\n"; // will be evaluated at runtime

    return 0;
}
```
У цьому прикладі, оскільки аргументи `x` та `y` не є константними виразами, функція не може бути визначена під час компіляції. Однак, функція все одно буде розпізнана під час виконання, повернувши очікуване значення у вигляді неконстантного типу `int`.
> [!NOTE]
> Коли функція `constexpr` обчислюється під час виконання, вона обчислюється так само, як і звичайна (не `constexpr`) функція. Іншими словами, у цьому випадку `constexpr` не має жодного ефекту.

> [!NOTE]
> Було дозволено обчислювати функції з типом повернення constexpr як під час компіляції, так і під час виконання, щоб одна функція могла обслуговувати обидва випадки.
> 
> В іншому випадку вам потрібно було б мати окремі функції (функцію з типом повернення constexpr і функцію з типом повернення не constexpr). Це призвело б не лише до дублювання коду, але й до того, що ці дві функції мали б мати різні назви!
## Виклики функцій `constexpr` у необов'язкових константних виразах
Можна було б очікувати, що функція `constexpr` буде обчислюватися під час компіляції, коли це можливо, але, на жаль, це не так.

Ми зазначили, що у контекстах, які не вимагають константних виразів, компілятор може вибирати, чи обчислювати константний вираз під час компіляції, чи під час виконання. Відповідно, будь-який виклик функції `constexpr`, що є частиною необов'язкового константного виразу, може бути обчислено як під час компіляції, так і під час виконання.

Наприклад:
```cpp
#include <iostream>

constexpr int getValue(int x)
{
    return x;
}

int main()
{
    int x { getValue(5) }; // may evaluate at runtime or compile-time

    return 0;
}
```
У наведеному вище прикладі, оскільки `getValue()` є `constexpr`, виклик `getValue(5)` є константним виразом. Однак, оскільки змінна x не є `constexpr`, вона не потребує ініціалізатора константного виразу. Отже, незважаючи на те, що ми надали ініціалізатор константного виразу, компілятор вільний вибирати, де обчислювати `getValue(5)` - під час виконання чи під час компіляції.
> [!NOTE]
> Обчислення функцій `constexpr` під час компіляції гарантується лише тоді, коли потрібен константний вираз.
## Діагностика функцій constexpr
Компілятор не зобов'язаний визначати, чи можна обчислити функцію `constexpr` під час компіляції, доки вона не буде фактично обчислена під час компіляції. Досить легко написати функцію `constexpr`, яка успішно компілюється для використання під час виконання, але потім не компілюється, коли її викликають під час компіляції.

Як дурний приклад цього:
```cpp
#include <iostream>

int getValue(int x)
{
    return x;
}

// This function can be evaluated at runtime
// When evaluated at compile-time, the function will produce a compilation error
// because the call to getValue(x) cannot be resolved at compile-time
constexpr int foo(int x)
{
    return getValue(x); // call to non-constexpr function here
}

int main()
{
    int x { foo(5) };           // okay: will evaluate at runtime
    constexpr int y { foo(5) }; // compile error: foo(5) can't evaluate at compile-time

    return 0;
}
```
У наведеному вище прикладі, коли `foo(5)` використовується як ініціалізатор для неконтекстної змінної `x`, вона буде обчислена під час виконання програми. Це працює добре і повертає значення `5`.

Однак, коли `foo(5)` використовується як ініціалізатор для змінної `constexpr` y, вона має бути обчислена під час компіляції. У цей момент компілятор визначить, що виклик `foo(5)` не може бути обчислений під час компіляції, оскільки `getValue()` не є функцією `constexpr`.

Тому, коли ви пишете функцію `constexpr`, завжди явно перевіряйте, що вона компілюється під час компіляції (викликаючи її у контексті, де потрібен константний вираз, наприклад, під час ініціалізації змінної `constexpr`).
> [!tip]
> Усі функції `constexpr` слід обчислювати під час компіляції, оскільки це буде потрібно у контекстах, які вимагають константних виразів.
> 
> Завжди тестуйте функції `constexpr` у контексті, що вимагає константних виразів, оскільки функція `constexpr` може працювати під час обчислення під час виконання, але не працювати під час обчислення під час компіляції.
## Параметри функції `constexpr`/`consteval` не є параметрами функції `constexpr`
Параметри функції `constexpr` не є неявно `constexpr` і не можуть бути оголошені як `constexpr`.
> [!NOTE]
> Параметр функції `constexpr` означає, що функцію можна викликати лише з аргументом `constexpr`. Але це не так - функції з параметром `constexpr` можна викликати і з іншими аргументами, коли функція обчислюється під час виконання.

Оскільки такі параметри не є `constexpr`, їх не можна використовувати у константних виразах всередині функції.
```cpp
#include <iostream>

consteval int goo(int c)    // c is not constexpr, and cannot be used in constant expressions
{
    return c;
}

constexpr int foo(int b)    // b is not constexpr, and cannot be used in constant expressions
{
    constexpr int b2 { b }; // compile error: constexpr variable requires constant expression initializer

    return goo(b);          // compile error: consteval function call requires constant expression argument
}

int main()
{
    constexpr int a { 5 };

    std::cout << foo(a); // okay: constant expression a can be used as argument to constexpr function foo()

    return 0;
}
```
У наведеному вище прикладі параметр функції `b` не є `constexpr` (хоча аргумент a є константним виразом). Це означає, що `b` не можна використовувати там, де потрібен константний вираз, наприклад, в ініціалізаторі змінної `constexpr` (наприклад, `b2`) або у виклику константної функції (`goo(b)`).

Параметри функцій `constexpr` можуть бути оголошені як `const`, у цьому випадку вони розглядаються як константи часу виконання.
## Функції `constexpr` є неявно вбудованими
Коли функція `constexpr` обчислюється під час компіляції, компілятор повинен мати можливість бачити повне визначення функції `constexpr` до виклику цієї функції (щоб він міг виконати її обчислення). У цьому випадку прямого оголошення буде недостатньо, навіть якщо фактичний опис функції з'являється пізніше у тому самому блоці компіляції.

Це означає, що функція `constexpr`, яка викликається у кількох файлах, повинна мати свій опис у кожному блоці трансляції - що зазвичай є порушенням правила одного визначення. Щоб уникнути таких проблем, функції `constexpr` неявно є вбудованими, що звільняє їх від правила одного визначення.

Як наслідок, функції `constexpr` часто визначаються в заголовних файлах, тому їх можна `#include` в будь-який .cpp-файл, який вимагає повного визначення.
> [!NOTE]
> Компілятор повинен бачити повне визначення функції `constexpr` (або `consteval`), а не лише пряме оголошення.

> [!tip]
> Функції `constexpr`/`consteval`, що використовуються в одному вихідному файлі (`.cpp`), можуть бути визначені у вихідному файлі вище, де вони використовуються.
> 
> Функції `constexpr`/`consteval`, що використовуються в декількох вихідних файлах, слід визначати в заголовному файлі, щоб їх можна було включити в кожен вихідний файл.

Для викликів функцій `constexpr`, які обчислюються лише під час виконання, достатньо прямого оголошення, щоб задовольнити компілятор.
## Підсумок
Позначення функції як `constexpr` означає, що її можна використовувати у константному виразі. Це не означає "буде обчислюватися під час компіляції".

Константний вираз (який може містити виклики функції `constexpr`) потрібно обчислювати під час компіляції лише у контекстах, де потрібен константний вираз.

У контекстах, де константний вираз не потрібен, компілятор може вибрати, чи обчислювати константний вираз (який може містити виклики функцій `constexpr`) під час компіляції, чи під час виконання.

Неконстантний вираз (який може містити виклики функцій `constexpr` або неконстантні виклики функцій) буде обчислено під час виконання.
> [!NOTE]
> Розділи, наведені вище цієї авторської примітки, містять найважливішу інформацію про функції `constexpr`. Решта цього уроку містить інформацію, яку вам варто прочитати, але вона менш важлива для глибокого розуміння.
## Інший приклад
Давайте розглянемо ще один приклад, щоб з'ясувати, як функція `constexpr` повинна або може обчислюватися далі:
```cpp
#include <iostream>

constexpr int greater(int x, int y)
{
    return (x > y ? x : y);
}

int main()
{
    constexpr int g { greater(5, 6) };              // case 1: always evaluated at compile-time
    std::cout << g << " is greater!\n";

    std::cout << greater(5, 6) << " is greater!\n"; // case 2: may be evaluated at either runtime or compile-time

    int x{ 5 }; // not constexpr but value is known at compile-time
    std::cout << greater(x, 6) << " is greater!\n"; // case 3: likely evaluated at runtime

    std::cin >> x;
    std::cout << greater(x, 6) << " is greater!\n"; // case 4: always evaluated at runtime

    return 0;
}
```
У випадку 1 ми викликаємо `greater()` у контексті, який вимагає константного виразу. Таким чином, `greater()` повинна бути обчислена під час компіляції.

У випадку 2 функція `greater()` викликається у контексті, який не вимагає константного виразу, оскільки оператори виводу повинні виконуватися під час виконання програми. Однак, оскільки аргументи є константними виразами, функцію можна обчислити під час компіляції. Таким чином, компілятор може вільно вибирати, чи буде цей виклик `greater()` обчислено під час компіляції, чи під час виконання.

У випадку 3 ми викликаємо `greater()` з одним аргументом, який не є константним виразом. Отже, цей виклик, як правило, буде виконано під час виконання.

Однак цей аргумент має значення, яке відоме під час компіляції. За правилом as-if компілятор може вирішити вважати обчислення x константним виразом і обчислити цей виклик `greater()` під час компіляції. Але, швидше за все, він обчислить його під час виконання.
> [!NOTE]
> Зауважте, що навіть неконтекстні функції можуть бути обчислені під час компіляції за правилом as-if!

У випадку 4 значення аргументу `x` не може бути відомим під час компіляції, тому цей виклик `greater()` завжди буде обчислюватися під час виконання.

> [!NOTE]
> Інакше кажучи, ми можемо класифікувати ймовірність того, що функція дійсно буде обчислена під час компіляції, наступним чином:
> 
> Завжди (вимагається стандартом):
> - Функція `constexpr` викликається там, де потрібен константний вираз.
> - Функція `constexpr` викликається з іншої функції, яка обчислюється під час компіляції.
> Ймовірно (немає особливих причин не робити цього):
> - Функція `constexpr` викликається там, де константний вираз не потрібен, всі аргументи є константними виразами.
> Можливо (якщо оптимізовано за правилом "якби"):
> - Функція `constexpr` викликається там, де константний вираз не потрібен, деякі аргументи не є константними виразами, але їх значення відомі під час компіляції.
> - Неконтекстна функція, яку можна обчислити під час компіляції, всі аргументи є константними виразами.
> Ніколи (неможливо):
> - Функція `constexpr` викликається там, де константний вираз не потрібен, а деякі аргументи мають значення, які не відомі під час компіляції.

Зауважте, що налаштування рівня оптимізації вашого компілятора може вплинути на те, чи вирішить він обчислювати функцію під час компіляції, чи під час виконання. Це також означає, що ваш компілятор може робити різний вибір для налагоджувальних і релізних збірок (оскільки у налагоджувальних збірках оптимізацію зазвичай вимкнено).

Наприклад, і gcc, і Clang не обчислюватимуть під час компіляції функцію `constexpr`, викликану там, де константний вираз не вимагається, якщо компілятору не буде вказано оптимізувати код (наприклад, за допомогою опції компілятора -O2).
> [!NOTE]
> Компілятор також може вбудувати виклик функції або навіть повністю оптимізувати виклик функції. Обидва ці способи можуть вплинути на те, коли (або якщо) буде обчислено вміст виклику функції.
## Визначення того, чи виклик функції `constexpr` обчислюється під час компіляції чи під час виконання
Наразі C++ не надає жодних надійних механізмів для цього.
## Як щодо `std::is_constant_evaluated` або `if consteval`? `Розширений`
Жодна з цих можливостей не показує, коли відбувається обчислення виклику функції - під час компіляції чи під час виконання.

`std::is_constant_evaluated()` (визначена у заголовку `<type_traits>`) повертає `bool`, який вказує, чи виконується поточна функція у контексті з константною оцінкою. Контекст з константною оцінкою (також званий константним контекстом) визначається як такий, у якому потрібен константний вираз (наприклад, ініціалізація змінної `constexpr`). Отже, у випадках, коли компілятор повинен обчислити константний вираз під час компіляції, `std::is_constant_evaluated()` буде істинною, як і очікувалося.

Це зроблено для того, щоб ви могли зробити щось подібне:
```cpp
#include <type_traits> // for std::is_constant_evaluated()

constexpr int someFunction()
{
    if (std::is_constant_evaluated()) // if evaluating in constant context
        doSomething();
    else
        doSomethingElse();
}
```
Однак компілятор може також вирішити обчислити функцію `constexpr` під час компіляції у контексті, який не вимагає константного виразу. У таких випадках `std::is_constant_evaluated()` поверне `false`, навіть якщо функцію було обчислено під час компіляції. Отже, `std::is_constant_evaluated()` насправді означає "компілятор змушують обчислити це під час компіляції", а не "це обчислюється під час компіляції".

> [!NOTE]
> Хоча це може здатися дивним, на це є кілька причин:
> 1. Як зазначено у [документі, який запропонував цю функцію](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0595r2.html), стандарт фактично не робить різниці між "часом компіляції" та "часом виконання". Визначення поведінки з урахуванням цієї різниці було б більш значною зміною.
> 2. Оптимізації не повинні змінювати спостережувану поведінку програми (якщо це явно не дозволено стандартом). Якщо `std::is_constant_evaluated()` з якихось причин повертає `true`, коли функція обчислюється під час компіляції, то оптимізатор, який вирішив обчислити функцію під час компіляції, а не під час виконання, може потенційно змінити поведінку функції, яку можна спостерігати. Як наслідок, ваша програма може поводитися дуже по-різному залежно від того, з яким рівнем оптимізації її було скомпільовано!
> 
> Хоча цю проблему можна вирішити різними способами, деякі з них пов'язані з додаванням додаткової складності для оптимізатора та/або обмеженням його здатності оптимізувати певні випадки.

Введена в C++23, `if consteval` є заміною `if (std::is_constant_evaluated())`, яка забезпечує кращий синтаксис і виправляє деякі інші проблеми. Однак, вона обчислює так само.
## Примусовий виклик функції `constexpr` під час компіляції
Не існує способу вказати компілятору, що функція `constexpr` має обчислюватися під час компіляції, коли це можливо (наприклад, у випадках, коли значення, що повертається функцією `constexpr`, використовується у неконстантному виразі).

Однак ми можемо змусити функцію `constexpr`, яка має право на обчислення під час компіляції, дійсно обчислюватися під час компіляції, переконавшись, що значення, яке повертається, використовується там, де потрібно константний вираз. Це потрібно робити для кожного виклику окремо.

Найпоширеніший спосіб зробити це - використати значення, що повертається, для ініціалізації змінної `constexpr` (саме тому у попередніх прикладах ми використовували змінну 'g'). На жаль, це вимагає введення нової змінної в нашу програму лише для забезпечення оцінки під час компіляції, що є негарним і знижує читабельність коду.
> [!NOTE]
> Існує декілька хакерських способів, якими люди намагалися обійти проблему необхідності введення нової змінної `constexpr` кожного разу, коли ми хочемо примусово обчислити її під час компіляції. Дивіться [тут](https://quuxplusone.github.io/blog/2018/08/07/force-constexpr/) і [тут](https://artificial-mind.net/blog/2020/11/14/cpp17-consteval).

Однак, у C++20 є кращий обхідний шлях для вирішення цієї проблеми, про який ми розповімо трохи пізніше.
## Consteval `C++20`
У C++20 введено ключове слово `consteval`, яке використовується для вказівки на те, що функція повинна обчислюватися під час компіляції, інакше виникне помилка компіляції. Такі функції називаються безпосередніми функціями.
```cpp
#include <iostream>

consteval int greater(int x, int y) // function is now consteval
{
    return (x > y ? x : y);
}

int main()
{
    constexpr int g { greater(5, 6) };              // ok: will evaluate at compile-time
    std::cout << g << '\n';

    std::cout << greater(5, 6) << " is greater!\n"; // ok: will evaluate at compile-time

    int x{ 5 }; // not constexpr
    std::cout << greater(x, 6) << " is greater!\n"; // error: consteval functions must evaluate at compile-time

    return 0;
}
```
У наведеному вище прикладі перші два виклики `greater()` будуть обчислені під час компіляції. Виклик `greater(x, 6)` не може бути обчислений під час компіляції, тому виникне помилка компіляції.
> [!tip]
> Використовуйте `consteval`, якщо у вас є функція, яка з якихось причин повинна обчислюватися під час компіляції (наприклад, тому що вона робить щось, що може бути зроблено тільки під час компіляції).

Можливо, вас здивує, що параметри константної функції не є `constexpr` (хоча константні функції можна обчислювати лише під час компіляції). Таке рішення було прийнято заради узгодженості.
## Використання `consteval` для виконання `constexpr` під час компіляції `C++20`
Недоліком `consteval` функцій є те, що такі функції не можуть обчислюватись під час виконання, що робить їх менш гнучкими, ніж функції `constexpr`, які можуть робити і те, і інше. Тому було б корисно мати зручний спосіб змусити функції `constexpr` обчислюватись під час компіляції (навіть якщо значення, що повертається, використовується там, де константний вираз не потрібен), щоб мати можливість обчислюватись під час компіляції, коли це можливо, і обчислюватись під час виконання, коли це не можливо.

Функції `consteval` надають спосіб зробити це за допомогою акуратної допоміжної функції:
```cpp
#include <iostream>

// Uses abbreviated function template (C++20) and `auto` return type to make this function work with any type of value
// See 'related content' box below for more info (you don't need to know how these work to use this function)
consteval auto compileTimeEval(auto value)
{
    return value;
}

constexpr int greater(int x, int y) // function is constexpr
{
    return (x > y ? x : y);
}

int main()
{
    std::cout << greater(5, 6) << '\n';                  // may or may not execute at compile-time
    std::cout << compileTimeEval(greater(5, 6)) << '\n'; // will execute at compile-time

    int x { 5 };
    std::cout << greater(x, 6) << '\n';                  // we can still call the constexpr version at runtime if we wish

    return 0;
}
```
Це працює тому, що `consteval` функції вимагають константні вирази як аргументи - отже, якщо ми використовуємо значення, що повертається функцією `constexpr`, як аргумент константної функції, функція `constexpr` має бути обчислена під час компіляції! Функція `consteval` просто повертає цей аргумент як своє власне значення, тому користувач може використовувати його.

Зверніть увагу, що функція `consteval` повертає значення. Хоча це може бути неефективно робити під час виконання (якщо значення є типом, який дорого копіювати, наприклад, `std::string`), під час компіляції це не має значення, оскільки весь виклик функції `consteval` буде просто замінено обчисленим значенням, що повертається.
## Функції `constexpr`/`consteval` можуть використовувати локальні змінні, що не є константами
У функції `constexpr` або `consteval` можна використовувати локальні змінні, які не є `constexpr`, і значення цих змінних можна змінювати.

Як дурний приклад:
```cpp
#include <iostream>

consteval int doSomething(int x, int y) // function is consteval
{
    x = x + 2;       // we can modify the value of non-const function parameters

    int z { x + y }; // we can instantiate non-const local variables
    if (x > y)
        z = z - 1;   // and then modify their values

    return z;
}

int main()
{
    constexpr int g { doSomething(5, 6) };
    std::cout << g << '\n';

    return 0;
}
```
Коли такі функції обчислюються під час компіляції, компілятор фактично "виконує" функцію і повертає обчислене значення.
## Функції `constexpr`/`consteval` можуть використовувати параметри функції та локальні змінні як аргументи у викликах функцій `constexpr`
Вище ми зазначали: "Коли функція `constexpr` (або `consteval`) обчислюється під час компіляції, всі інші функції, які вона викликає, також мають бути обчислені під час компіляції".

Можливо, вас здивує, але функція `constexpr` або `consteval` може використовувати параметри своєї функції (які не є `constexpr`) або навіть локальні змінні (які можуть взагалі не бути `const`) як аргументи у виклику функції `constexpr`. Коли функція `constexpr` або `consteval` обчислюється під час компіляції, значення всіх параметрів функції та локальних змінних мають бути відомі компілятору (інакше він не зможе обчислити їх під час компіляції). Тому у цьому конкретному контексті C++ дозволяє використовувати ці значення як аргументи у виклику функції `constexpr`, і цей виклик функції `constexpr` все одно може бути обчислений під час компіляції.
```cpp
#include <iostream>

constexpr int goo(int c) // goo() is now constexpr
{
    return c;
}

constexpr int foo(int b) // b is not a constant expression within foo()
{
    return goo(b);       // if foo() is resolved at compile-time, then `goo(b)` can also be resolved at compile-time
}

int main()
{
    std::cout << foo(5);

    return 0;
}
```
У наведеному вище прикладі `foo(5)` може обчислюватися, а може і не обчислюватися під час компіляції. Якщо це так, то компілятор знає, що `b` дорівнює `5`. І навіть якщо `b` не є константним, компілятор може вважати виклик `goo(b)` викликом `goo(5)` і обчислити цей виклик функції під час компіляції. Якщо `foo(5)` натомість обчислюється під час виконання, то і `goo(b)` також буде обчислюватися під час виконання.
## Чи може функція `constexpr` викликати функцію не-constexpr?
Відповідь - так, але тільки тоді, коли функція `constexpr` обчислюється у неконстантному контексті. Не можна викликати неконстантну функцію, коли функція `constexpr` обчислюється у константному контексті (оскільки тоді функція `constexpr` не зможе створити значення константи часу компіляції), і це призведе до помилки компіляції.

Виклик неконтекстної функції дозволяється для того, щоб функція `constexpr` могла зробити щось подібне:
```cpp
#include <type_traits> // for std::is_constant_evaluated

constexpr int someFunction()
{
    if (std::is_constant_evaluated()) // if evaluating in constant context
        return someConstexprFcn();
    else
        return someNonConstexprFcn();
}
```
Тепер розглянемо такий варіант:
```cpp
constexpr int someFunction(bool b)
{
    if (b)
        return someConstexprFcn();
    else
        return someNonConstexprFcn();
}
```
Це законно, якщо тільки `someFunction(false)` ніколи не викликається у константному виразі.

> [!NOTE]
> До версії C++23 стандарт C++ говорить, що функція `constexpr` повинна повертати значення `constexpr` принаймні для одного набору аргументів, інакше вона є технічно неправильно оформленою. Безумовний виклик функції, яка не є `constexpr`, у функції `constexpr` робить функцію `constexpr` неправильно сформованою. Однак компілятори не зобов'язані видавати помилки або попередження у таких випадках - отже, компілятор, ймовірно, не буде скаржитися, якщо ви не спробуєте викликати таку функцію `constexpr` у константному контексті. У C++23 цю вимогу було скасовано.

Для досягнення найкращих результатів ми рекомендуємо наступне:
1. Якщо можливо, уникайте виклику неконтекстних функцій з контекстної функції.
2. Якщо ваша функція `constexpr` вимагає різної поведінки для константних і неконстантних контекстів, зумовте поведінку за допомогою `if (std::is_constant_evaluated())` (у C++20) або `if consteval` (C++23 і далі).
3. Завжди тестуйте ваші функції `constexpr` у постійному контексті, оскільки вони можуть працювати при виклику у непостійному контексті, але не працювати у постійному контексті.
## Чому б не створити `constexpr` для кожної функції?
Існує декілька причин, чому ви можете не захотіти `constexpr` функцію:
1. `constexpr` сигналізує, що функція може бути використана у константному виразі. Якщо ваша функція не може бути обчислена як частина константного виразу, її не слід позначати як `constexpr`.
2. `constexpr` є частиною інтерфейсу функції. Після того, як функція стає константною, її можна викликати іншими константними функціями або використовувати у контекстах, що вимагають константних виразів. Видалення `constexpr` пізніше призведе до зламу такого коду.
3. `constexpr` ускладнює налагодження функцій, оскільки ви не можете перевіряти їх під час виконання.
## Навіщо створювати контексну функцію, якщо вона фактично не обчислюється під час компіляції?
Програмісти-початківці іноді запитують: "Навіщо мені констатувати функцію, якщо вона обчислюється у моїй програмі лише під час виконання (наприклад, тому що аргументи у виклику функції не є константами)?".

Існує декілька причин:
1. Використання `constexpr` не має суттєвих недоліків і може допомогти компілятору оптимізувати вашу програму, щоб вона була меншою і швидшою.
2. Те, що ви зараз не викликаєте функцію в контексті, який можна оцінити під час компіляції, не означає, що ви не викличете її в такому контексті, коли будете модифікувати або розширювати свою програму. І якщо ви ще не контекстували функцію, ви можете не подумати про це, коли почнете викликати її у такому контексті, і тоді ви втратите вигоду від підвищення продуктивності. Або ви можете бути змушені контекснути її пізніше, коли вам потрібно буде використати значення, що повертається, у контексті, який вимагає десь константного виразу.
3. Повторення допомагає засвоїти найкращі практики.

У нетривіальних проектах варто реалізовувати функції з думкою про те, що вони можуть бути повторно використані (або розширені) в майбутньому. Кожного разу, коли ви змінюєте існуючу функцію, ви ризикуєте її зламати, а це означає, що її потрібно повторно тестувати, що вимагає часу та енергії. Часто варто витратити додаткову хвилину чи дві, щоб "зробити все правильно з першого разу", щоб потім не довелося переробляти (і тестувати) знову.

Як правило, якщо функцію можна обчислити як частину константного виразу, її слід зробити `constexpr`. Тим не менш, якщо ваша програма тривіальна або просто викинута на смітник, і ви не зробите константний вираз для функції, кінець світу не настане. Принаймні, сподіваємось.
> [!tip]
> Якщо у вас немає особливих причин не робити цього, функцію, яку можна обчислити як частину константного виразу, слід зробити `constexpr` (навіть якщо вона не використовується у такий спосіб).
> 
> Функцію, яку не можна обчислити як частину константного виразу, не слід позначати як `constexpr`.