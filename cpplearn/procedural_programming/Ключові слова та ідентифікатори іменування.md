---
date: 2024-09-02
tags:
  - Процедурне_програмування
  - Основи
---
## Ключові слова
C++ резервує набір з 92 слів (станом на C++23) для власного використання. Ці слова називаються ключовими (або зарезервованими), і кожне з них має особливе значення у мові C++.

Ось список усіх ключових слів C++ (за версією C++23):

|A – C|D – P|R – Z|
|---|---|---|
|[`alignas`](https://en.cppreference.com/w/cpp/keyword/alignas "cpp/keyword/alignas") (C++11)  <br>[`alignof`](https://en.cppreference.com/w/cpp/keyword/alignof "cpp/keyword/alignof") (C++11)  <br>[`and`](https://en.cppreference.com/w/cpp/keyword/and "cpp/keyword/and")  <br>[`and_eq`](https://en.cppreference.com/w/cpp/keyword/and_eq "cpp/keyword/and eq")  <br>[`asm`](https://en.cppreference.com/w/cpp/keyword/asm "cpp/keyword/asm")  <br>[`atomic_cancel`](https://en.cppreference.com/w/cpp/keyword/atomic_cancel "cpp/keyword/atomic cancel") (TM TS)  <br>[`atomic_commit`](https://en.cppreference.com/w/cpp/keyword/atomic_commit "cpp/keyword/atomic commit") (TM TS)  <br>[`atomic_noexcept`](https://en.cppreference.com/w/cpp/keyword/atomic_noexcept "cpp/keyword/atomic noexcept") (TM TS)  <br>[`auto`](https://en.cppreference.com/w/cpp/keyword/auto "cpp/keyword/auto") (1) (3) (4) (5)  <br>[`bitand`](https://en.cppreference.com/w/cpp/keyword/bitand "cpp/keyword/bitand")  <br>[`bitor`](https://en.cppreference.com/w/cpp/keyword/bitor "cpp/keyword/bitor")  <br>[`bool`](https://en.cppreference.com/w/cpp/keyword/bool "cpp/keyword/bool")  <br>[`break`](https://en.cppreference.com/w/cpp/keyword/break "cpp/keyword/break")  <br>[`case`](https://en.cppreference.com/w/cpp/keyword/case "cpp/keyword/case")  <br>[`catch`](https://en.cppreference.com/w/cpp/keyword/catch "cpp/keyword/catch")  <br>[`char`](https://en.cppreference.com/w/cpp/keyword/char "cpp/keyword/char")  <br>[`char8_t`](https://en.cppreference.com/w/cpp/keyword/char8_t "cpp/keyword/char8 t") (C++20)  <br>[`char16_t`](https://en.cppreference.com/w/cpp/keyword/char16_t "cpp/keyword/char16 t") (C++11)  <br>[`char32_t`](https://en.cppreference.com/w/cpp/keyword/char32_t "cpp/keyword/char32 t") (C++11)  <br>[`class`](https://en.cppreference.com/w/cpp/keyword/class "cpp/keyword/class") (1)  <br>[`compl`](https://en.cppreference.com/w/cpp/keyword/compl "cpp/keyword/compl")  <br>[`concept`](https://en.cppreference.com/w/cpp/keyword/concept "cpp/keyword/concept") (C++20)  <br>[`const`](https://en.cppreference.com/w/cpp/keyword/const "cpp/keyword/const")  <br>[`consteval`](https://en.cppreference.com/w/cpp/keyword/consteval "cpp/keyword/consteval") (C++20) (5)  <br>[`constexpr`](https://en.cppreference.com/w/cpp/keyword/constexpr "cpp/keyword/constexpr") (C++11) (3)  <br>[`constinit`](https://en.cppreference.com/w/cpp/keyword/constinit "cpp/keyword/constinit") (C++20)  <br>[`const_cast`](https://en.cppreference.com/w/cpp/keyword/const_cast "cpp/keyword/const cast")  <br>[`continue`](https://en.cppreference.com/w/cpp/keyword/continue "cpp/keyword/continue")  <br>[`co_await`](https://en.cppreference.com/w/cpp/keyword/co_await "cpp/keyword/co await") (C++20)  <br>[`co_return`](https://en.cppreference.com/w/cpp/keyword/co_return "cpp/keyword/co return") (C++20)  <br>[`co_yield`](https://en.cppreference.com/w/cpp/keyword/co_yield "cpp/keyword/co yield") (C++20)|[`decltype`](https://en.cppreference.com/w/cpp/keyword/decltype "cpp/keyword/decltype") (C++11) (2)  <br>[`default`](https://en.cppreference.com/w/cpp/keyword/default "cpp/keyword/default") (1)  <br>[`delete`](https://en.cppreference.com/w/cpp/keyword/delete "cpp/keyword/delete") (1)  <br>[`do`](https://en.cppreference.com/w/cpp/keyword/do "cpp/keyword/do")  <br>[`double`](https://en.cppreference.com/w/cpp/keyword/double "cpp/keyword/double")  <br>[`dynamic_cast`](https://en.cppreference.com/w/cpp/keyword/dynamic_cast "cpp/keyword/dynamic cast")  <br>[`else`](https://en.cppreference.com/w/cpp/keyword/else "cpp/keyword/else")  <br>[`enum`](https://en.cppreference.com/w/cpp/keyword/enum "cpp/keyword/enum") (1)  <br>[`explicit`](https://en.cppreference.com/w/cpp/keyword/explicit "cpp/keyword/explicit")  <br>[`export`](https://en.cppreference.com/w/cpp/keyword/export "cpp/keyword/export") (1) (4)  <br>[`extern`](https://en.cppreference.com/w/cpp/keyword/extern "cpp/keyword/extern") (1)  <br>[`false`](https://en.cppreference.com/w/cpp/keyword/false "cpp/keyword/false")  <br>[`float`](https://en.cppreference.com/w/cpp/keyword/float "cpp/keyword/float")  <br>[`for`](https://en.cppreference.com/w/cpp/keyword/for "cpp/keyword/for") (1)  <br>[`friend`](https://en.cppreference.com/w/cpp/keyword/friend "cpp/keyword/friend")  <br>[`goto`](https://en.cppreference.com/w/cpp/keyword/goto "cpp/keyword/goto")  <br>[`if`](https://en.cppreference.com/w/cpp/keyword/if "cpp/keyword/if") (3) (5)  <br>[`inline`](https://en.cppreference.com/w/cpp/keyword/inline "cpp/keyword/inline") (1) (3)  <br>[`int`](https://en.cppreference.com/w/cpp/keyword/int "cpp/keyword/int") (1)  <br>[`long`](https://en.cppreference.com/w/cpp/keyword/long "cpp/keyword/long")  <br>[`mutable`](https://en.cppreference.com/w/cpp/keyword/mutable "cpp/keyword/mutable") (1)  <br>[`namespace`](https://en.cppreference.com/w/cpp/keyword/namespace "cpp/keyword/namespace")  <br>[`new`](https://en.cppreference.com/w/cpp/keyword/new "cpp/keyword/new")  <br>[`noexcept`](https://en.cppreference.com/w/cpp/keyword/noexcept "cpp/keyword/noexcept") (C++11)  <br>[`not`](https://en.cppreference.com/w/cpp/keyword/not "cpp/keyword/not")  <br>[`not_eq`](https://en.cppreference.com/w/cpp/keyword/not_eq "cpp/keyword/not eq")  <br>[`nullptr`](https://en.cppreference.com/w/cpp/keyword/nullptr "cpp/keyword/nullptr") (C++11)  <br>[`operator`](https://en.cppreference.com/w/cpp/keyword/operator "cpp/keyword/operator") (1)  <br>[`or`](https://en.cppreference.com/w/cpp/keyword/or "cpp/keyword/or")  <br>[`or_eq`](https://en.cppreference.com/w/cpp/keyword/or_eq "cpp/keyword/or eq")  <br>[`private`](https://en.cppreference.com/w/cpp/keyword/private "cpp/keyword/private") (4)  <br>[`protected`](https://en.cppreference.com/w/cpp/keyword/protected "cpp/keyword/protected")  <br>[`public`](https://en.cppreference.com/w/cpp/keyword/public "cpp/keyword/public")|[`reflexpr`](https://en.cppreference.com/w/cpp/keyword/reflexpr "cpp/keyword/reflexpr") (reflection TS)  <br>[`register`](https://en.cppreference.com/w/cpp/keyword/register "cpp/keyword/register") (3)  <br>[`reinterpret_cast`](https://en.cppreference.com/w/cpp/keyword/reinterpret_cast "cpp/keyword/reinterpret cast")  <br>[`requires`](https://en.cppreference.com/w/cpp/keyword/requires "cpp/keyword/requires") (C++20)  <br>[`return`](https://en.cppreference.com/w/cpp/keyword/return "cpp/keyword/return")  <br>[`short`](https://en.cppreference.com/w/cpp/keyword/short "cpp/keyword/short")  <br>[`signed`](https://en.cppreference.com/w/cpp/keyword/signed "cpp/keyword/signed")  <br>[`sizeof`](https://en.cppreference.com/w/cpp/keyword/sizeof "cpp/keyword/sizeof") (1)  <br>[`static`](https://en.cppreference.com/w/cpp/keyword/static "cpp/keyword/static")  <br>[`static_assert`](https://en.cppreference.com/w/cpp/keyword/static_assert "cpp/keyword/static assert") (C++11)  <br>[`static_cast`](https://en.cppreference.com/w/cpp/keyword/static_cast "cpp/keyword/static cast")  <br>[`struct`](https://en.cppreference.com/w/cpp/keyword/struct "cpp/keyword/struct") (1)  <br>[`switch`](https://en.cppreference.com/w/cpp/keyword/switch "cpp/keyword/switch")  <br>[`synchronized`](https://en.cppreference.com/w/cpp/keyword/synchronized "cpp/keyword/synchronized") (TM TS)  <br>[`template`](https://en.cppreference.com/w/cpp/keyword/template "cpp/keyword/template")  <br>[`this`](https://en.cppreference.com/w/cpp/keyword/this "cpp/keyword/this") (5)  <br>[`thread_local`](https://en.cppreference.com/w/cpp/keyword/thread_local "cpp/keyword/thread local") (C++11)  <br>[`throw`](https://en.cppreference.com/w/cpp/keyword/throw "cpp/keyword/throw") (3) (4)  <br>[`true`](https://en.cppreference.com/w/cpp/keyword/true "cpp/keyword/true")  <br>[`try`](https://en.cppreference.com/w/cpp/keyword/try "cpp/keyword/try")  <br>[`typedef`](https://en.cppreference.com/w/cpp/keyword/typedef "cpp/keyword/typedef")  <br>[`typeid`](https://en.cppreference.com/w/cpp/keyword/typeid "cpp/keyword/typeid")  <br>[`typename`](https://en.cppreference.com/w/cpp/keyword/typename "cpp/keyword/typename") (3) (4)  <br>[`union`](https://en.cppreference.com/w/cpp/keyword/union "cpp/keyword/union")  <br>[`unsigned`](https://en.cppreference.com/w/cpp/keyword/unsigned "cpp/keyword/unsigned")  <br>[`using`](https://en.cppreference.com/w/cpp/keyword/using "cpp/keyword/using") (1) (4)  <br>[`virtual`](https://en.cppreference.com/w/cpp/keyword/virtual "cpp/keyword/virtual")  <br>[`void`](https://en.cppreference.com/w/cpp/keyword/void "cpp/keyword/void")  <br>[`volatile`](https://en.cppreference.com/w/cpp/keyword/volatile "cpp/keyword/volatile")  <br>[`wchar_t`](https://en.cppreference.com/w/cpp/keyword/wchar_t "cpp/keyword/wchar t")  <br>[`while`](https://en.cppreference.com/w/cpp/keyword/while "cpp/keyword/while")  <br>[`xor`](https://en.cppreference.com/w/cpp/keyword/xor "cpp/keyword/xor")  <br>[`xor_eq`](https://en.cppreference.com/w/cpp/keyword/xor_eq "cpp/keyword/xor eq")

Скопюйовано з сайту [cppreference.com](https://en.cppreference.com/)

Ключові слова, позначені (C++20), було додано у C++20. Якщо ваш компілятор не сумісний з C++20 (або має функціональність C++20, але вона вимкнена за замовчуванням), ці ключові слова можуть не працювати.

У C++ також визначено спеціальні ідентифікатори: override, final, import та module. Вони мають специфічне значення при використанні у певних контекстах, але не зарезервовані в інших випадках.

Ви вже зустрічалися з деякими з цих ключових слів, зокрема int і return. Разом з набором операторів ці ключові слова та спеціальні ідентифікатори визначають усю мову C++ (за винятком команд препроцесора). Оскільки ключові слова та спеціальні ідентифікатори мають особливе значення, ваші IDE, ймовірно, змінять колір тексту цих слів, щоб виділити їх серед інших ідентифікаторів.

Коли ви закінчите цю серію уроків, ви зрозумієте, що роблять майже всі ці слова!
## Правила іменування ідентифікаторів
Нагадуємо, що ім'я змінної (або функції, типу чи іншого елемента) називається ідентифікатором. C++ надає вам велику гнучкість у називанні ідентифікаторів на власний розсуд. Однак, існує декілька правил, яких слід дотримуватись при іменуванні ідентифікаторів:
- Ідентифікатор не може бути ключовим словом. Ключові слова зарезервовані.
- Ідентифікатор може складатися лише з літер (малих чи великих), цифр та символу підкреслення. Це означає, що ім'я не може містити символів (крім символу підкреслення) або пробілів (пробілів або табуляції).
- Ідентифікатор повинен починатися з літери (маленької або великої) або символу підкреслення. Він не може починатися з цифри.
- C++ є чутливою до регістру, і тому розрізняє малі та великі літери. `nvalue` відрізняється від `nValue` відрізняється від `NVALUE`.
## Найкращі практики іменування ідентифікаторів
Тепер, коли ви знаєте, як можна назвати змінну, давайте поговоримо про те, як слід називати змінну (або функцію).

По-перше, у C++ прийнято, що імена змінних повинні починатися з малої літери. Якщо ім'я змінної складається з одного слова або абревіатури, його слід писати малими літерами.
```cpp
int value; // conventional

int Value; // unconventional (should start with lower case letter)
int VALUE; // unconventional (should start with lower case letter and be in all lower case)
int VaLuE; // unconventional (see your psychiatrist) ;)
```

Найчастіше назви функцій також починаються з малої літери (хоча існують певні розбіжності щодо цього питання). Ми будемо дотримуватися цієї домовленості, оскільки функція main (яка повинна бути у всіх програмах) починається з малої літери, як і всі функції у стандартній бібліотеці C++.

Імена ідентифікаторів, що починаються з великої літери, зазвичай використовуються для типів, визначених користувачем (таких як структури, класи та зчислення, про які ми поговоримо пізніше).

Якщо ім'я змінної або функції складається з кількох слів, існує дві загальноприйняті домовленості: слова розділяються підкресленням (іноді називається snake_case), або переноситься (іноді називається camelCase, оскільки великі літери стирчать вгору, як горби на верблюді).
```cpp
int my_variable_name;   // conventional (separated by underscores/snake_case)
int my_function_name(); // conventional (separated by underscores/snake_case)

int myVariableName;     // conventional (intercapped/camelCase)
int myFunctionName();   // conventional (intercapped/camelCase)

int my variable name;   // invalid (whitespace not allowed)
int my function name(); // invalid (whitespace not allowed)

int MyVariableName;     // unconventional (should start with lower case letter)
int MyFunctionName();   // unconventional (should start with lower case letter)
```

У цьому підручнику ми зазвичай будемо використовувати інтеркапсульований підхід, оскільки його легше читати (у щільних блоках коду легко сплутати підкреслення з пробілом). Але часто можна зустріти і те, і інше - стандартна бібліотека C++ використовує метод підкреслення як для змінних, так і для функцій. Іноді ви можете побачити їх поєднання: підкреслення для змінних і пробіли для функцій.

Варто зазначити, що якщо ви працюєте в чужому коді, зазвичай вважається, що краще відповідати стилю коду, в якому ви працюєте, ніж жорстко дотримуватися викладених вище угод щодо іменування.

> [!success] 
> Працюючи в існуючій програмі, використовуйте умовні позначення цієї програми (навіть якщо вони не відповідають сучасним найкращим практикам). Використовуйте сучасні найкращі практики, коли пишете нові програми.

По-друге, вам слід уникати назв ваших ідентифікаторів, що починаються з символу підкреслення, оскільки ці назви зазвичай зарезервовані для використання ОС, бібліотеками та/або компіляторами.

По-третє, ваші ідентифікатори повинні чітко пояснювати, що означає значення, яке вони зберігають (особливо, якщо одиниці виміру не є очевидними). Ідентифікатори повинні бути названі так, щоб допомогти людині, яка не має уявлення про те, що робить ваш код, якнайшвидше розібратися в ньому. Через 3 місяці, коли ви знову подивитеся на свою програму, ви забудете, як вона працює, і подякуєте собі за те, що вибрали імена змінних, які мають сенс.

Однак, надання тривіальній змінній надто складної назви заважає загальному розумінню того, що робить програма, майже так само, як і надання широко використовуваному ідентифікатору неадекватної назви. Тому гарне емпіричне правило полягає в тому, щоб довжина ідентифікатора була пропорційною до того, наскільки широко він використовується. Ідентифікатор з тривіальним використанням може мати коротке ім'я (наприклад, i). Ідентифікатор, який використовується ширше (наприклад, функція, яка викликається з багатьох різних місць програми), повинен мати довшу і більш описову назву (наприклад, замість open, спробуйте openFileOnDisk).

|int ccount|Bad|What does the c before “count” stand for?|
|---|---|---|
|int customerCount|Good|Clear what we’re counting|
|int i|Either|Okay if use is trivial, bad otherwise|
|int index|Either|Okay if obvious what we’re indexing|
|int totalScore|Either|Okay if there’s only one thing being scored, otherwise too ambiguous|
|int _count|Bad|Do not start names with underscore|
|int count|Either|Okay if obvious what we’re counting|
|int data|Bad|What kind of data?|
|int time|Bad|Is this in seconds, minutes, or hours?|
|int minutesElapsed|Good|Descriptive|
|int value1, value2|Either|Can be hard to differentiate between the two|
|int numApples|Good|Descriptive|
|int monstersKilled|Good|Descriptive|
|int x, y|Either|Okay if use is trivial, bad otherwise|
У будь-якому випадку, уникайте скорочень (якщо тільки вони не є загальновживаними/однозначними). Хоча вони скорочують час, необхідний для написання коду, вони роблять ваш код важчим для читання. Код читають частіше, ніж пишуть, і час, який ви зекономили на написанні коду - це час, який кожен читач, в тому числі і ви в майбутньому, витрачає на його читання. Якщо ви хочете писати код швидше, скористайтеся функцією автозавершення у вашому редакторі.

Для оголошення змінних корисно використовувати коментар, щоб описати, для чого буде використовуватися змінна, або пояснити щось інше, що може бути неочевидним. Наприклад, скажімо, ми оголосили змінну з іменем `numberOfChars`, яка має зберігати кількість символів у фрагменті тексту. Чи містить текст "Hello World!" 10, 11 або 12 символів? Це залежить від того, чи включаємо ми пробіли або розділові знаки. Замість того, щоб називати змінну `numberOfCharsIncludingWhitespaceAndPunctuation`, що є доволі довгою назвою, користувачеві краще скористатися вдалим коментарем у рядку оголошення або над ним, який допоможе розібратися у цьому:

```cpp
// a count of the number of chars in a piece of text, including whitespace and punctuation
int numberOfChars;
```