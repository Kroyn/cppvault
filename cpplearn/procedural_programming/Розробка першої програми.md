---
date: 2024-09-02
tags:
  - Процедурне_програмування
  - Основи
---
У попередніх уроках ми познайомилися з багатьма термінами та поняттями, які ми будемо використовувати майже у кожній програмі, яку створюватимемо. У цьому уроці ми розглянемо процес інтеграції цих знань у нашу першу просту програму.
## Помножте на 2
Спочатку напишемо програму, яка просить користувача ввести ціле число, чекає, поки він його введе, а потім повідомляє, скільки разів це число буде помножено на 2. Програма повинна виводити наступний результат (припустимо, я ввів 4):

```
Enter an integer: 4
Double that number is: 8
```

Як з цим боротися? Крок за кроком.

> [!success] 
> Програмісти-початківці часто намагаються написати всю програму за один раз, а потім розгублюються, коли вона видає багато помилок. Краща стратегія - додавати по одному фрагменту за раз, переконатися, що він компілюється, і протестувати його. Потім, коли ви впевнені, що все працює, переходьте до наступної частини.

Ми будемо використовувати цю стратегію тут. Проходячи кожен крок, введіть (не копіюйте і не вставляйте) кожну програму у ваш редактор коду, скомпілюйте і запустіть її.

Спочатку створіть новий консольний проект.

Тепер давайте почнемо з базового риштування. Ми знаємо, що нам знадобиться функція main() (оскільки всі програми на C++ повинні її мати), тому, якщо ваша IDE не створила порожню функцію при створенні нового проекту, давайте створимо її:

```cpp
int main()
{
	return 0;
}
```

Тепер скажемо користувачеві, що потрібно ввести ціле число:

```cpp
#include <iostream>

int main()
{
	std::cout << "Enter an integer: ";

	return 0;
}
```

На цьому етапі ваша програма повинна видати цей результат:

```
Enter an integer:
```

а потім припинити.

Далі ми збираємося отримати дані від користувача. Для цього ми скористаємося `std::cin` та `operator>>`. Але нам також потрібно визначити змінну, яка буде зберігати ці дані для подальшого використання.

```cpp
#include <iostream>

int main() // note: this program has an error somewhere
{
	std::cout << "Enter an integer: ";

	int num{ }; // define variable num as an integer variable
	std::cin << num; // get integer value from user's keyboard

	return 0;
}
```

Час підбити підсумки наших змін... і...

Ух ох! Ось що вийшло у автора на Visual Studio 2017:

```
1>------ Build started: Project: Double, Configuration: Release Win32 ------
1>Double.cpp
1>c:\\vcprojects\\double\\double.cpp(8): error C2678: binary '<<': no operator found which takes a left-hand operand of type 'std::istream' (or there is no acceptable conversion)
1>c:\\vcprojects\\double\\double.cpp: note: could be 'built-in C++ operator<<(bool, int)'
1>c:\\vcprojects\\double\\double.cpp: note: while trying to match the argument list '(std::istream, int)'
1>Done building project "Double.vcxproj" -- FAILED.
========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========
```

Ми зіткнулися з помилкою компіляції!

По-перше, оскільки програма компілювалася до того, як ми зробили це останнє оновлення, і не компілюється зараз, помилка повинна бути в коді, який ми щойно додали (рядки 7 і 8). Це значно зменшує кількість коду, який ми повинні просканувати, щоб знайти помилку. Рядок 7 досить простий (просто визначення змінної), тому помилки, ймовірно, там немає. Залишається рядок 8 як ймовірний винуватець.

По-друге, це повідомлення про помилку не дуже легко прочитати. Але давайте виділимо деякі ключові елементи: Компілятор повідомляє нам, що він зіткнувся з помилкою у рядку 8. Це означає, що фактична помилка, ймовірно, знаходиться у рядку 8, або, можливо, у попередньому рядку, що підтверджує нашу попередню оцінку. Далі компілятор повідомляє, що він не зміг знайти оператор '<<', який має лівий операнд типу std::istream (який є типом std::cin). Іншими словами, operator<< не знає, що робити з std::cin, тому помилка може бути або у використанні std::cin, або у використанні operator<<.

Тепер бачите помилку? Якщо ні, знайдіть хвилинку і спробуйте знайти її.

Ось програма, яка містить виправлений код:

```cpp
#include <iostream>

int main()
{
	std::cout << "Enter an integer: ";

	int num{ };
	std::cin >> num; // std::cin uses operator >>, not operator <<!

	return 0;
}
```

Тепер програма скомпілюється, і ми можемо її протестувати. Програма буде чекати, поки ви введете число, тому давайте введемо 4. На виході повинно вийти ось таке число:

```
Enter an integer: 4
```

Майже готово! Останній крок - подвоїти число.

Як тільки ми виконаємо цей останній крок, наша програма буде скомпільована і успішно запущена, видаючи бажаний результат.

Існує (принаймні) 3 способи зробити це. Підемо від гіршого до кращого.
## Погане рішення
```cpp
#include <iostream>

// worst version
int main()
{
	std::cout << "Enter an integer: ";

	int num{ };
	std::cin >> num;

	num = num * 2; // double num's value, then assign that value back to num

	std::cout << "Double that number is: " << num << '\\n';

	return 0;
}
```

У цьому розв'язку ми використовуємо вираз для множення num на 2, а потім повертаємо це значення до num. З цього моменту num буде містити подвоєне число.

Чому це поганий розв'язок:

- До оператора присвоювання num містить вхідні дані користувача. Після присвоювання воно містить інше значення. Це збиває з пантелику.
- Ми перезаписали вхідні дані користувача, присвоївши вхідній змінній нове значення, тому якщо ми захочемо розширити нашу програму, щоб зробити щось інше з цим вхідним значенням пізніше (наприклад, потроїти вхідні дані користувача), воно вже буде втрачено.
## Здебільшого хороше рішення
```cpp
#include <iostream>

// less-bad version
int main()
{
	std::cout << "Enter an integer: ";

	int num{ };
	std::cin >> num;

	int doublenum{ num * 2 }; // define a new variable and initialize it with num * 2
	std::cout << "Double that number is: " << doublenum << '\\n'; // then print the value of that variable here

	return 0;
}
```

Це рішення є досить простим для читання і розуміння, і вирішує обидві проблеми, що зустрічаються в найгіршому рішенні.

Основним недоліком тут є те, що ми визначаємо нову змінну (що додає складності) для зберігання значення, яке ми використовуємо лише один раз. Ми можемо зробити краще.
## Найкраще рішення
```cpp
#include <iostream>

// preferred version
int main()
{
	std::cout << "Enter an integer: ";

	int num{ };
	std::cin >> num;

	std::cout << "Double that number is: " <<  num * 2 << '\\n'; // use an expression to multiply num * 2 at the point where we are going to print it

	return 0;
}
```

Це найкраще рішення з усіх можливих. При виконанні std::cout буде обчислено вираз num * 2, і результатом буде подвійне значення num. Це значення буде виведено на екран. Значення в самому num не буде змінено, тому ми зможемо використовувати його пізніше, якщо захочемо.

Ця версія є нашим еталонним рішенням.


> [!info] 
> Перша і головна мета програмування - зробити так, щоб ваша програма працювала. Програма, яка не працює, не є корисною, незалежно від того, наскільки добре вона написана.
> 
> Однак, є приказка, яку я люблю: "Ви повинні написати програму один раз, щоб зрозуміти, як ви повинні були написати її з першого разу". Це говорить про те, що найкраще рішення часто не є очевидним, і що наші перші рішення проблем зазвичай не такі хороші, як могли б бути.
> 
> Коли ми зосереджені на тому, щоб з'ясувати, як змусити наші програми працювати, немає сенсу витрачати багато часу на код, який ми навіть не знаємо, чи збережемо. Тому ми обираємо короткі шляхи. Ми пропускаємо такі речі, як обробка помилок та коментарі. Ми розкидаємо налагоджувальний код по всьому нашому рішенню, щоб допомогти нам діагностувати проблеми і знаходити помилки. Ми вчимося на ходу - речі, які, як ми думали, можуть спрацювати, зрештою не працюють, і нам доводиться відступати і пробувати інший підхід.
> 
> В результаті наші початкові рішення часто не є добре структурованими, надійними (захищеними від помилок), читабельними або стислими. Тож, коли ваша програма працює, ваша робота насправді не завершена (якщо тільки програма не є одноразовою/викидною). Наступний крок - це очищення коду. Це включає в себе такі речі, як: видалення (або коментування) тимчасового/налагоджувального коду, додавання коментарів, обробка помилок, форматування коду та забезпечення дотримання найкращих практик. І навіть після цього ваша програма може бути не такою простою, як могла б бути - можливо, є надлишкова логіка, яку можна об'єднати, або кілька операторів, які можна об'єднати, або змінні, які не потрібні, або тисяча інших дрібниць, які можна спростити. Занадто часто програмісти-початківці зосереджуються на оптимізації для продуктивності, тоді як вони повинні оптимізувати для зручності супроводу.
> 
> Дуже мало рішень, представлених у цих підручниках, працюють з першого разу. Скоріше, вони є результатом постійного вдосконалення, доки не було знайдено більше нічого, що можна було б покращити. І в багатьох випадках читачі все ще знаходять багато інших речей, які можна запропонувати для покращення!
> 
> Усе це я хочу сказати: не розчаровуйтеся, якщо/коли ваші рішення не виходять чудово оптимізованими прямо з вашого мозку. Це нормально. Досконалість у програмуванні - це ітеративний процес (такий, що вимагає повторних проходів).

> [!info] 
> І ще одне: ви можете подумати: "У C++ так багато правил і концепцій. Як я все це запам'ятаю?".
> 
> Коротка відповідь: Ніяк. C++ - це одна частина, яка використовує те, що ви знаєте, і дві частини, які шукають, як зробити все інше.
> 
> Коли ви вперше читаєте цей сайт, зосередьтеся менше на запам'ятовуванні деталей, а більше на розумінні того, що можливо. Потім, коли у вас виникне потреба реалізувати щось у програмі, яку ви пишете, ви зможете повернутися сюди (або на довідковий сайт) і освіжити в пам'яті, як це зробити.
