---
date: 2024-09-06
tags:
  - Процедурне_програмування
  - Основи
---
Уявімо, що ви вперше їдете в гості до друга, і вам дали адресу 245 Фронт-стріт у Мілл-Сіті. Доїхавши до Мілл-Сіті, ви дістаєте мапу і виявляєте, що в Мілл-Сіті насправді є дві різні Фронт-стріт, які знаходяться в різних кінцях міста одна від одної! На яку з них ви підете? Якщо у вас немає додаткової підказки, яка б допомогла вам прийняти рішення (наприклад, ви пам'ятаєте, що будинок вашого друга знаходиться біля річки), вам доведеться зателефонувати другу і запитати більше інформації. Оскільки це було б заплутано і неефективно (особливо для вашого поштового оператора), у більшості країн всі назви вулиць і адреси будинків у місті повинні бути унікальними.

Аналогічно, C++ вимагає, щоб усі ідентифікатори були недвозначними. Якщо два однакові ідентифікатори вводяться в одну програму так, що компілятор або компонувальник не може їх відрізнити, компілятор або компонувальник видасть помилку. Ця помилка зазвичай називається **зіткненням імен** (або **конфліктом імен**).

Якщо ідентифікатори, що зіштовхуються, вводяться в один і той самий файл, результатом буде помилка компілятора. Якщо ідентифікатори, що зіштовхуються, вводяться в окремі файли, що належать до однієї програми, результатом буде помилка компонувальника.
## Приклад колізії іменування
a.cpp:

```cpp
#include <iostream>

void myFcn(int x)
{
    std::cout << x;
}
```

main.cpp:

```cpp
#include <iostream>

void myFcn(int x)
{
    std::cout << 2 * x;
}

int main()
{
    return 0;
}
```

Коли компілятор скомпілює цю програму, він скомпілює a.cpp і main.cpp незалежно, і кожен файл буде скомпільовано без проблем.

Однак, коли виконується компонувальник, він зв'яже всі визначення в a.cpp і main.cpp разом, і виявить конфліктуючі визначення для функції `myFcn()`. Після цього компонувальник завершить роботу з помилкою. Зверніть увагу, що ця помилка виникає, навіть якщо `myFcn()` ніколи не викликається!

Більшість колізій імен відбувається у двох випадках:
1. Дві (або більше) однаково названі функції (або глобальні змінні) введено в окремі файли, що належать до однієї програми. Це призведе до помилки компонування, як показано вище.
2. Дві (або більше) функції (або глобальні змінні) з однаковими іменами введено в одному файлі. Це призведе до помилки компілятора.

Коли програми стають більшими і використовують більше ідентифікаторів, ймовірність виникнення колізії імен значно зростає. Хороша новина полягає в тому, що C++ надає багато механізмів для уникнення колізій імен. Одним з таких механізмів є локальна область видимості, яка не дозволяє локальним змінним, визначеним всередині функцій, конфліктувати між собою. Але локальна область видимості не працює для імен функцій. Тож як нам уникнути конфлікту імен функцій між собою?
## Регіони охоплення
Повернімося на мить до нашої аналогії з адресами: мати дві Фронт-стріт було проблематично лише тому, що ці вулиці існували в межах одного міста. З іншого боку, якби вам потрібно було доставити пошту на дві адреси, одну на Фронт-стріт, 245 у Мілл-Сіті, а іншу на Фронт-стріт, 245 у Джонсвіллі, то не було б плутанини, куди їхати. Інакше кажучи, міста забезпечують групування, яке дозволяє нам розрізняти адреси, які в іншому випадку могли б конфліктувати між собою.

**Область видимості** - це область вихідного коду, де всі оголошені ідентифікатори вважаються відмінними від імен, оголошених в інших областях видимості (подібно до міст у нашій аналогії). Два ідентифікатори з однаковими іменами можуть бути оголошені в різних областях видимості без виникнення конфлікту імен. Однак, в межах даного регіону видимості всі ідентифікатори повинні бути унікальними, інакше виникне конфлікт імен.

Тіло функції є одним з прикладів області видимості. Два ідентифікатори з однаковими іменами можуть бути визначені в окремих функціях без проблем - оскільки кожна функція надає окрему область видимості, колізії не виникає. Однак, якщо ви спробуєте визначити два ідентифікатори з однаковими іменами в одній функції, виникне колізія імен, і компілятор поскаржиться.
## Простори імен
**Простір імен** надає ще один тип області видимості (так звану область видимості простору імен), яка дозволяє вам оголошувати імена всередині нього з метою розмежування. Будь-які імена, оголошені всередині простору імен, не будуть сприйняті як ідентичні імена в інших областях видимості.

> [!NOTE]
> Ім'я, оголошене в області видимості (наприклад, у просторі імен), не буде помилково сприйнято як ідентичне ім'я, оголошене в іншій області видимості.

На відміну від функцій (які призначені для того, щоб містити виконувані оператори), в області видимості простору імен можуть з'являтися лише оголошення та визначення. Наприклад, дві функції з однаковими іменами можуть бути визначені у різних просторах імен, і ніякої колізії імен не виникне.

> [!NOTE]
> У межах простору імен можуть з'являтися лише оголошення та визначення (не виконувані оператори). Однак всередині простору імен можна визначити функцію, яка може містити виконувані оператори.

Простори імен часто використовують для групування пов'язаних ідентифікаторів у великому проекті, щоб запобігти їхньому випадковому зіткненню з іншими ідентифікаторами. Наприклад, якщо ви розмістите всі ваші математичні функції у просторі імен `math`, то ваші математичні функції не зіткнуться з однойменними функціями за межами простору імен `math`.

Про те, як створювати власні простори імен, ми поговоримо у наступному уроці.
## Глобальний простір імен
У C++ будь-яке ім'я, яке не визначене всередині класу, функції або простору імен, вважається частиною неявно визначеного простору імен, який називається **глобальним простором** імен (іноді його також називають **глобальною областю видимості**).

У прикладі на початку уроку функції `main()` та обидві версії `myFcn()` визначені у глобальному просторі імен. Колізія імен у прикладі виникає через те, що обидві версії `myFcn()` опиняються всередині глобального простору імен, що порушує правило, згідно з яким усі імена в області видимості мають бути унікальними.

Наразі вам слід знати дві речі:
- Ідентифікатори, оголошені у глобальній області видимості, є видимими від моменту оголошення до кінця файлу.
- Хоча змінні можуть бути визначені у глобальному просторі імен, зазвичай цього слід уникати (ми обговоримо чому у уроці 7.8 - Чому (не-const) глобальні змінні є злом).
### Наприклад:
```cpp
#include <iostream> // imports the declaration of std::cout into the global scope

// All of the following statements are part of the global namespace

void foo();    // okay: function forward declaration
int x;         // compiles but strongly discouraged: non-const global variable definition (without initializer)
int y { 5 };   // compiles but strongly discouraged: non-const global variable definition (with initializer)
x = 5;         // compile error: executable statements are not allowed in namespaces

int main()     // okay: function definition
{
    return 0;
}

void goo();    // okay: A function forward declaration
```
## Простір імен std
Коли C++ було розроблено, всі ідентифікатори стандартної бібліотеки C++ (включаючи `std::cin` та `std::cout`) можна було використовувати без префікса `std::` (вони були частиною глобального простору імен). Однак це означало, що будь-який ідентифікатор у стандартній бібліотеці міг потенційно конфліктувати з будь-яким іменем, яке ви вибрали для власних ідентифікаторів (також визначених у глобальному просторі імен). Код, який колись працював, може раптово зіткнутися з конфліктом імен, коли ви включите іншу частину стандартної бібліотеки. Або ще гірше, код, який компілюється під однією версією C++, може не компілюватися під наступною версією C++, оскільки нові ідентифікатори, введені до стандартної бібліотеки, можуть мати конфлікт імен з уже написаним кодом. Тому C++ перемістила всю функціональність стандартної бібліотеки у простір імен std (скорочення від "стандартний").

Виявляється, що назва `std::cout` насправді не є `std::cout`. Насправді це просто `cout`, а `std` - це назва простору імен, частиною якого є ідентифікатор `cout`. Оскільки `cout` визначено у просторі назв `std`, ім'я `cout` не конфліктуватиме з будь-якими об'єктами або функціями з іменем `cout`, які ми створюємо поза простором назв `std` (наприклад, у глобальному просторі назв).

При зверненні до ідентифікатора, визначеного у просторі імен (наприклад, `std::cout`), потрібно вказати компілятору, що ми шукаємо ідентифікатор, визначений всередині простору імен (`std`).
> [!NOTE] 
> Коли ви використовуєте ідентифікатор, визначений у просторі імен (наприклад, у просторі імен std), ви повинні вказати компілятору, що ідентифікатор знаходиться у цьому просторі імен.

Є кілька різних способів зробити це.

## Явний кваліфікатор простору імен std::

Найпростіший спосіб вказати компілятору, що ми хочемо використовувати `cout` з простору імен `std`, це явно використати префікс `std::`. Наприклад:

```cpp
#include <iostream>

int main()
{
    std::cout << "Hello world!"; // when we say cout, we mean the cout defined in the std namespace
    return 0;
}
```

Символ `::` - це оператор, який називається оператором визначення області видимості. Ідентифікатор ліворуч від символу `::` визначає простір імен, у якому міститься ім'я праворуч від символу `::`. Якщо ідентифікатор ліворуч від символу `::` не вказано, вважається, що використовується глобальний простір імен.

Отже, коли ми говоримо `std::cout`, ми маємо на увазі "`cout`, який оголошено у просторі імен `std`".

Це найбезпечніший спосіб використання `cout`, оскільки немає ніякої двозначності щодо того, на який саме `cout` ми посилаємося (той, що у просторі імен `std`).

> [!tip]
> Використовуйте явні префікси простору імен для доступу до ідентифікаторів, визначених у просторі імен.

Коли ідентифікатор містить префікс простору імен, ідентифікатор називається **кваліфікованим іменем**.
## `using namespace std;` (і чому його слід уникати)
Іншим способом доступу до ідентифікаторів всередині простору імен є використання директиви використання. Ось наша оригінальна програма "Hello world" з директивою using:

```cpp
#include <iostream>

using namespace std; // this is a using-directive that allows us to access names in the std namespace with no namespace prefix

int main()
{
    cout << "Hello world!";
    return 0;
}
```

Директива using дозволяє отримати доступ до імен у просторі імен без використання префікса простору імен. Отже, у наведеному вище прикладі, коли компілятор намагається визначити ідентифікатор `cout`, він знайде `std::cout`, який, завдяки директиві `using`, доступний як просто `cout`.

Багато текстів, підручників і навіть деякі IDE рекомендують або використовують директиву `using` у верхній частині програми. Однак, використання її у такий спосіб є поганою практикою і вкрай не рекомендується.

Розглянемо наступну програму:

```cpp
#include <iostream> // imports the declaration of std::cout into the global scope

using namespace std; // makes std::cout accessible as "cout"

int cout() // defines our own "cout" function in the global namespace
{
    return 5;
}

int main()
{
    cout << "Hello, world!"; // Compile error!  Which cout do we want here?  The one in the std namespace or the one we defined above?

    return 0;
}
```

Вищенаведена програма не компілюється, тому що компілятор тепер не може визначити, чи потрібна нам функція `cout`, яку ми визначили, чи `std::cout`.

При такому використанні директиви using будь-який визначений нами ідентифікатор може конфліктувати з будь-яким ідентично названим ідентифікатором у просторі імен `std`. Навіть гірше, хоча ім'я ідентифікатора може не конфліктувати сьогодні, воно може конфліктувати з новими ідентифікаторами, доданими до простору імен std у майбутніх ревізіях мови. У цьому і полягав основний сенс перенесення усіх ідентифікаторів стандартної бібліотеки до простору назв `std`!

> [!caution]
> Уникайте use-директив (наприклад, using namespace std;) у верхній частині програми або у заголовних файлах. Вони порушують причину, через яку простори назв було додано в першу чергу.
## Фігурні дужки та відступи в коді
У C++ фігурні дужки часто використовуються для відокремлення області видимості, яка вкладена в іншу область видимості (дужки також використовуються для деяких цілей, не пов'язаних з областю видимості, наприклад, для ініціалізації списків). Наприклад, функція, визначена всередині глобальної області видимості, використовує фігурні дужки, щоб відокремити область видимості функції від глобальної області видимості.

У деяких випадках ідентифікатори, визначені поза фігурними дужками, все одно можуть бути частиною області видимості, визначеної фігурними дужками, а не навколишньої області видимості - параметри функції є гарним прикладом цього.

Наприклад:

```cpp
#include <iostream> // imports the declaration of std::cout into the global scope

void foo(int x) // foo is defined in the global scope, x is defined within scope of foo()
{ // braces used to delineate nested scope region for function foo()
    std::cout << x << '\n';
} // x goes out of scope here

int main()
{ // braces used to delineate nested scope region for function main()
    foo(5);

    int x { 6 }; // x is defined within the scope of main()
    std::cout << x << '\n';

    return 0;
} // x goes out of scope here
// foo and main (and std::cout) go out of scope here (the end of the file)
```

Код, який існує всередині вкладеної області видимості, умовно відступається на один рівень, як для зручності читання, так і для того, щоб вказати, що він існує всередині окремої області видимості.

Інструкції `#include` та визначення функцій `foo()` і `main()` знаходяться у глобальній області видимості, тому вони не мають відступів. Оператори всередині кожної функції знаходяться у вкладеній області видимості функції, тому вони мають відступи на один рівень.