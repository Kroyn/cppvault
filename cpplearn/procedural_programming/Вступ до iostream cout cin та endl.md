---
date: 2024-09-01
tags:
  - Процедурне_програмування
  - Основи
---
## Бібліотека вводу/виводу
**Бібліотека вводу/виводу** (io-бібліотека) є частиною стандартної бібліотеки C++, яка займається базовим вводом та виводом. Ми будемо використовувати функціонал цієї бібліотеки для отримання даних з клавіатури та виведення даних на консоль. Частина io в iostream означає ввід/вивід.

Щоб використовувати функціональність, визначену в бібліотеці iostream, нам потрібно включити заголовок iostream у верхній частині будь-якого файлу коду, який використовує вміст, визначений в iostream, як це зроблено нижче:

```cpp
#include <iostream>

// решта коду, що використовує функціонал iostream тут
```
## `std::cout`
Бібліотека iostream містить декілька попередньо визначених змінних для використання. Однією з найбільш корисних є `std::cout`, яка дозволяє нам надсилати дані на консоль для виведення у вигляді тексту. `cout` означає "виведення символів".

Нагадуємо, що ось наша програма Hello world:

```cpp
#include <iostream> // для std::cout

int main()
{
    std::cout << "Hello world!"; // вивести Hello world! в консоль

    return 0;
}
```

У цій програмі ми включили iostream, щоб мати доступ до std::cout. Усередині нашої головної функції ми використовуємо std::cout разом з оператором вставки (<<) для надсилання тексту Hello world! на консоль для друку.

std::cout може виводити не тільки текст, але й числа:

```cpp
#include <iostream> // для std::cout

int main()
{
    std::cout << 4; // вивести 4 в консоль

    return 0;
}
```

Це дає результат:

```
4
```

Його також можна використовувати для виведення значень змінних:

```cpp
#include <iostream> // для std::cout

int main()
{
    int x{ 5 }; // оголосити цілочисельну змінну x, ініціалізовану значенням 5
    std::cout << x; // вивести значення x (5) в консоль
    return 0;
}
```

Це дає результат:

```
5
```

Щоб вивести кілька даних в одному рядку, оператор вставки (`<<`) можна використовувати декілька разів в одному операторі, щоб об'єднати (зв'язати разом) кілька результатів виведення. Наприклад:

```cpp
#include <iostream> // для std::cout

int main()
{
    std::cout << "Hello" << " world!";
    return 0;
}
```

Ця програма друкує:

```
Hello world!
```

Ось ще один приклад, де ми виводимо і текст, і значення змінної в одному операторі:

```cpp
#include <iostream> // для std::cout

int main()
{
    int x{ 5 };
    std::cout << "x is equal to: " << x;
    return 0;
}
```

Ця програма друкує:

```
x is equal to: 5
```
## Використання `std::endl` для виведення нового рядка
Що, на вашу думку, повинна надрукувати ця програма?

```cpp
#include <iostream> // для std::cout

int main()
{
    std::cout << "Hi!";
    std::cout << "My name is Alex.";
    return 0;
}
```

Результат може вас здивувати:

```
Hi!My name is Alex.
```

Окремі оператори виводу не призводять до появи окремих рядків виводу на консолі.

Якщо ми хочемо вивести на консоль окремі рядки, нам потрібно сказати консолі, щоб вона перевела курсор на наступний рядок. Це можна зробити за допомогою виведення нового рядка. **Новий рядок** - це специфічний для ОС символ або послідовність символів, які переміщують курсор на початок наступного рядка.

Одним із способів виведення нового рядка є виведення `std::endl` (що означає "кінець рядка"):

```cpp
#include <iostream> // для std::cout і std::endl

int main()
{
    std::cout << "Hi!" << std::endl; // std::endl призведе до переміщення курсору на наступний рядок
    std::cout << "My name is Alex." << std::endl;

    return 0;
}
```

Ця програма друкує:

```
Hi!
My name is Alex.
```


> [!NOTE] 
> У наведеній вище програмі другий `std::endl` не є технічно необхідним, оскільки програма завершується одразу після нього. Однак, він слугує декільком корисним цілям.
> 
> По-перше, він допомагає вказати, що рядок виводу є "завершеною думкою" (на відміну від часткового виводу, який завершується десь пізніше у коді). У цьому сенсі він функціонує подібно до використання крапки у стандартній англійській мові.
> 
> По-друге, він позиціонує курсор на наступний рядок, так що якщо ми пізніше додамо додаткові рядки виводу (наприклад, попросимо програму сказати "бувай!"), ці рядки з'являться там, де ми очікуємо (а не додадуться до попереднього рядка виводу).
> 
> По-третє, після запуску виконуваного файлу з командного рядка деякі операційні системи не виводять новий рядок перед тим, як знову показати командний рядок. Якщо наша програма не закінчується з курсором на новому рядку, командний рядок може з'явитися у додатку до попереднього рядка, а не на початку нового рядка, як очікував користувач.

> [!success] 
> Виводити новий рядок щоразу, коли рядок виводу завершено.
## `std::cout` буферизується
Уявіть собі поїздку на американських гірках у вашому улюбленому парку розваг. Пасажири з'являються (з деякою змінною швидкістю) і стають у чергу. Періодично приїжджає потяг і забирає пасажирів (до максимальної місткості потягу). Коли потяг заповнений, або коли минуло достатньо часу, потяг від'їжджає з черговою партією пасажирів, і атракціон починає роботу. Пасажири, які не встигли сісти на поточний поїзд, чекають на наступний.

Ця аналогія схожа на те, як зазвичай обробляється вивід, надісланий до `std::cout`, у C++. Оператори у нашій програмі вимагають, щоб виведення було надіслано на консоль. Однак, як правило, цей вивід не надсилається на консоль негайно. Замість цього запитуваний вивід "стає в чергу" і зберігається в області пам'яті, відведеній для збору таких запитів (так званий **буфер**). Періодично буфер очищується, тобто всі дані, зібрані в буфері, передаються до місця призначення (в даному випадку на консоль).

Це також означає, що якщо ваша програма аварійно завершиться, перерветься або буде призупинена (наприклад, з метою налагодження) до того, як буфер буде очищено, будь-який вивід, що все ще очікує в буфері, не буде виведено на екран.

> [!NOTE] 
> Протилежністю буферизованого виводу є небуферизований вивід. При небуферизованому виводі кожен окремий запит на вивід надсилається безпосередньо на пристрій виводу.
> 
> Запис даних до буфера зазвичай відбувається швидко, тоді як передача пакета даних на пристрій виводу відбувається порівняно повільно. Буферизація може значно підвищити продуктивність, об'єднуючи декілька запитів на вивід разом, щоб мінімізувати кількість разів, коли дані потрібно надсилати на пристрій виводу.
## `std::endl` проти `\\n`
Використання `std::endl` часто є неефективним, оскільки вона фактично виконує дві роботи: виводить новий рядок (переміщуючи курсор на наступний рядок консолі) і очищає буфер (що є повільним процесом). Якщо ми виведемо декілька рядків тексту, що закінчуються командою `std::endl`, ми отримаємо декілька очисток, що є повільним і, ймовірно, непотрібним.

При виведенні тексту на консоль, як правило, нам не потрібно явно очищати буфер самостійно. Система виводу у C++ призначена для періодичного самоочищення, і простіше та ефективніше дозволити їй робити це самостійно.

Щоб вивести новий рядок без очищення буфера виводу, ми використовуємо `\\n` (всередині одинарних або подвійних лапок), який є спеціальним символом, що інтерпретується компілятором як символ нового рядка. Команда `\\n` переміщує курсор на наступний рядок консолі без очищення буфера виводу, тому вона зазвичай працює краще. Символ `\\n` також є більш стислим для введення і може бути вбудований у текст, взятий у подвійні лапки.

Ось приклад, у якому використовується `\\n` кількома різними способами:

```cpp
#include <iostream> // for std::cout

int main()
{
    int x{ 5 };
    std::cout << "x is equal to: " << x << '\\n'; // single quoted (by itself) (conventional)
    std::cout << "Yep." << "\\n";                 // double quoted (by itself) (unconventional but okay)
    std::cout << "And that's all, folks!\\n";     // between double quotes in existing text (conventional)
    return 0;
}
```

Ця програма друкує:

```
x is equal to: 5
Yep.
And that's all, folks!
```

Якщо `\\n` не вставляється у наявний рядок тексту у подвійних лапках (наприклад, `"hello\\n"`), він умовно береться в одинарні лапки (`'\\n'`).

> [!NOTE] 
> У C++ ми використовуємо одинарні лапки для позначення окремих символів (наприклад, 'a' або '$') і подвійні лапки для позначення тексту (нуль або більше символів). 
> 
> Хоча у вихідному коді '\n' представлено у вигляді двох символів, компілятор сприймає його як один символ переведення рядка (LF) (зі значенням ASCII 10), а отже, він умовно береться в одинарні лапки (якщо тільки його не вбудовано у вже існуючий текст у подвійних лапках).

> [!success] 
> Надавайте перевагу \n перед std::endl при виведенні тексту на консоль.

> [!attention] 
> `'\n'` використовує зворотну косу риску (як і всі спеціальні символи у C++), а не пряму.
> 
> Використання прямої похилої риски (наприклад, `'/n'`) або включення інших символів всередині одинарних лапок (наприклад, `' \n`' або `'.\n'`) призведе до неочікуваної поведінки. Наприклад, `std::cout << '/n';` часто виводитиме `12142`, що, ймовірно, не те, чого ви очікували.
## `std::cin`
`std::cin` - це ще одна попередньо визначена змінна у бібліотеці `iostream`. У той час як `std::cout` виводить дані на консоль (використовуючи оператор вставки `<<` для передачі даних), `std::cin` (що означає "символьний ввід") зчитує дані з клавіатури. Зазвичай ми використовуємо оператор вилучення `>>`, щоб помістити вхідні дані у змінну (яку потім можна використовувати у наступних операторах).

```cpp
#include <iostream>  // for std::cout and std::cin

int main()
{
    std::cout << "Enter a number: "; // ask user for a number

    int x{};       // define variable x to hold user input (and value-initialize it)
    std::cin >> x; // get number from keyboard and store it in variable x

    std::cout << "You entered " << x << '\\n';
    return 0;
}
```

Спробуйте скомпілювати цю програму і запустити її на виконання. Коли ви запустите програму, у рядку 5 буде надруковано "Введіть число: ". Коли код дійде до рядка 8, ваша програма чекатиме на введення. Як тільки ви введете число (і натиснете enter), введене вами число буде присвоєно змінній `x`. Нарешті, у рядку 10 програма виведе "Ви ввели ", а потім число, яке ви щойно ввели.

Наприклад (введення значення 4):

```
Enter a number: 4
You entered 4
```

Це простий спосіб отримати клавіатурне введення від користувача, і ми будемо використовувати його в багатьох наших прикладах надалі.

> [!NOTE]
>Зауважте, що вам не потрібно виводити `'\\n'` при прийнятті рядка вводу, оскільки користувачеві потрібно буде натиснути клавішу вводу, щоб його ввід було прийнято, і це переведе курсор на наступний рядок консолі.

Так само, як можна виводити більше одного біта тексту в одному рядку, так само можна вводити більше одного значення в одному рядку:

```cpp
#include <iostream>  // for std::cout and std::cin

int main()
{
    std::cout << "Enter two numbers separated by a space: ";

    int x{}; // define variable x to hold user input (and value-initialize it)
    int y{}; // define variable y to hold user input (and value-initialize it)
    std::cin >> x >> y; // get two numbers and store in variable x and y respectively

    std::cout << "You entered " << x << " and " << y << '\\n';

    return 0;
}
```

Це дає результат:

```
Enter two numbers separated by a space: 5 6
You entered 5 and 6
```

Значення, що вводяться, слід розділяти пробілами (пробілами, табуляцією або новим рядком).


> [!NOTE] 
> Існують суперечки щодо того, чи потрібно ініціалізувати змінну безпосередньо перед тим, як надавати їй значення з іншого джерела (наприклад, std::cin), оскільки надане користувачем значення просто перезапише значення ініціалізації. Згідно з нашою попередньою рекомендацією про те, що змінні завжди слід ініціалізувати, найкраще ініціалізувати змінну першою.

> [!NOTE] 
> Бібліотека вводу/виводу C++ не надає можливості приймати ввід з клавіатури без натискання користувачем клавіші вводу. Якщо вам це потрібно, вам доведеться скористатися бібліотекою сторонніх розробників. Для консольних програм ми рекомендуємо [pdcurses](https://pdcurses.org/), [FXTUI](https://github.com/ArthurSonzogni/FTXUI), [cpp-terminal](https://github.com/jupyter-xeus/cpp-terminal) або [notcurses](https://github.com/dankamongmen/notcurses). Багато бібліотек графічного інтерфейсу користувача мають власні функції для виконання подібних завдань.
## `std::cin` буферизується
У попередньому розділі ми зазначали, що виведення даних - це фактично двоетапний процес:

- Дані з кожного запиту на вивід додаються (в кінець) буфера виводу.
- Пізніше дані з (передньої частини) буфера виводяться на пристрій виводу (консоль).

> [!NOTE] 
> Додавання даних в кінець буфера і видалення їх з початку буфера гарантує, що дані будуть оброблятися в тому ж порядку, в якому вони були додані. Іноді це називається FIFO (перший прийшов, перший пішов).

Аналогічно, введення даних - це також двоетапний процес:

- Окремі символи, які ви вводите, додаються у кінець буфера вводу (всередині `std::cin`). Клавіша введення (натиснута для надсилання даних) також зберігається як символ `'\\n'`.
- Оператор вилучення '>>' видаляє символи з передньої частини вхідного буфера і перетворює їх у значення, яке присвоюється відповідній змінній. Цю змінну можна використовувати в наступних операторах.

> [!NOTE] 
> Кожен рядок вхідних даних у вхідному буфері завершується символом '\n'.

Ми продемонструємо це за допомогою наступної програми:

```cpp
#include <iostream>  // for std::cout and std::cin

int main()
{
    std::cout << "Enter two numbers: ";

    int x{};
    std::cin >> x;

    int y{};
    std::cin >> y;

    std::cout << "You entered " << x << " and " << y << '\\n';

    return 0;
}
```

Ця програма вводить вхідні дані у дві змінні (цього разу у вигляді окремих операторів). Ми запустимо цю програму двічі.

Запуск #1: Коли зустрічається `std::cin >> x;`, програма буде чекати на введення. Введіть значення `4`. Введення `4\\n` потрапляє у вхідний буфер, а значення `4` витягується у змінну x.

Якщо зустрінеться `std::cin >> y;`, програма знову буде чекати на ввід. Введіть значення `5`. Введене `5\\n` потрапляє у вхідний буфер, а значення `5` витягується у змінну y. Нарешті, програма виведе `You entered 4 and 5.`

У цьому прогоні не повинно бути нічого дивного.

Запуск #2: Коли зустрічається `std::cin >> x`, програма буде чекати на введення. Введіть `4 5`. Введення `4 5\\n` потрапляє у вхідний буфер, але у змінну x витягується лише цифра `4` (витяг зупиняється на пробілі).

Коли зустрічається `std::cin >> y`, програма не буде чекати на введення. Замість цього `5`, яке все ще знаходиться у вхідному буфері, буде витягнуто у змінну y. Потім програма виведе `Ви ввели 4 і 5.`

Зауважте, що у варіанті 2 програма не чекала на введення користувачем додаткових даних при витягуванні у змінну `y`, оскільки у вхідному буфері вже було попереднє введення, яке можна було використати.


> [!NOTE] 
> std::cin є буферизованою, оскільки вона дозволяє нам відокремити введення даних від їх вилучення. Ми можемо ввести вхідні дані один раз, а потім виконати декілька запитів на їх вилучення.
## Основний процес екстракції
Ось спрощений вигляд того, як працює оператор `>>` для введення:

1. Спочатку з вхідного буфера буде вилучено початкові пробіли (пробіли, табуляції та переноси рядків на початку буфера). Це призведе до відкидання усіх невилучених символів нового рядка, що залишилися з попереднього рядка введення.
2. Якщо буфер вводу порожній, оператор `>>` чекатиме, доки користувач введе нові дані. Початкові пробіли знову буде відкинуто.
3. Потім оператор `>>` витягує стільки символів підряд, скільки зможе, доки не зустріне символ нового рядка (що означає кінець рядка введення) або символ, який не є допустимим для змінної, до якої витягуються дані.

Результат екстракції виглядає наступним чином:

- Якщо на кроці 3 було вилучено будь-які символи, то вилучення є успішним. Витягнуті символи перетворюються на значення, яке потім присвоюється змінній.
- Якщо на кроці 3 не вдалося витягти жодного символу, це означає, що вилучення не вдалося. Об'єкту, до якого виконується видобування, присвоюється значення `0` (починаючи з C++11), і будь-які подальші видобування одразу ж завершаться невдачею (доки не буде очищено `std::cin`).

Будь-які невитягнуті символи (включно з новими рядками) залишаються доступними для наступної спроби вилучення.

Наприклад, наведений нижче фрагмент:

```cpp
int x{};
std::cin >> x;
```

Якщо користувач введе `5a` і натисне enter, до буфера буде додано `5a\\n`. `5` буде витягнуто, перетворено у ціле число і присвоєно змінній `x`. `a\\n` буде залишено у вхідному буфері для наступного вилучення.

Якщо користувач введе 'b' і натисне enter, до буфера буде додано `b\\n`. Оскільки b не є дійсним цілим числом, жоден символ не може бути вилучено, тому це буде помилкою вилучення. Змінна `x` буде встановлена у `0`, і подальші вилучення не відбудуться, доки потік вводу не буде очищено.

Ми розглянемо інші випадки у вікторині нижче.
## `operator<<` vs `operator>>`
Програмісти-початківці часто плутають `std::cin`, `std::cout`, оператор вставки (`<<`) та оператор вилучення (`>>`). Ось простий спосіб запам'ятати:

- `std::cin` і `std::cout` завжди йдуть у лівій частині оператора.
- `std::cout` використовується для виведення значення (cout = символьний вивід).
- `std::cin` використовується для отримання вхідного значення (cin = символьне введення).
- `<<` використовується з `std::cout` і показує напрямок переміщення даних. `std::cout << 4` переміщує значення `4` на консоль.
- `>>` використовується зі `std::cin` і показує напрямок переміщення даних. `std::cin >> x` переміщує значення, введене користувачем з клавіатури, у змінну `x`.