---
date: 2024-09-24
tags:
  - Процедурне_програмування
  - Фундаментальні_типи_дани
---
Ви знаете як ввести рядкові літерали у стилі C:
```cpp
#include <iostream>

int main()
{
    std::cout << "Hello, world!"; // "Hello world!" is a C-style string literal.
    return 0;
}
```
У той час як рядкові літерали у C-стилі чудово підходять для використання, рядкові змінні у C-стилі поводяться дивно, з ними важко працювати (наприклад, ви не можете використовувати присвоювання для присвоєння рядковій змінній у C-стилі нового значення) і є небезпечними (наприклад, якщо ви скопіюєте більший рядок у C-стилі у місце, відведене для коротшого рядка у C-стилі, то це призведе до невизначеної поведінки). У сучасній C++ краще уникати використання рядкових змінних у стилі C.

На щастя, у C++ введено два додаткових рядкових типи, з якими набагато простіше і безпечніше працювати: `std::string` та `std::string_view` (C++17). На відміну від типів, які ми розглядали раніше, `std::string` і `std::string_view` не є фундаментальними типами (вони є типами класів, про які ми розповімо у майбутньому). Проте, базове використання кожного з них є досить простим і корисним, тому ми представимо їх тут.
## Представляємо `std::string`
Найпростіший спосіб роботи з рядками та рядковими об'єктами у C++ - це тип `std::string`, який знаходиться у заголовку `<string>`.

Ми можемо створювати об'єкти типу `std::string` так само, як і інші об'єкти:
```cpp
#include <string> // allows use of std::string

int main()
{
    std::string name {}; // empty string

    return 0;
}
```
Подібно до звичайних змінних, ви можете ініціалізувати або присвоювати значення об'єктам `std::string`, як ви очікуєте:
```cpp
#include <string>

int main()
{
    std::string name { "Alex" }; // initialize name with string literal "Alex"
    name = "John";               // change name to "John"

    return 0;
}
```
Зверніть увагу, що рядки можуть складатися і з цифрових символів:
```cpp
std::string myID{ "45" }; // "45" is not the same as integer 45!
```
У рядковій формі числа розглядаються як текст, а не як числа, і тому з ними не можна маніпулювати як з числами (наприклад, не можна їх помножити). C++ не виконує автоматичного перетворення рядків у цілі числа або числа з плаваючою комою і навпаки (хоча існують способи зробити це, які ми розглянемо у наступному уроці).
## Виведення рядка з допомогою `std::cout`
Об'єкти `std::string` можуть бути виведені, як і очікувалося, за допомогою `std::cout`:
```cpp
#include <iostream>
#include <string>

int main()
{
    std::string name { "Alex" };
    std::cout << "My name is: " << name << '\n';

    return 0;
}
```
Це виводе:
```
My name is: Alex
```
Порожні рядки нічого не виведуть:
```cpp
#include <iostream>
#include <string>

int main()
{
    std::string empty{ };
    std::cout << '[' << empty << ']';

    return 0;
}
```
Це виводе:
```
[]
```
## `std::string` може обробляти рядки різної довжини
Однією з найакуратніших речей, які може робити `std::string`, є зберігання рядків різної довжини:
```cpp
#include <iostream>
#include <string>

int main()
{
    std::string name { "Alex" }; // initialize name with string literal "Alex"
    std::cout << name << '\n';

    name = "Jason";              // change name to a longer string
    std::cout << name << '\n';

    name = "Jay";                // change name to a shorter string
    std::cout << name << '\n';

    return 0;
}
```
Це виводе:
```
Alex
Jason
Jay
```
У наведеному вище прикладі `name` ініціалізується рядком `"Alex"`, який містить п'ять символів (чотири явних символи і нуль-термінатор). Потім ми встановлюємо `name` у більший рядок, а потім у менший рядок. `std::string` без проблем впорається з цим! Ви навіть можете зберігати дуже довгі рядки у `std::string`.

Це одна з причин, чому `std::string` така потужна.
> [!NOTE]
> Якщо `std::string` не має достатньо пам'яті для зберігання рядка, вона запросить додаткову пам'ять (під час виконання), використовуючи форму розподілу пам'яті, відому як динамічний розподіл пам'яті. Ця здатність отримувати додаткову пам'ять є частиною того, що робить `std::string` такою гнучкою, але і порівняно повільною.
> 
> Ми розглянемо динамічне виділення пам'яті у наступній главі.
## Введення рядка з допомогою std::cin
Використання `std::string` з `std::cin` може принести деякі сюрпризи! Розглянемо наступний приклад:
```cpp
#include <iostream>
#include <string>

int main()
{
    std::cout << "Enter your full name: ";
    std::string name{};
    std::cin >> name; // this won't work as expected since std::cin breaks on whitespace

    std::cout << "Enter your favorite color: ";
    std::string color{};
    std::cin >> color;

    std::cout << "Your name is " << name << " and your favorite color is " << color << '\n';

    return 0;
}
```
Ось результати вибіркового запуску цієї програми:
```
Enter your full name: John Doe
Enter your favorite color: Your name is John and your favorite color is Doe
```
Хм, це не так! Що ж сталося? Виявляється, при використанні `operator>>` для вилучення рядка з `std::cin`, `operator>>` повертає лише символи до першого пробілу, з яким він зіткнувся. Всі інші символи залишаються всередині `std::cin` і чекають наступного вилучення.

Отже, коли ми використали `operator>>` для вилучення вхідних даних у змінну `name`, було вилучено лише `"John"`, залишивши `"Doe"` всередині `std::cin`. Коли ми використали `operator>>` для вилучення даних у змінну `color`, було вилучено `"Doe"` замість того, щоб чекати, поки ми введемо колір. Після цього програма завершується.
## Використовуйте `std::getline()` для введення тексту
Для зчитування повного рядка вводу у рядок краще використовувати функцію `std::getline()`. `std::getline()` вимагає двох аргументів: перший - `std::cin`, а другий - ваша змінна-рядок.

Ось та сама програма, що й наведена вище, але з використанням `std::getline()`:
```cpp
#include <iostream>
#include <string> // For std::string and std::getline

int main()
{
    std::cout << "Enter your full name: ";
    std::string name{};
    std::getline(std::cin >> std::ws, name); // read a full line of text into name

    std::cout << "Enter your favorite color: ";
    std::string color{};
    std::getline(std::cin >> std::ws, color); // read a full line of text into color

    std::cout << "Your name is " << name << " and your favorite color is " << color << '\n';

    return 0;
}
```
Зараз наша програма працює, як і очікувалося:
```
Enter your full name: John Doe
Enter your favorite color: blue
Your name is John Doe and your favorite color is blue
```
## Що таке `std::ws`?
Ми обговорювали маніпулятори виводу, які дозволяють змінювати спосіб виводу. У цьому уроці ми використовували функцію маніпулятора виводу `std::setprecision()` для зміни кількості знаків після коми, які виводить `std::cout`.

C++ також підтримує маніпулятори вводу, які змінюють спосіб, у який приймається ввід. Маніпулятор вводу `std::ws` вказує `std::cin` ігнорувати будь-які початкові пробіли перед витяганням. Початковий пробіл - це будь-який пробіл (пробіл, табуляція, новий рядок), який знаходиться на початку рядка.

Давайте з'ясуємо, чому це корисно. Розглянемо наступну програму:
```cpp
#include <iostream>
#include <string>

int main()
{
    std::cout << "Pick 1 or 2: ";
    int choice{};
    std::cin >> choice;

    std::cout << "Now enter your name: ";
    std::string name{};
    std::getline(std::cin, name); // note: no std::ws here

    std::cout << "Hello, " << name << ", you picked " << choice << '\n';

    return 0;
}
```
Ось деякі результати роботи цієї програми:
```
Pick 1 or 2: 2
Now enter your name: Hello, , you picked 2
```
Ця програма спочатку просить вас ввести 1 або 2 і чекає, поки ви це зробите. Поки що все гаразд. Потім вона попросить вас ввести ваше ім'я. Однак, насправді вона не чекає на введення вашого імені! Замість цього вона надрукує рядок `"Hello"`, а потім вийде.

Коли ви вводите значення за допомогою `operator>>`, `std::cin` перехоплює не лише значення, але й символ переходу на новий рядок (`'\n'`), який з'являється при натисканні клавіші введення. Отже, коли ми вводимо `2` і натискаємо enter, `std::cin` перехоплює рядок `"2\n"` як ввід. Потім він витягує значення `2` до змінної `choice`, залишаючи символ нового рядка на потім. Потім, коли `std::getline()` намагається витягти текст до `name`, він бачить, що `"\n"` вже чекає на нього у `std::cin`, а це означає, що ми, мабуть, раніше ввели порожній рядок! Безумовно, це не те, що ми планували.

Ми можемо змінити вищенаведену програму на використання маніпулятора вводу `std::ws`, щоб вказати `std::getline()` ігнорувати будь-які початкові пробіли:
```cpp
#include <iostream>
#include <string>

int main()
{
    std::cout << "Pick 1 or 2: ";
    int choice{};
    std::cin >> choice;

    std::cout << "Now enter your name: ";
    std::string name{};
    std::getline(std::cin >> std::ws, name); // note: added std::ws here

    std::cout << "Hello, " << name << ", you picked " << choice << '\n';

    return 0;
}
```
Тепер ця програма буде функціонувати за призначенням.
```
Pick 1 or 2: 2
Now enter your name: Alex
Hello, Alex, you picked 2
```
> [!tip]
> Якщо ви використовуєте `std::getline()` для читання рядків, використовуйте маніпулятор вводу `std::cin >> std::ws`, щоб ігнорувати початкові пробіли. Це потрібно робити для кожного виклику `std::getline()`, оскільки `std::ws` не зберігається між викликами.

> [!NOTE]
> Під час видобування до змінної оператор видобування (`>>`) ігнорує початкові пробіли. Він припиняє видобування, якщо зустрічає неперевідні пробіли.
> 
> `std::getline()` не ігнорує початкові пробіли. Якщо ви хочете, щоб вона ігнорувала пробіли, передайте `std::cin >> std::ws` як перший аргумент. Програма припинить видобування, якщо зустріне новий рядок.
## Довжина рядка `std::string`
Якщо ми хочемо дізнатися, скільки символів міститься у `std::string`, ми можемо запитати у об'єкта `std::string` його довжину. Синтаксис цього запиту відрізняється від того, що ви бачили раніше, але є досить простим:
```cpp
#include <iostream>
#include <string>

int main()
{
    std::string name{ "Alex" };
    std::cout << name << " has " << name.length() << " characters\n";

    return 0;
}
```
Це відбиток:
```
Alex has 4 characters
```
Хоча `std::string` має завершуватися нуль-термінатором (починаючи з C++11), довжина рядка `std::string`, що повертається, не містить неявного символу нуль-термінатора.

Зверніть увагу, що замість того, щоб запитувати довжину рядка як `length(name)`, ми говоримо `name.length()`. Функція `length()` не є звичайною окремою функцією - це спеціальний тип функції, яка вкладена у `std::string` і називається **функцією-членом**(або **метод**). Оскільки функцію-член `length()` оголошено всередині `std::string`, у документації її іноді пишуть як `std::string::length()`.

Ми розглянемо функції-члени, у тому числі як написати власну, більш детально пізніше.
> [!NOTE]
> Для звичайних функцій ми викликаємо функцію(об'єкт). З функціями-членами ми викликаємо `object.function()`.

Також зверніть увагу, що `std::string::length()` повертає беззнакове ціле значення (найімовірніше, типу `size_t`). Якщо ви хочете присвоїти довжину змінній типу `int`, вам слід статично привести її до типу `static_cast`, щоб уникнути попереджень компілятора про перетворення типу `sign`/`unsigned`:
```cpp
int length { static_cast<int>(name.length()) };
```

> [!NOTE]
> У C++20 ви також можете використовувати функцію `std::ssize()` для отримання довжини `std::string` як великого цілого типу зі знаком (зазвичай `std::ptrdiff_t`):

```cpp
#include <iostream>
#include <string>

int main()
{
    std::string name{ "Alex" };
    std::cout << name << " has " << std::ssize(name) << " characters\n";

    return 0;
}
```
> Оскільки `ptrdiff_t` може бути більшим за `int`, якщо ви хочете зберегти результат `std::ssize()` у змінній типу `int`, вам слід статично привести результат до типу `int`:
```cpp
int len { static_cast<int>(std::ssize(name)) };
```
## Ініціалізація `std::string` коштує дорого
Кожного разу, коли ініціалізується рядок `std::string`, створюється копія рядка, який використовувався для його ініціалізації. Створення копій рядків коштує дорого, тому слід подбати про те, щоб мінімізувати кількість створюваних копій.
## Не передавайте `std::string` за значенням
Коли `std::string` передається у функцію за значенням, параметр функції `std::string` повинен бути екземпляром та ініціалізований аргументом. Це призводить до дорогої копії. Ми обговоримо, що можна зробити замість цього (використати `std::string_view`).
> [!tip]
> Не передавайте `std::string` за значенням, оскільки це призводить до дорогої копії.
> 
> У більшості випадків замість цього використовуйте параметр std::string_view
## Повернення рядка `std::string`
Коли функція повертає значення за викликом, значення, що повертається, зазвичай копіюється з функції назад викликувачу. Отже, ви можете очікувати, що вам не слід повертати `std::string` за значенням, оскільки це призведе до повернення дорогої копії `std::string`.

Однак, як правило, можна повертати `std::string` за значенням, якщо вираз оператора `return` перетворюється на одне з наступних значень:
- Локальна змінна типу `std::string`.
- Рядок `std::string`, який було повернуто за значенням з іншого виклику функції або оператора.
- Тимчасовий параметр `std::string`, який створюється як частина оператора `return`.
> [!NOTE]
> `std::string` підтримує можливість, яка називається семантикою переміщення, що дозволяє об'єкту, який буде знищено в кінці функції, повертатися за значенням без створення копії. Те, як працює семантика переміщення, виходить за рамки цієї вступної статті, але ми розглянемо це у наступному уроці.

У більшості інших випадків краще уникати повернення `std::string` за значенням, оскільки це призведе до створення дорогої копії.
> [!tip]
> Якщо повертається рядковий літерал у стилі C, використовуйте тип повернення `std::string_view`.

> [!NOTE]
> У певних випадках `std::string` може також повертатися за посиланням (`const`), що є ще одним способом уникнути створення копії.

## Літерали для `std::string`
Рядкові літерали у подвійних лапках (наприклад, `"Hello, world!"`) за замовчуванням є рядками у стилі C (а отже, мають дивний тип).

Ми можемо створювати рядкові літерали з типом `std::string`, використовуючи суфікс `s` після рядкового літерала у подвійних лапках. Суфікс `s` має бути у нижньому регістрі.

> [!tip]
> Суфікс "`s`" знаходиться у просторі імен `std::literals::string_literals`.
> 
> Найкоротший спосіб отримати доступ до суфіксів літералів - за допомогою директиви using-directive з `using namespace std::literals`. Однак, це імпортує всі стандартні бібліотечні літерали до області видимості директиви `using`, що призводить до появи купи речей, які ви, ймовірно, не збираєтеся використовувати.
> 
> Ми рекомендуємо використовувати простір імен `std::string_literals`, який імпортує лише літерали для `std::string`.
> 
> Це один з тих випадків, коли використання цілого простору імен, як правило, є нормальним, оскільки суфікси, визначені у ньому, навряд чи зіткнуться з вашим кодом. Уникайте таких директив використання поза функціями у заголовних файлах.

Ймовірно, вам не доведеться використовувати `std::string` літерали дуже часто (оскільки можна ініціалізувати об'єкт `std::string` рядковим літералом у стилі C), але у наступних уроках ми розглянемо декілька випадків (пов'язаних з виведенням типів), коли використання `std::string` літералів замість рядкових літералів у стилі C спрощує роботу.
> [!NOTE]
> `"Hello"` перетворюється на `std::string { "Hello", 5 }`, що створює тимчасовий `std::string`, ініціалізований рядковим літералом `"Hello"` у стилі C (який має довжину `5`, не враховуючи неявного нуль-термінатора).
## Рядки `constexpr`
Якщо ви спробуєте визначити `constexpr std::string`, ваш компілятор, ймовірно, видасть помилку:
```cpp
#include <iostream>
#include <string>

int main()
{
    using namespace std::string_literals;

    constexpr std::string name{ "Alex"s }; // compile error

    std::cout << "My name is: " << name;

    return 0;
}
```
Це відбувається тому, що контексний вираз `std::string` взагалі не підтримується у C++17 або більш ранніх версіях, і працює лише у дуже обмежених випадках у C++20/23. Якщо вам потрібні рядки `constexpr`, використовуйте `std::string_view`.
## Висновок
`std::string` є складною, оскільки використовує багато мовних можливостей, які ми ще не розглянули. На щастя, вам не потрібно розуміти ці складнощі, щоб використовувати `std::string` для простих завдань, таких як базове введення та виведення рядків. Ми заохочуємо вас почати експериментувати з рядками вже зараз, а додаткові можливості рядків ми розглянемо пізніше.