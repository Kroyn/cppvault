---
date: 2024-09-03
tags:
  - Процедурне_програмування
  - Основи
---
Коли ви компілюєте свій проект, ви можете очікувати, що компілятор скомпілює кожен файл коду саме так, як ви його написали. Насправді це не так.

Натомість, перед компіляцією кожен файл коду (.cpp) проходить фазу попередньої обробки. На цьому етапі програма, яка називається препроцесором, вносить різні зміни в текст файлу коду. Насправді **препроцесор** жодним чином не змінює вихідні файли коду - всі зміни, зроблені **препроцесором**, відбуваються або тимчасово в пам'яті, або з використанням тимчасових файлів.
> [!NOTE]
> Історично препроцесор був окремою програмою від компілятора, але в сучасних компіляторах препроцесор може бути вбудований безпосередньо в сам компілятор.

Більшість з того, що робить препроцесор, досить нецікаво. Наприклад, він видаляє коментарі і гарантує, що кожен файл коду закінчується з нового рядка. Однак препроцесор виконує одну дуже важливу роль: він обробляє директиви `#include` (про які ми поговоримо пізніше).

Коли препроцесор закінчує обробку файлу коду, результат називається **одиницею трансляції**. Саме цей блок трансляції потім компілюється компілятором.

> [!NOTE]
> Весь процес попередньої обробки, компіляції та зв'язування називається перекладом.
> Якщо вам цікаво, ось список [етапів перекладу](https://en.cppreference.com/w/cpp/language/translation_phases). На момент написання цієї статті препроцесорна обробка охоплює етапи з 1 по 4, а компіляція - етапи з 5 по 7.
## Директиви препроцесора
Коли препроцесор запускається, він сканує файл коду (зверху вниз) у пошуках директив препроцесора. Директиви препроцесора (часто їх називають просто директивами) - це інструкції, які починаються з символу # і закінчуються новим рядком (НЕ крапкою з комою). Ці директиви вказують препроцесору виконати певні завдання з маніпулювання текстом. Зауважте, що препроцесор не розуміє синтаксис C++ - натомість директиви мають власний синтаксис (який у деяких випадках нагадує синтаксис C++, а в інших - не дуже).

> [!NOTE]
> Кінцевий вивід препроцесора не містить жодних директив - компілятору передається лише вивід обробленої директиви.
## `#Include`

Ви вже бачили директиву `#include` в дії (зазвичай для `#include <iostream>`). Коли ви `#include` файл, препроцесор замінює директиву `#include` вмістом включеного файлу. Потім включений вміст препроцесується (що може призвести до рекурсивної обробки додаткових директив `#include`), після чого препроцесується решта файлу.

Розглянемо наступну програму:

```cpp
#include <iostream>

int main()
{
    std::cout << "Hello, world!\\n";
    return 0;
}
```

Коли препроцесор виконує цю програму, він замінить `#include <iostream>` на вміст файлу з назвою "iostream", а потім обробить включений вміст і решту файлу.

Після того, як препроцесор закінчить обробку файлу коду і всього вмісту `#included`, результат називається одиницею трансляції. **Блок трансляції** - це те, що надсилається компілятору для компіляції.
> [!NOTE]
> Блок перекладу містить як оброблений код з файлу коду, так і оброблений код з усіх файлів `#included`.

Оскільки `#include` майже виключно використовується для включення заголовних файлів, ми обговоримо `#include` більш детально в наступному уроці (коли будемо обговорювати заголовні файли).
## Макрос визначає
Для створення макросу можна використовувати директиву `#define`. У C++ макрос - це правило, яке визначає, як вхідний текст перетворюється у вихідний текст, що замінює його.

Існує два основних типи макросів: об'єктні макроси та макроси-функції.

Функціональні макроси діють подібно до функцій і мають схожу мету. Їх використання зазвичай вважається небезпечним, і майже все, що вони можуть робити, може бути виконано звичайною функцією.

Об'єктні макроси можна визначити одним із двох способів:

```cpp
#define IDENTIFIER
#define IDENTIFIER substitution_text
```

У верхньому визначенні немає тексту заміни, тоді як у нижньому він є. Оскільки це директиви препроцесора (а не оператори), зверніть увагу, що жодна з форм не закінчується крапкою з комою.

Ідентифікатор макросу використовує ті самі правила іменування, що й звичайні ідентифікатори: він може містити літери, цифри та символи підкреслення, не може починатися з цифри і не повинен починатися з символу підкреслення. Зазвичай, імена макросів пишуться великими літерами, розділеними символами підкреслення.
## Об'єктні макроси з текстом підстановки
Коли препроцесор зустрічає цю директиву, створюється асоціація між ідентифікатором макросу та текстом_підстановки. Усі подальші входження ідентифікатора макросу (за межами використання у інших командах препроцесора) замінюються на текст_підстановки.

Розглянемо наступну програму:

```cpp
#include <iostream>

#define MY_NAME "Alex"

int main()
{
    std::cout << "My name is: " << MY_NAME << '\\n';

    return 0;
}
```

Препроцесор перетворює наведені вище дані в наступні:

```cpp
// The contents of iostream are inserted here

int main()
{
    std::cout << "My name is: " << "Alex" << '\\n';

    return 0;
}
```

Який при виконанні виводить на екран `My name is: Алекс`.

Об'єктні макроси з текстом підстановки використовувалися (у C) як спосіб присвоєння імен літералам. У цьому більше немає необхідності, оскільки у C++ доступні кращі методи. Об'єктні макроси з текстом підстановки зараз здебільшого зустрічаються у застарілому коді, і ми рекомендуємо уникати їх, коли це можливо.

> [!success] 
> Уникайте макросів із текстом підстановки, якщо не існує життєздатних альтернатив.
## Об'єктні макроси без тексту підстановки
Об'єктні макроси також можуть бути визначені без тексту підстановки.

Наприклад:

```cpp
#define USE_YEN
```

Макроси цієї форми працюють так, як і слід було очікувати: більшість подальших входжень ідентифікатора видаляється і замінюється нічим!

Це може здатися досить марним, і це марно для виконання заміни тексту. Однак це не те, для чого зазвичай використовується ця форма директиви. Ми обговоримо використання цієї форми за мить.

На відміну від об'єктних макросів із текстом підстановки, макроси цієї форми зазвичай вважаються прийнятними для використання.
## Умовна компіляція
Директиви препроцесора умовної компіляції дозволяють вказати, за яких умов щось буде або не буде скомпільовано. Існує досить багато різних директив умовної компіляції, але ми розглянемо лише деякі з них, які використовуються найчастіше: `#ifdef`, `#ifndef` та `#endif`.

Директива препроцесора `#ifdef` дозволяє препроцесору перевірити, чи був ідентифікатор раніше визначений за допомогою `#define`. Якщо так, то код між `#ifdef` і відповідним `#endif` компілюється. Якщо ні, то код ігнорується.

Розглянемо наступну програму:

```cpp
#include <iostream>

#define PRINT_JOE

int main()
{
#ifdef PRINT_JOE
    std::cout << "Joe\\n"; // will be compiled since PRINT_JOE is defined
#endif

#ifdef PRINT_BOB
    std::cout << "Bob\\n"; // will be excluded since PRINT_BOB is not defined
#endif

    return 0;
}
```
Оскільки PRINT_JOE було `#define`, рядок `std::cout << "Joe\n"` буде скомпільовано. Оскільки PRINT_BOB не було `#define`, рядок `std::cout << "Bob\n" `буде проігноровано.

Команда `#ifndef` є протилежною до `#ifdef` у тому сенсі, що вона дозволяє перевірити, чи ідентифікатор ще не було `#define`.

```cpp
#include <iostream>

int main()
{
#ifndef PRINT_BOB
    std::cout << "Bob\\n";
#endif

    return 0;
}
```

Ця програма виводить "Bob", тому що PRINT_BOB ніколи не був `#define`.

Замість `#ifdef` PRINT_BOB і `#ifndef` PRINT_BOB ви також побачите `#if` defined(PRINT_BOB) і `#if` !defined(PRINT_BOB). Вони роблять те ж саме, але використовують синтаксис трохи більш схожий на C++.

## `#if 0`

Ще одне поширене використання умовної компіляції - використання `#if 0` для виключення блоку коду з компіляції (так, ніби він знаходиться всередині блоку коментарів):

```cpp
#include <iostream>

int main()
{
    std::cout << "Joe\\n";

#if 0 // Don't compile anything starting here
    std::cout << "Bob\\n";
    std::cout << "Steve\\n";
#endif // until this point

    return 0;
}
```

Вищенаведений код виводить тільки "Joe", оскільки "Bob" і "Steve" виключені з компіляції директивою препроцесора `#if 0`.

Це забезпечує зручний спосіб "закоментувати" код, який містить багаторядкові коментарі (які не можна закоментувати за допомогою іншого багаторядкового коментаря через те, що багаторядкові коментарі не є вкладеними):

```cpp
#include <iostream>

int main()
{
    std::cout << "Joe\\n";

#if 0 // Don't compile anything starting here
    std::cout << "Bob\\n";
    /* Some
     * multi-line
     * comment here
     */
    std::cout << "Steve\\n";
#endif // until this point

    return 0;
}
```

Щоб тимчасово увімкнути код, який було загорнуто у `#if 0`, ви можете змінити `#if 0` на `#if 1`:

```cpp
#include <iostream>

int main()
{
    std::cout << "Joe\\n";

#if 1 // always true, so the following code will be compiled
    std::cout << "Bob\\n";
    /* Some
     * multi-line
     * comment here
     */
    std::cout << "Steve\\n";
#endif

    return 0;
}
```
## Макропідстановка в інших командах препроцесора
Тепер ви можете задатися питанням, враховуючи наступний код:

```cpp
#define PRINT_JOE

int main()
{
#ifdef PRINT_JOE
    std::cout << "Joe\\n"; // will be compiled since PRINT_JOE is defined
#endif

    return 0;
}
```

Оскільки ми визначили PRINT_JOE як ніщо, чому препроцесор не замінив PRINT_JOE в `#ifdef` PRINT_JOE на ніщо і не виключив оператор виводу з компіляції?

У більшості випадків заміна макросу не відбувається, коли ідентифікатор макросу використовується в іншій команді препроцесора.

Ще один приклад:

```cpp
#define FOO 9 // Here's a macro substitution

#ifdef FOO // This FOO does not get replaced with 9 because it’s part of another preprocessor directive
    std::cout << FOO << '\\n'; // This FOO gets replaced with 9 because it's part of the normal code
#endif
```

## Область видимості `#defines`

Директиви розв'язуються перед компіляцією, зверху вниз для кожного файлу окремо.

Розглянемо наступну програму:

```cpp
#include <iostream>

void foo()
{
#define MY_NAME "Alex"
}

int main()
{
	std::cout << "My name is: " << MY_NAME << '\\n';

	return 0;
}
```

Хоча виглядає так, ніби `#define` MY_NAME "Alex" визначено всередині функції foo, препроцесор не розуміє такі концепції C++, як функції. Тому ця програма поводитиметься так само, як і та, де `#define` MY_NAME "Alex" було визначено до або одразу після функції foo. Щоб уникнути плутанини, вам, як правило, слід `#define` ідентифікатори поза функціями.

Тому що директива `#include` замінює директиву `#include` вмістом включеного файлу, а `#include` може копіювати директиви з включеного файлу у поточний файл. Ці директиви будуть оброблятися по порядку.

Наприклад, наступний приклад поводиться так само, як і попередні:

Alex.h:

```cpp
#define MY_NAME "Alex"
```

main.cpp:

```cpp
#include "Alex.h" // copies #define MY_NAME from Alex.h here
#include <iostream>

int main()
{
	std::cout << "My name is: " << MY_NAME << '\\n'; // preprocessor replaces MY_NAME with "Alex"

	return 0;
}
```

Після завершення роботи препроцесора всі визначені ідентифікатори з цього файлу відкидаються. Це означає, що директиви є дійсними лише з моменту визначення до кінця файлу, в якому вони визначені. Директиви, визначені в одному файлі, не мають жодного впливу на інші файли (якщо тільки вони не `#include` в інший файл). Наприклад:

function.cpp:

```cpp
#include <iostream>

void doSomething()
{
#ifdef PRINT
    std::cout << "Printing!\\n";
#endif
#ifndef PRINT
    std::cout << "Not printing!\\n";
#endif
}
```

main.cpp:

```cpp
void doSomething(); // forward declaration for function doSomething()

#define PRINT

int main()
{
    doSomething();

    return 0;
}
```

Вищенаведена програма надрукує:

```
Not printing!
```

Незважаючи на те, що PRINT було визначено в `main.cpp`, це не має жодного впливу на код у `function.cpp` (PRINT є `#define` лише від точки визначення до кінця `main.cpp`). Це матиме значення, коли ми будемо обговорювати захисники заголовків у наступному уроці.