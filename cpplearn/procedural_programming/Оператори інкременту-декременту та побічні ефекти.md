---
date: 2024-10-04
tags:
  - Процедурне_програмування
  - Оператори
---
Інкремент (додавання 1 до змінної) і декремент (віднімання 1 від змінної) є настільки поширеними, що мають власні оператори.

| Operator                           | Symbol | Form | Operation                                      |
| ---------------------------------- | ------ | ---- | ---------------------------------------------- |
| Prefix increment (pre-increment)   | ++     | ++x  | Increment x, then return x                     |
| Prefix decrement (pre-decrement)   | ––     | ––x  | Decrement x, then return x                     |
| Postfix increment (post-increment) | ++     | x++  | Copy x, then increment x, then return the copy |
| Postfix decrement (post-decrement) | ––     | x––  | Copy x, then decrement x, then return the copy |
Зверніть увагу, що існує дві версії кожного оператора - префіксна (де оператор стоїть перед операндом) і постфіксна (де оператор стоїть після операнда).
## Інкремент та декремент префікса
Префіксні оператори інкременту/декременту дуже прості. Спочатку операнд збільшується або зменшується, а потім вираз обчислюється до значення операнда. Наприклад:
```cpp
#include <iostream>

int main()
{
    int x { 5 };
    int y { ++x }; // x is incremented to 6, x is evaluated to the value 6, and 6 is assigned to y

    std::cout << x << ' ' << y << '\n';
    return 0;
}
```
Це виводе:
```
6 6
```
## Постфіксний інкремент та декремент
Постфіксні оператори інкременту/декременту складніші. Спочатку створюється копія операнда. Потім операнд (не копія) збільшується або зменшується. Нарешті, копія (не оригінал) обчислюється. Наприклад:
```cpp
#include <iostream>

int main()
{
    int x { 5 };
    int y { x++ }; // x is incremented to 6, copy of original x is evaluated to the value 5, and 5 is assigned to y

    std::cout << x << ' ' << y << '\n';
    return 0;
}
```
Це виводе:
```
6 5
```
Давайте розглянемо, як працює цей рядок 6 більш детально. Спочатку створюється тимчасова копія x, яка починається з того ж значення, що і x (5). Потім значення x збільшується з 5 до 6. Потім повертається копія x (яка все ще має значення 5) і присвоюється y. Після цього тимчасова копія відкидається.

Таким чином, y отримує значення 5 (попереднє інкрементоване значення), а x отримує значення 6 (наступне інкрементоване значення).

Зверніть увагу, що постфіксна версія виконує набагато більше кроків, і тому може бути не такою продуктивною, як префіксна.
## Більше прикладів
Ось ще один приклад, що демонструє різницю між префіксною та постфіксною версіями:
```cpp
#include <iostream>

int main()
{
    int x { 5 };
    int y { 5 };
    std::cout << x << ' ' << y << '\n';
    std::cout << ++x << ' ' << --y << '\n'; // prefix
    std::cout << x << ' ' << y << '\n';
    std::cout << x++ << ' ' << y-- << '\n'; // postfix
    std::cout << x << ' ' << y << '\n';

    return 0;
}
```
Це дає результат:
```
5 5
6 4
6 4
6 4
7 3
```
У 8-му рядку ми виконуємо префіксний інкремент і декремент. У цьому рядку x та y збільшуються/зменшуються перед тим, як їх значення надсилаються до `std::cout`, тому ми бачимо їх оновлені значення, відображені у `std::cout`.

У 10-му рядку ми виконуємо постфіксний інкремент і декремент. У цьому рядку копії x та y (з попередньо інкрементованими та попередньо декрементованими значеннями) надсилаються до `std::cout`, тому ми не бачимо відображення інкременту та декременту тут. Ці зміни не з'являються до наступного рядка, коли x та y обчислюються знову.
## Коли використовувати префікс vs постфікс
У багатьох випадках префіксні та постфіксні оператори дають однакову поведінку:
```cpp
int main()
{
    int x { 0 };
    ++x; // increments x to 1
    x++; // increments x to 2

    return 0;
}
```
У випадках, коли код може бути написаний з використанням префіксів або постфіксів, віддавайте перевагу префіксним версіям, оскільки вони, як правило, більш продуктивні і з меншою ймовірністю приносять сюрпризи.
> [!tip]
> Надавайте перевагу префіксальним версіям, оскільки вони більш продуктивні і з меншою ймовірністю принесуть сюрпризи.

Використовуйте постфіксні версії, коли це дає значно стисліший і зрозуміліший код, ніж еквівалентний код, написаний з використанням префіксних версій.
## Побічні ефекти
Кажуть, що функція або вираз має побічний ефект, якщо він має деякий видимий ефект, окрім того, що повертає значення.

Поширеними прикладами побічних ефектів є зміна значень об'єктів, введення або виведення даних або оновлення графічного інтерфейсу користувача (наприклад, увімкнення або вимкнення кнопки).

Здебільшого побічні ефекти є корисними:
```cpp
x = 5; // the assignment operator has side effect of changing value of x
++x; // operator++ has side effect of incrementing x
std::cout << x; // operator<< has side effect of modifying the state of the console
```

Оператор присвоювання у наведеному вище прикладі має побічний ефект, який полягає у постійній зміні значення x. Навіть після завершення виконання оператора x все ще матиме значення 5. Подібно до оператора`++`, значення x змінюється навіть після завершення обчислень в операторі. Виведення x також має побічним ефектом зміну стану консолі, оскільки тепер ви можете бачити значення x, виведене на консоль.
## Побічні ефекти можуть спричинити проблеми з порядком оцінки
У деяких випадках побічні ефекти можуть призвести до проблем з оцінкою. Наприклад:
```cpp
#include <iostream>

int add(int x, int y)
{
    return x + y;
}

int main()
{
    int x { 5 };
    int value{ add(x, ++x) }; // undefined behavior: is this 5 + 6, or 6 + 6?
    // It depends on what order your compiler evaluates the function arguments in

    std::cout << value << '\n'; // value could be 11 or 12, depending on how the above line evaluates!

    return 0;
}
```
Стандарт C++ не визначає порядок обчислення аргументів функції. Якщо лівий аргумент обчислюється першим, це призведе до виклику `add(5, 6)`, що дорівнює `11`. Якщо першим обчислюється правий аргумент, це призведе до виклику add(6, 6), що дорівнює 12! Зауважте, що це лише проблема, оскільки один з аргументів функції add() має побічний ефект.
> [!NOTE]
> Стандарт C++ навмисно не визначає ці речі, щоб компілятори могли робити те, що є найприроднішим (і, відповідно, найпродуктивнішим) для даної архітектури.
## Послідовність побічних ефектів
У багатьох випадках C++ також не визначає, коли потрібно застосовувати побічні ефекти операторів. Це може призвести до невизначеної поведінки у випадках, коли об'єкт із застосованим побічним ефектом використовується більше одного разу в одному операторі.

Наприклад, вираз `x + ++x` має невизначену поведінку. Коли `x` ініціалізовано значенням `1`, Visual Studio та GCC оцінюють його як `2 + 2`, а Clang - як `1 + 2`! Це пов'язано з різницею у тому, коли компілятори застосовують побічний ефект інкрементування `x`.

Навіть коли стандарт C++ чітко описує, як слід обчислювати змінні, історично це була область, де виникало багато помилок компілятора. Як правило, цих проблем можна уникнути, якщо переконатися, що будь-яка змінна, до якої застосовується побічний ефект, використовується не більше одного разу в одному операторі.
> [!caution]
> У C++ не визначено порядок обчислення аргументів функцій або операндів операторів.

> [!caution]
> Не використовуйте змінну, яка має побічний ефект, більше одного разу в одному операторі.
> 
> Виняток становлять прості вирази присвоювання, такі як `x = x + y` (що, по суті, еквівалентно `x += y`).