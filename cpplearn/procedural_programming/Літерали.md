---
date: 2024-09-22
tags:
  - Процедурне_програмування
  - Константи_та_рядки
---
**Літерали** - це значення, які вставляються безпосередньо в код. Наприклад:
```cpp
return 5;                     // 5 is an integer literal
bool myNameIsAlex { true };   // true is a boolean literal
double d { 3.4 };             // 3.4 is a double literal
std::cout << "Hello, world!"; // "Hello, world!" is a C-style string literal
```
Літерали іноді називають **буквальними константами**, оскільки їх значення не можна перевизначити (`5` завжди означає інтегральне значення 5).
## Тип літералу
Подібно до того, як об'єкти мають тип, всі літерали мають тип. Тип літералу виводиться зі значення літералу. Наприклад, літерал, що є цілим числом (наприклад, `5`), має тип `int`.
За замовчуванням:

| Literal value        | Examples        | Default literal type | Note                                         |
| -------------------- | --------------- | -------------------- | -------------------------------------------- |
| integer value        | 5, 0, -3        | int                  |                                              |
| boolean value        | true, false     | bool                 |                                              |
| floating point value | 1.2, 0.0, 3.4   | double (not float!)  |                                              |
| character            | ‘a’, ‘\n’       | char                 |                                              |
| C-style string       | “Hello, world!” | const char[14]       | див. розділ Рядкові літерали у стилі C нижче |
## Літературні суфікси
Якщо тип літерала за замовчуванням не відповідає вашим побажанням, ви можете змінити тип літерала, додавши суфікс. Ось деякі з найпоширеніших суфіксів:

|Data type|Suffix|Meaning|
|---|---|---|
|integral|u or U|unsigned int|
|integral|l or L|long|
|integral|ul, uL, Ul, UL, lu, lU, Lu, LU|unsigned long|
|integral|ll or LL|long long|
|integral|ull, uLL, Ull, ULL, llu, llU, LLu, LLU|unsigned long long|
|integral|z or Z|The signed version of std::size_t (C++23)|
|integral|uz, uZ, Uz, UZ, zu, zU, Zu, ZU|std::size_t (C++23)|
|floating point|f or F|float|
|floating point|l or L|long double|
|string|s|std::string|
|string|sv|std::string_view|
Про літерали та суфікси з цілою та плаваючою точкою ми поговоримо пізніше.

У більшості випадків суфікси не потрібні (за винятком `f`).

> [!NOTE]
> Додаткові (рідковживані) суфікси існують для комплексних чисел і хронологічних (часових) літералів. Вони задокументовані тут.

> [!NOTE]
> За винятком суфікса `f`, суфікси найчастіше використовуються у випадках, коли йдеться про віднімання за типом.
## Суфіксальна оболонка
Більшість суфіксів не залежать від регістру. Винятки становлять:
- `s` та `sv` мають бути малими літерами.
- Два символи `l` або `L`, що йдуть підряд, повинні мати однакову оболонку.
Оскільки мала літера `L` у деяких шрифтах може виглядати як цифра `1`, деякі розробники вважають за краще використовувати великі літери. Інші використовують суфікси нижнього регістру, крім `L`.

> [!tip]
> Надавайте перевагу буквеному суфіксу L (верхній регістр) над l (нижній регістр).
## Цілісні літерали
Зазвичай вам не потрібно використовувати суфікси для цілих літералів, але ось кілька прикладів:
```cpp
#include <iostream>

int main()
{
    std::cout << 5 << '\n';  // 5 (no suffix) is type int (by default)
    std::cout << 5L << '\n'; // 5L is type long
    std::cout << 5u << '\n'; // 5u is type unsigned int

    return 0;
}
```
У більшості випадків можна використовувати літерали `int` без суфіксів, навіть при ініціалізації не-`int` типів:
```cpp
int main()
{
    int a { 5 };          // ok: types match
    unsigned int b { 6 }; // ok: compiler will convert int value 6 to unsigned int value 6
    long c { 7 };         // ok: compiler will convert int value 7 to long value 7

    return 0;
}
```
У таких випадках компілятор перетворить літерал `int` до відповідного типу.

У першому випадку `5` вже є `int` за замовчуванням, тому компілятор може використовувати це значення безпосередньо для ініціалізації змінної типу `int a`. У другому випадку значення `int 6` не відповідає типу `unsigned int b`. Компілятор перетворить значення `int 6` у значення `unsigned int 6`, а потім використає його як ініціалізатор для `b`. У третьому випадку значення `int 7` не відповідає типу `long c`. Компілятор перетворить значення `int 7` у значення `long 7`, а потім використає його як ініціалізатор для `c`.
## Літерали з плаваючою комою
За замовчуванням, літерали з плаваючою комою мають тип `double`. Щоб зробити їх літералами з плаваючою комою, слід використовувати суфікс `f` (або `F`):
```cpp
#include <iostream>

int main()
{
    std::cout << 5.0 << '\n';  // 5.0 (no suffix) is type double (by default)
    std::cout << 5.0f << '\n'; // 5.0f is type float

    return 0;
}
```
Програмістів-початківців часто бентежить, чому наступне викликає попередження компілятора:
```cpp
float f { 4.1 }; // warning: 4.1 is a double literal, not a float literal
```
Оскільки `4.1` не має суфікса, літерал має тип `double`, а не `float`. Коли компілятор визначає тип літералу, йому байдуже, що ви робите з ним (наприклад, у цьому випадку ви використовуєте його для ініціалізації змінної типу `float`). Оскільки тип літералу (`double`) не збігається з типом змінної, для ініціалізації якої він використовується (`float`), значення літералу має бути перетворено у змінну з плаваючою комою, щоб його можна було використати для ініціалізації змінної `f`. Перетворення значення з типу `double` у змінну з плаваючою комою може призвести до втрати точності, тому компілятор видасть відповідне попередження.

Вирішити цю проблему можна одним з наступних способів:
```cpp
float f { 4.1f }; // use 'f' suffix so the literal is a float and matches variable type of float
double d { 4.1 }; // change variable to type double so it matches the literal type double
```
## Наукова нотація для літералів з плаваючою комою
Існує два різних способи оголошення літералів з плаваючою комою:
```cpp
double pi { 3.14159 }; // 3.14159 is a double literal in standard notation
double avogadro { 6.02e23 }; // 6.02 x 10^23 is a double literal in scientific notation
```
У другій формі число після експоненти може бути від'ємним:
```cpp
double electronCharge { 1.6e-19 }; // charge on an electron is 1.6 x 10^-19
```
## Рядкові літерали
У програмуванні **рядок** - це набір послідовних символів, які використовуються для представлення тексту (наприклад, імен, слів і речень).

Найперша програма на C++, яку ви написали, напевно, виглядала приблизно так:
```cpp
#include <iostream>

int main()
{
    std::cout << "Hello, world!";
    return 0;
}
```
`"Hello, world!"` - це рядковий літерал. Рядкові літерали беруться у подвійні лапки, щоб ідентифікувати їх як рядки (на відміну від літералів типу `char`, які беруться в одинарні лапки).

Оскільки рядки часто використовуються в програмах, більшість сучасних мов програмування включають в себе фундаментальний тип даних рядки. З історичних причин, рядки не є фундаментальним типом у C++. Скоріше, це дивний, складний тип, з яким важко працювати (ми розглянемо, як і чому, в одному з наступних уроків, після того, як ми розглянемо основи, необхідні для пояснення того, як вони працюють). Такі рядки часто називають **C-рядками** або **рядками у стилі C**, оскільки вони успадковані від мови C.

Є дві неочевидні речі, які варто знати про рядкові літерали у стилі C.
1. Усі рядкові літерали у стилі C мають неявний нульовий термінатор. Розглянемо рядок типу `"hello"`. Хоча здається, що цей рядок у стилі C містить лише п'ять символів, насправді їх шість: `'h'`, `'e'`, `'l'`, `'l'`, `'o'` та `'\0'` (символ з ASCII кодом 0). Символ `'\0'` є спеціальним символом, який називається нульовим термінатором, і використовується для позначення кінця рядка. Рядок, який закінчується нульовим термінатором, називається рядком з нульовим закінченням.

> [!NOTE]
> Саме тому рядок `"Hello, world!`" має тип `const char[14]`, а не `const char[13`] - прихований нульовий термінатор вважається символом.

Причина появи нуль-термінатора також історична: з його допомогою можна визначити, де закінчується рядок.
2. На відміну від більшості інших літералів (які є значеннями, а не об'єктами), рядкові літерали у стилі C є об'єктами `const`, які створюються на початку програми і гарантовано існуватимуть протягом усієї програми. Цей факт стане важливим через декілька уроків, коли ми будемо обговорювати `std::string_view`.

> [!NOTE]
> Рядкові літерали у стилі C - це об'єкти типу const, які створюються на початку програми і гарантовано існують протягом усього часу виконання програми.

На відміну від рядкових літералів у стилі C, літерали `std::string` та `std::string_view` створюють тимчасові об'єкти. Ці тимчасові об'єкти мають бути використані негайно, оскільки вони знищуються в кінці повного виразу, в якому їх було створено.
> [!NOTE]
> Ми ще поговоримо про `std::string` та `std::string_view`.
## Магічні числа
**Магічне число** - це літера (зазвичай цифра), яка або має неясне значення, або може бути змінена пізніше.

Ось два твердження, що демонструють приклади магічних чисел:
```cpp
const int maxStudentsPerSchool{ numClassrooms * 30 };
setMax(30);
```
Що означають літери `30` у цих контекстах? У першому випадку можна здогадатися, що це кількість учнів у класі, але це не одразу зрозуміло. У другому - хтозна. Треба подивитися на функцію, щоб дізнатися, що вона робить.

У складних програмах може бути дуже важко зробити висновок про значення літералу, якщо немає коментаря, який пояснює його.

Використання магічних чисел зазвичай вважається поганою практикою, оскільки, окрім того, що вони не надають контексту щодо того, для чого вони використовуються, вони створюють проблеми, якщо значення потрібно змінити. Припустимо, що школа купує нові парти, які дозволяють збільшити кількість учнів у класі з 30 до 35, і наша програма повинна це відобразити.

Для цього нам потрібно оновити один або кілька літералів з `30` на `35`. Але які літерали? `30` в ініціалізаторі `maxStudentsPerSchool` здається очевидним. Але як щодо `30`, яке використовується як аргумент в `setMax()`? Чи має це `30` те саме значення, що й інші `30`? Якщо так, то його слід оновити. Якщо ні, то його слід залишити у спокої, інакше ми можемо зламати нашу програму десь в іншому місці. Якщо ви робите глобальний пошук і заміну, ви можете випадково оновити аргумент `setMax()`, коли він не повинен був змінюватися. Отже, вам доведеться переглянути весь код для кожного екземпляра літералу `30` (яких може бути сотні), а потім окремо визначити, чи потрібно його змінювати, чи ні. Це може зайняти багато часу (і призвести до помилок).

На щастя, як відсутність контексту, так і проблеми з оновленням можна легко вирішити, використовуючи символічні константи:
```cpp
const int maxStudentsPerClass { 30 };
const int totalStudents{ numClassrooms * maxStudentsPerClass }; // now obvious what this 30 means

const int maxNameLength{ 30 };
setMax(maxNameLength); // now obvious this 30 is used in a different context
```
Ім'я константи забезпечує контекст, і нам потрібно лише оновити значення в одному місці, щоб змінити значення в усій нашій програмі.

Зверніть увагу, що магічні числа не завжди є числами - вони також можуть бути текстом (наприклад, іменами) або іншими типами.

Літерали, що використовуються в очевидних контекстах, які навряд чи будуть змінюватися, зазвичай не вважаються магічними. Значення `-1`, `0`, `0.0` і `1` часто використовуються в таких контекстах:
```cpp
int idGenerator { 0 };         // fine: we're starting our id generator with value 0
idGenerator = idGenerator + 1; // fine: we're just incrementing our generator
```
Інші числа також можуть бути очевидними в контексті (а отже, не вважатися магічними):
```cpp
int kmtoM(int km)
{
    return km * 1000; // fine: it's obvious 1000 is a conversion factor
}
```

> [!tip]
> Уникайте магічних чисел у коді