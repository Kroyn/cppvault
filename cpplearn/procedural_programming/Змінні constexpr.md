---
date: 2024-09-22
tags:
  - Процедурне_програмування
  - Фундаментальні_типи_дани
---
У попередньому уроці, ми визначили, що таке константний вираз і чому константні вирази бажано використовувати.

Ми також з'ясували, що у C++ є два типи константних змінних: константні змінні часу компіляції та константні змінні часу виконання. У константних виразах можна використовувати лише константні змінні часу компіляції - константні змінні часу виконання (і неконстантні змінні) використовувати не можна.

Оскільки константні змінні часу компіляції не мають суттєвих недоліків, ми зазвичай прагнемо використовувати константи часу компіляції там, де це можливо.
## Проблеми з константою часу компіляції
Також у попередньому уроці ми обговорили, що одним із способів створення константної змінної під час компіляції є використання ключового слова `const`. Якщо змінна `const` має цілочисельний тип та ініціалізатор константного виразу, вона є константою часу компіляції. Всі інші змінні `const` розглядаються як константи часу виконання.

Однак у цього методу є дві проблеми.

По-перше, при використанні `const` наші інтегральні змінні можуть стати константою часу компіляції або константою часу виконання, залежно від того, чи є ініціалізатор константним виразом, чи ні. У деяких випадках це може ускладнити визначення того, чи є змінна `const` константою часу компіляції, чи ні.

Наприклад:
```cpp
int a { 5 };       // not const at all
const int b { a }; // obviously a runtime const (since initializer is non-const)
const int c { 5 }; // obviously a compile-time const (since initializer is a constant expression)

const int d { someVar };    // not obvious whether this is a runtime or compile-time const
const int e { getValue() }; // not obvious whether this is a runtime or compile-time const
```
У наведеному вище прикладі і `d`, і `e` можуть бути або константою часу виконання, або константою часу компіляції, залежно від того, як визначено `someVar` і `getValue()`. Це не зрозуміло, поки ми не знайдемо визначення цих ідентифікаторів (що може вимагати пошуку визначення ініціалізаторів для цих змінних!).

По-друге, використання `const` для створення константних змінних часу компіляції не поширюється на неінтегральні змінні. Існує багато випадків, коли ми хотіли б, щоб неінтегральні змінні також були константами часу компіляції.
## Ключове слово `constexpr`
На щастя, ми можемо звернутися за допомогою до компілятора, щоб отримати константну змінну часу компіляції там, де ми цього бажаємо. Для цього ми використовуємо ключове слово `constexpr` (яке є скороченням від "**константний вираз**") замість `const` в оголошенні змінної. Змінна `constexpr` завжди є константою часу компіляції. Як наслідок, змінна `constexpr` має бути ініціалізована константним виразом, інакше виникне помилка компіляції.

Наприклад:
```cpp
#include <iostream>

// The return value of a non-constexpr function is not a constant expression
int five()
{
    return 5;
}

int main()
{
    constexpr double gravity { 9.8 }; // ok: 9.8 is a constant expression
    constexpr int sum { 4 + 5 };      // ok: 4 + 5 is a constant expression
    constexpr int something { sum };  // ok: sum is a constant expression

    std::cout << "Enter your age: ";
    int age{};
    std::cin >> age;

    constexpr int myAge { age };      // compile error: age is not a constant expression
    constexpr int f { five() };       // compile error: return value of five() is not a constant expression

    return 0;
}
```
Оскільки функції зазвичай виконуються під час виконання, значення, що повертається функцією, не є константним виразом (навіть якщо значення, що повертається оператором `return`, є константою). Ось чому `five()` не є легальним значенням ініціалізації для `constexpr int f`.

Крім того, `constexpr` працює зі змінними нецілих типів:
```cpp
constexpr double d { 1.2 }; // d can be used in constant expressions!
```
## Значення `const` vs `constexpr` для змінних
Для змінних:
- `const` означає, що значення об'єкта не може бути змінено після ініціалізації. Значення ініціалізатора може бути відоме під час компіляції або під час виконання програми. Об'єкт `const` можна обчислити під час виконання програми.
- `constexpr` означає, що об'єкт можна використовувати у константному виразі. Значення ініціалізатора має бути відоме під час компіляції. Об'єкт `constexpr` можна обчислити під час виконання або компіляції.
Змінні `constexpr` неявно є `const`. Змінні типу `const` не є неявно `constexpr` (за винятком інтегральних змінних типу `const` з ініціалізатором у вигляді константного виразу). Хоча змінна може бути визначена і як `constexpr`, і як `const`, у більшості випадків це є надлишковим, і нам потрібно використовувати тільки `const` або `constexpr`.

На відміну від `const`, `constexpr` не є частиною типу об'єкта. Тому змінна, визначена як `constexpr int`, насправді має тип `const int` (через неявне `const`, яке `constexpr` надає об'єктам).

> [!tip]
> Будь-яка константна змінна, ініціалізатором якої є константний вираз, має бути оголошена як `constexpr`.
> 
> Будь-яку константну змінну, ініціалізатор якої не є константним виразом (що робить її константою часу виконання), слід оголошувати як `const`.
> 
> Застереження: У майбутньому ми обговоримо деякі типи, які не повністю сумісні з `constexpr` (зокрема, `std::string`, `std::vector` та інші типи, які використовують динамічне виділення пам'яті). Для константних об'єктів цих типів або використовуйте `const` замість `constexpr`, або виберіть інший тип, сумісний з `constexpr` (наприклад, `std::string_view` або `std::array`).

> [!NOTE]
> Термін `constexpr` - це портфоліо "**константних виразів**". Цю назву було обрано тому, що об'єкти `constexpr` (і функції) можна використовувати у константних виразах.
> 
> Формально, ключове слово `constexpr` стосується лише об'єктів і функцій. Умовно, термін `constexpr` використовується як скорочення для будь-якого константного виразу (наприклад, `1 + 2`).
## Параметри функцій `const` та `constexpr`
Звичайні виклики функцій обчислюються під час виконання, а передані аргументи використовуються для ініціалізації параметрів функції. Оскільки ініціалізація параметрів функції відбувається під час виконання, це призводить до двох наслідків:
1. Параметри функції `const` розглядаються як константи часу виконання (навіть якщо переданий аргумент є константою часу компіляції).
2. Параметри функції не можуть бути оголошені як `constexpr`, оскільки їхні початкові значення не визначаються до часу виконання.
> [!NOTE]
> C++ підтримує функції, які можуть бути обчислені під час компіляції (а отже, можуть бути використані у константних виразах).
> 
> C++ також підтримує передачу констант часу компіляції у функцію.
## Огляд номенклатури

| Термін                    | Визначення                                                                                                                                                             |
| ------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Константа часу компіляції | Значення або немодифікований об'єкт, значення якого має бути відоме під час компіляції (наприклад, літерали та змінні constexpr).                                      |
| Constexpr                 | Ключове слово, яке оголошує змінні константами часу компіляції (і функціями, які можна обчислити під час компіляції). Неформально, скорочення від "константний вираз". |
| Постійний вираз           | Вираз, що містить лише константи часу компіляції та оператори/функції, які підтримують обчислення під час компіляції.                                                  |
| Вираз часу виконання      | Вираз, який не є константним виразом.                                                                                                                                  |
| Константа часу виконання  | Значення або немодифікований об'єкт, який не є константою часу компіляції.                                                                                             |
