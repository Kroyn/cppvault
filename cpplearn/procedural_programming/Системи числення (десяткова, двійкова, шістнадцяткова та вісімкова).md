---
date: 2024-09-22
tags:
  - Процедурне_програмування
  - Константи_та_рядки
---

> [!NOTE]
> Цей урок є факультативним.
> 
> У наступних уроках мова йтиме про шістнадцяткові числа, тому вам слід хоча б побіжно ознайомитися з цією концепцією, перш ніж продовжувати.

У повсякденному житті ми рахуємо за допомогою десяткових чисел, де кожна цифра може бути 0, 1, 2, 3, 4, 5, 6, 7, 8 або 9. Десяткову систему числення ще називають "основа 10", оскільки в ній є 10 можливих цифр (від 0 до 9). У цій системі ми рахуємо так: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... За замовчуванням числа в програмах на C++ вважаються десятковими.
```cpp
int x { 12 }; // 12 is assumed to be a decimal number
```
У двійковому коді є лише 2 цифри: 0 і 1, тому вона називається "основа 2". У двійковій системі числення ми рахуємо так: 0, 1, 10, 11, 100, 101, 110, 111, ...

Десяткова та двійкова системи числення - це два приклади систем числення, які є вигадливою назвою для набору символів (наприклад, цифр), що використовуються для представлення чисел. У C++ існує 4 основні системи числення. У порядку популярності це: десяткова (основа 10), двійкова (основа 2), шістнадцяткова (основа 16) та вісімкова (основа 8).

> [!NOTE]
> Як у десятковій, так і в двійковій системі числення числа `0` і `1` мають однакове значення. В обох системах ми називаємо ці числа "нуль" і "одиниця".
> 
> А як щодо числа `10`? `10` - це число, яке стоїть після останнього однозначного числа в системі числення. У десятковій системі числення `10` дорівнює дев'ять плюс один. Ми називаємо це число "десять".
> 
> У двійковій системі числення `10` використовує ті ж цифри, але дорівнює одиниці плюс один (еквівалент двійки в десятковій системі числення). Було б незрозуміло називати двійкове число `10` "десять", тому що "десять" - це дев'ять плюс один, а це число `10` - це один плюс один.
> 
> Тому назви "десять", "одинадцять", "дванадцять" і т.д. зазвичай зарезервовані для десяткових чисел. У недесяткових системах числення ми воліємо називати ці числа один-нуль, один-один, один-два і т.д... Двійкове число 101 - це не "сто один", а "один-нуль-один".
## Вісімкові та шістнадцяткові літерали
**Вісімкова система числення** має основу 8 - тобто, єдиними доступними цифрами є 0, 1, 2, 3, 4, 5, 6 і 7. У вісімковій системі числення ми рахуємо так: 0, 1, 2, 3, 4, 5, 6, 7, 10, 11, 12, ... (зверніть увагу: немає 8 і 9, тому ми пропускаємо від 7 до 10)

| Decimal | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  |
| ------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Octal   | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 10  | 11  | 12  | 13  |
Щоб використовувати вісімковий літерал, додайте до нього 0 (нуль):
```cpp
#include <iostream>

int main()
{
    int x{ 012 }; // 0 before the number means this is octal
    std::cout << x << '\n';
    return 0;
}
```
Ця програма друкує:
```
10
```
Чому 10, а не 12? Тому що числа за замовчуванням виводяться в десятковій системі числення, а 12 вісімкових = 10 десяткових.

Вісімкова система числення майже не використовується, і ми рекомендуємо вам уникати її.

**Шістнадцяткова система числення** має основу 16. У шістнадцятковій системі числення ми рахуємо так: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, 10, 11, 12, …

| Decimal     | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  | 16  | 17  |
| ----------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Hexadecimal | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | A   | B   | C   | D   | E   | F   | 10  | 11  |
Ви також можете використовувати малі літери (хоча більш поширеною є велика).

Щоб використовувати шістнадцяткові літерали, додайте до них префікс `0x`:
```cpp
#include <iostream>

int main()
{
    int x{ 0xF }; // 0x before the number means this is hexadecimal
    std::cout << x << '\n';
    return 0;
}
```
Ця програма друкує:
```
15
```
Ви також можете використовувати префікс `0X`, але `0x` є загальноприйнятим, оскільки його легше читати.
## Використання шістнадцяткової системи числення для представлення двійкових чисел
Оскільки існує 16 різних значень для шістнадцяткової цифри, можна сказати, що одна шістнадцяткова цифра охоплює 4 біти. Отже, пара шістнадцяткових цифр може бути використана для точного представлення повного байта.

| Hexadecimal | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | A    | B    | C    | D    | E    | F    |
| ----------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| Binary      | 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 |
Розглянемо 32-бітне ціле число з двійковим значенням 0011 1010 0111 1111 1001 1000 0010 0110. Через довжину та повторення цифр його нелегко читати. У шістнадцятковій системі числення це значення буде таким: 3A7F 9826, що набагато лаконічніше. З цієї причини шістнадцяткові значення часто використовуються для представлення адрес пам'яті або необроблених даних у пам'яті (тип яких невідомий).
## Бінарні літерали
До версії C++14 не було підтримки двійкових літералів. Однак, шістнадцяткові літерали надають нам корисний обхідний шлях (який ви все ще можете побачити в існуючих кодових базах):
```cpp
#include <iostream>

int main()
{
    int bin{};    // assume 16-bit ints
    bin = 0x0001; // assign binary 0000 0000 0000 0001 to the variable
    bin = 0x0002; // assign binary 0000 0000 0000 0010 to the variable
    bin = 0x0004; // assign binary 0000 0000 0000 0100 to the variable
    bin = 0x0008; // assign binary 0000 0000 0000 1000 to the variable
    bin = 0x0010; // assign binary 0000 0000 0001 0000 to the variable
    bin = 0x0020; // assign binary 0000 0000 0010 0000 to the variable
    bin = 0x0040; // assign binary 0000 0000 0100 0000 to the variable
    bin = 0x0080; // assign binary 0000 0000 1000 0000 to the variable
    bin = 0x00FF; // assign binary 0000 0000 1111 1111 to the variable
    bin = 0x00B3; // assign binary 0000 0000 1011 0011 to the variable
    bin = 0xF770; // assign binary 1111 0111 0111 0000 to the variable

    return 0;
}
```
Починаючи з C++14, ми можемо використовувати двійкові літерали, використовуючи префікс 0b:
```cpp
#include <iostream>

int main()
{
    int bin{};        // assume 16-bit ints
    bin = 0b1;        // assign binary 0000 0000 0000 0001 to the variable
    bin = 0b11;       // assign binary 0000 0000 0000 0011 to the variable
    bin = 0b1010;     // assign binary 0000 0000 0000 1010 to the variable
    bin = 0b11110000; // assign binary 0000 0000 1111 0000 to the variable

    return 0;
}
```
## Роздільники цифр
Оскільки довгі літерали важко читати, у C++14 також додано можливість використовувати лапки (') як роздільник цифр.
```cpp
#include <iostream>

int main()
{
    int bin { 0b1011'0010 };  // assign binary 1011 0010 to the variable
    long value { 2'132'673'462 }; // much easier to read than 2132673462

    return 0;
}
```
Також зверніть увагу, що роздільник не може стояти перед першою цифрою значення:
```cpp
int bin { 0b'1011'0010 };  // error: ' used before first digit of value
```
Розділювачі цифр є суто візуальними і ніяк не впливають на буквальне значення.
## Виведення значень у десятковому, вісімковому або шістнадцятковому форматі
За замовчуванням C++ виводить значення у десятковій системі числення. Однак ви можете змінити формат виведення за допомогою маніпуляторів вводу/виводу `std::dec`, `std::oct` та `std::hex`:
```cpp
#include <iostream>

int main()
{
    int x { 12 };
    std::cout << x << '\n'; // decimal (by default)
    std::cout << std::hex << x << '\n'; // hexadecimal
    std::cout << x << '\n'; // now hexadecimal
    std::cout << std::oct << x << '\n'; // octal
    std::cout << std::dec << x << '\n'; // return to decimal
    std::cout << x << '\n'; // decimal

    return 0;
}
```
Це відбиток:
```
12
c
c
14
12
12
```
Зауважте, що після застосування маніпулятор вводу/виводу залишається налаштованим на майбутній вивід, доки його не буде змінено знову.
## Виведення значень у двійковому форматі
Виведення значень у двійковому вигляді трохи складніше, оскільки `std::cou`t не має вбудованих можливостей для цього. На щастя, стандартна бібліотека C++ включає тип `std::bitset`, який зробить це за нас (у заголовку `<bitset>`).

Щоб використовувати `std::bitset`, ми можемо визначити змінну `std::bitset` і вказати `std::bitset`, скільки бітів ми хочемо зберігати. Кількість бітів має бути константою часу компіляції. `std::bitset` можна ініціалізувати цілим числом (у будь-якому форматі, включаючи десятковий, вісімковий, шістнадцятковий або двійковий).
```cpp
#include <bitset> // for std::bitset
#include <iostream>

int main()
{
	// std::bitset<8> means we want to store 8 bits
	std::bitset<8> bin1{ 0b1100'0101 }; // binary literal for binary 1100 0101
	std::bitset<8> bin2{ 0xC5 }; // hexadecimal literal for binary 1100 0101

	std::cout << bin1 << '\n' << bin2 << '\n';
	std::cout << std::bitset<4>{ 0b1010 } << '\n'; // create a temporary std::bitset and print it

	return 0;
}
```
Це відбиток:
```
11000101
11000101
1010
```
У вищенаведеному коді цей рядок:
```cpp
std::cout << std::bitset<4>{ 0b1010 } << '\n'; // create a temporary std::bitset and print it
```
створює тимчасовий (безіменний) об'єкт `std::bitset` з 4 бітами, ініціалізує його двійковим літералом `0b1010`, виводить значення у двійковому вигляді, а потім відкидає тимчасовий об'єкт.
## Виведення значень у двійковому форматі за допомогою бібліотеки Формат / Друк `Додатково`
У C++20 та C++23 ми маємо кращі можливості для друку двійкових файлів за допомогою нової бібліотеки форматів (C++20) та бібліотеки друку (C++23):
```cpp
#include <format> // C++20
#include <iostream>
#include <print> // C++23

int main()
{
    std::cout << std::format("{:b}\n", 0b1010);  // C++20, {:b} formats the argument as binary digits
    std::cout << std::format("{:#b}\n", 0b1010); // C++20, {:#b} formats the argument as 0b-prefixed binary digits

    std::println("{:b} {:#b}", 0b1010, 0b1010);  // C++23, format/print two arguments (same as above) and a newline

    return 0;
}
```
Це виводе:
```
1010
0b1010
1010 0b1010
```