---
date: 2024-09-24
tags:
  - Процедурне_програмування
  - Константи_та_рядки
---
Оскільки `std::string_view` є нашою першою зустріччю з типом представлення, ми присвятимо йому додатковий час для подальшого обговорення. Ми зосередимося на тому, як безпечно використовувати `std::string_view`, і надамо кілька прикладів, що ілюструють, як його можна використовувати неправильно. Ми завершимо розгляд деякими рекомендаціями щодо того, коли слід використовувати `std::string`, а коли `std::string_view`.
## Вступ до власників та глядачів
Давайте на мить проведемо аналогію. Скажімо, ви вирішили, що будете малювати велосипед. Але у вас немає велосипеда! Що ви будете робити?

Ну, ви можете піти в місцевий веломагазин і купити його. Він стане твоїм власником. Це має певні переваги: тепер у вас є велосипед, на якому ви можете їздити. Ви можете гарантувати, що велосипед завжди буде доступний, коли ви захочете. Ви можете прикрасити його або перевезти. У цього вибору є і деякі недоліки. Велосипеди коштують дорого. І якщо ви його купили, то тепер ви несете за нього відповідальність. Ви повинні періодично його обслуговувати. А коли ви вирішите, що він вам більше не потрібен, ви маєте правильно його утилізувати.

Власність може бути дорогою. Як власник, ви несете відповідальність за придбання, управління та належне розпорядження об'єктами, які вам належать.

Виходячи з дому, ви дивитеся у вікно на вулицю. Ви помічаєте, що ваш сусід припаркував велосипед навпроти вашого вікна. Ви можете просто намалювати велосипед сусіда (як його видно з вашого вікна). Цей вибір має багато переваг. Ви заощаджуєте кошти на купівлю власного велосипеда. Вам не потрібно його обслуговувати. Ви також не несете відповідальності за його утилізацію. Коли ви закінчите перегляд, ви можете просто закрити штори і продовжити жити далі. На цьому ваш погляд на об'єкт закінчується, але на сам об'єкт це не впливає. У цього вибору також є деякі потенційні недоліки. Ви не можете розфарбувати чи налаштувати велосипед сусіда. І поки ви дивитеся на велосипед, ваш сусід може вирішити змінити його вигляд або взагалі прибрати його з поля вашого зору. Натомість ви можете побачити щось несподіване.

Перегляд коштує недорого. Як глядач, ви не несете жодної відповідальності за об'єкти, на які дивитеся, але ви також не маєте жодного контролю над цими об'єктами.
## `std::string` - власник
Вам може бути цікаво, чому `std::string` робить дорогу копію свого ініціалізатора. Коли об'єкт створюється, для нього виділяється пам'ять для зберігання будь-яких даних, які йому знадобляться протягом його життя. Ця пам'ять зарезервована для об'єкта і гарантовано існує до тих пір, поки існує об'єкт. Це безпечне місце. std::string (і більшість інших об'єктів) копіюють значення ініціалізації, яке їм надається, у цю пам'ять, щоб мати власне незалежне значення для доступу і маніпулювання ним пізніше. Після того, як значення ініціалізації скопійовано, об'єкт більше не залежить від ініціалізатора жодним чином.

І це добре, тому що після завершення ініціалізації, як правило, не можна довіряти ініціалізатору. Якщо уявити процес ініціалізації як виклик функції, яка ініціалізує об'єкт, то хто передає ініціалізатор? Той, хто викликає функцію. Коли ініціалізація завершена, керування повертається назад до того, хто викликає. У цей момент інструкція ініціалізації завершена, і зазвичай відбувається одна з двох речей:
- Якщо ініціалізатор був тимчасовим значенням або об'єктом, цей тимчасовий об'єкт буде негайно знищено.
- Якщо ініціалізатором була змінна, користувач все ще має доступ до цього об'єкта. Викликач може робити з об'єктом все, що йому заманеться, у тому числі змінювати або знищувати його.
> [!NOTE]
> Ініціалізований об'єкт не має контролю над тим, що станеться зі значенням ініціалізації після завершення ініціалізації.

Оскільки `std::string` створює власну копію значення, їй не потрібно турбуватися про те, що станеться після завершення ініціалізації. Ініціалізатор можна знищити або змінити, і це не вплине на `std::string`. Недоліком є те, що ця незалежність має свою ціну у вигляді дорогої копії.

У контексті нашої аналогії, `std::string` є власником. У нього є власні дані, якими він керує. І коли його знищують, він прибирає за собою.
## Нам не завжди потрібна копія
Давайте повернемося до прикладу з попереднього уроку:
```cpp
#include <iostream>
#include <string>

void printString(std::string str) // str makes a copy of its initializer
{
    std::cout << str << '\n';
}

int main()
{
    std::string s{ "Hello, world!" };
    printString(s);

    return 0;
}
```
Коли викликається `printString(s)`, `str` робить дорогу копію `s`. Функція друкує скопійований рядок, а потім знищує його.

Зверніть увагу, що `s` вже містить рядок, який ми хочемо надрукувати. Чи можемо ми просто використати рядок, який зберігається у `s`, замість того, щоб створювати копію? Відповідь - можливо, але нам потрібно оцінити три критерії:
- Чи можна знищити `s` під час використання `str`? Ні, `str` знищується в кінці функції, а `s` існує в області видимості викликаючого користувача і не може бути знищений до повернення функції.
- Чи можна модифікувати `s` під час використання `str`? Ні, `str` знищується в кінці функції, і користувач не має можливості змінити `s` до того, як функція повернеться.
- Чи змінює `str` рядок у спосіб, якого не очікує користувач? Ні, функція не модифікує рядок взагалі.

Оскільки всі три критерії хибні, немає ніякого ризику у використанні рядка, який тримає s, замість того, щоб зробити його копію. А оскільки копії рядків коштують дорого, навіщо платити за копію, яка нам не потрібна?
## `std::string_view` - переглядач
`std::string_view` використовує інший підхід до ініціалізації. Замість того, щоб створювати дорогу копію рядка ініціалізації, `std::string_view` створює недороге представлення рядка ініціалізації. Потім `std::string_view` можна використовувати щоразу, коли потрібен доступ до рядка.

У контексті нашої аналогії, std::string_view є переглядачем. Він переглядає об'єкт, який вже існує деінде, і не може змінювати цей об'єкт. Коли перегляд знищується, об'єкт, що переглядається, не змінюється.

Важливо зазначити, що `std::string_view` залишається залежним від ініціалізатора протягом усього свого життя. Якщо рядок, який переглядається, буде змінено або знищено під час використання представлення, це призведе до неочікуваної або невизначеної поведінки.

Кожного разу, коли ми використовуємо представлення, ми повинні гарантувати, що ці можливості не виникнуть.
> [!caution]
> Подання залежить від об'єкта, який переглядається. Якщо об'єкт, який переглядається, змінено або знищено під час використання подання, це призведе до неочікуваної або невизначеної поведінки.

Подання `std::string_view`, яке переглядає знищений рядок, іноді називають висячим поданням.
## `std::string_view` найкраще використовувати як параметр функції, доступний лише для читання
Найкраще використовувати `std::string_view` як параметр функції, доступний лише для читання. Це дозволяє нам передавати аргумент у стилі C - рядок, `std::string` або `std::string_view` - без створення копії, оскільки `std::string_view` створить подання для аргументу.
```cpp
#include <iostream>
#include <string>
#include <string_view>

void printSV(std::string_view str) // now a std::string_view, creates a view of the argument
{
    std::cout << str << '\n';
}

int main()
{
    printSV("Hello, world!"); // call with C-style string literal

    std::string s2{ "Hello, world!" };
    printSV(s2); // call with std::string

    std::string_view s3 { s2 };
    printSV(s3); // call with std::string_view

    return 0;
}
```
Оскільки параметр функції `str` створюється, ініціалізується, використовується і знищується до того, як керування повертається до викликаючого, немає ризику, що рядок, який переглядається (аргумент функції), буде змінено або знищено до того, як буде створено наш параметр str.
## Яким параметрам функції надавати перевагу: `std::string_view` чи `const std::string&`? `Розширений`
У більшості випадків надавайте перевагу `std::string_view`.
## Неправильне використання `std::string_view`
Давайте розглянемо декілька випадків, коли неправильне використання `std::string_view` може призвести до неприємностей.

Ось наш перший приклад:
```cpp
#include <iostream>
#include <string>
#include <string_view>

int main()
{
    std::string_view sv{};

    { // create a nested block
        std::string s{ "Hello, world!" }; // create a std::string local to this nested block
        sv = s; // sv is now viewing s
    } // s is destroyed here, so sv is now viewing an invalid string

    std::cout << sv << '\n'; // undefined behavior

    return 0;
}
```
У цьому прикладі ми створюємо `std::string s` всередині вкладеного блоку (поки що не турбуйтеся про те, що таке вкладений блок). Потім ми встановлюємо `sv` на перегляд `s`. `s` буде знищено в кінці вкладеного блоку. `sv` не знає, що `s` було знищено. Коли ми потім використовуємо `sv`, ми отримуємо доступ до недійсного об'єкту, що призводить до невизначеної поведінки.

Ось ще один варіант тієї ж проблеми, де ми ініціалізуємо `std::string_view` значенням `std::string`, що повертається функцією:
```cpp
#include <iostream>
#include <string>
#include <string_view>

std::string getName()
{
    std::string s { "Alex" };
    return s;
}

int main()
{
  std::string_view name { getName() }; // name initialized with return value of function
  std::cout << name << '\n'; // undefined behavior

  return 0;
}
```
Цей приклад поводиться так само, як і попередній. Функція `getName()` повертає `std::string`, що містить рядок `"Alex"`. Значення, що повертаються, є тимчасовими об'єктами, які знищуються в кінці повного виразу, що містить виклик функції. Ми повинні або використати це значення негайно, або скопіювати його, щоб використати пізніше.

Але `std::string_view` не робить копій. Замість цього він створює подання для тимчасового значення, що повертається, яке потім знищується. Це залишає наш `std::string_view` у підвішеному стані (перегляд недійсного об'єкта), а друк представлення призводить до невизначеної поведінки.

Нижче наведено менш очевидний варіант вищеописаного:
```cpp
#include <iostream>
#include <string>
#include <string_view>

int main()
{
    using namespace std::string_literals;
    std::string_view name { "Alex"s }; // "Alex"s creates a temporary std::string
    std::cout << name << '\n'; // undefined behavior

    return 0;
}
```
Літерал `std::string` (створений за допомогою суфікса `s`) створює тимчасовий об'єкт `std::string`. Отже, у цьому випадку `"Alex "s` створює тимчасовий `std::string`, який ми потім використовуємо як ініціалізатор для `name`. У цей момент `name` переглядає тимчасовий `std::string`. Потім тимчасовий рядок `std::string` знищується, а ім'я залишається у підвішеному стані. Ми отримуємо невизначену поведінку при подальшому використанні name.
> [!caution]
> Не ініціалізуйте `std::string_view` літералом `std::string`, оскільки це призведе до зависання `std::string_view`.
> 
> Можна ініціалізувати `std::string_view` рядковим літералом у стилі C або літералом `std::string_view`. Також можна ініціалізувати `std::string_view` рядковим об'єктом у стилі C, об'єктом `std::string` або об'єктом `std::string_view`, якщо цей рядковий об'єкт переживе вигляд.

Ми також можемо отримати невизначену поведінку при зміні базового рядка:
```cpp
#include <iostream>
#include <string>
#include <string_view>

int main()
{
    std::string s { "Hello, world!" };
    std::string_view sv { s }; // sv is now viewing s

    s = "Hello, universe!";    // modifies s, which invalidates sv (s is still valid)
    std::cout << sv << '\n';   // undefined behavior

    return 0;
}
```
У цьому прикладі `sv` знову встановлюється на вигляд `s`. Потім `s` модифікується. Коли std::string модифікується, всі представлення для цього `std::string` стають недійсними, тобто ці представлення тепер є недійсними. Використання недійсного представлення призведе до невизначеної поведінки. Таким чином, коли ми виводимо `sv`, виникає невизначена поведінка.

Наведемо той самий приклад, що й у попередньому, але ми перепровіримо `sv`:
```cpp
#include <iostream>
#include <string>
#include <string_view>

int main()
{
    std::string s { "Hello, world!" };
    std::string_view sv { s }; // sv is now viewing s

    s = "Hello, universe!";    // modifies s, which invalidates sv (s is still valid)
    std::cout << sv << '\n';   // undefined behavior

    sv = s;                    // revalidate sv: sv is now viewing s again
    std::cout << sv << '\n';   // prints "Hello, universe!"

    return 0;
}
```
Після того, як `sv` стає недійсним через модифікацію `s`, ми повторно перевіряємо `sv` за допомогою оператора `sv = s`, що призводить до того, що `sv` знову стає дійсним представленням s. Коли ми виводимо `sv` вдруге, він виводить "Привіт, всесвіте!".
## Будьте обережні, повертаючи `std::string_view`
`std::string_view` можна використовувати як значення, що повертається функцією. Однак, це часто буває небезпечно.

Оскільки локальні змінні знищуються в кінці функції, повернення `std::string_view`, який переглядає локальну змінну, призведе до того, що повернутий `std::string_view` буде недійсним, і подальше використання цього `std::string_view` призведе до невизначеної поведінки. Наприклад:
```cpp
#include <iostream>
#include <string>
#include <string_view>

std::string_view getBoolName(bool b)
{
    std::string t { "true" };  // local variable
    std::string f { "false" }; // local variable

    if (b)
        return t;  // return a std::string_view viewing t

    return f; // return a std::string_view viewing f
} // t and f are destroyed at the end of the function

int main()
{
    std::cout << getBoolName(true) << ' ' << getBoolName(false) << '\n'; // undefined behavior

    return 0;
}
```
У вищенаведеному прикладі, коли викликається `getBoolName(true)`, функція повертає `std::string_view`, який переглядає `t`. Однак, `t` знищується в кінці функції. Це означає, що повернутий `std::string_view` переглядає об'єкт, який було знищено. Отже, коли повернутий `std::string_view` виводиться на друк, виникає невизначена поведінка.

Ваш компілятор може попередити вас про такі випадки, а може і не попередити.

Існує два основних випадки, коли `std::string_view` можна повертати безпечно. По-перше, оскільки рядкові літерали у стилі C існують для всієї програми, цілком нормально (і корисно) повертати рядкові літерали у стилі C з функції, яка має тип повернення `std::string_view`.
```cpp
#include <iostream>
#include <string_view>

std::string_view getBoolName(bool b)
{
    if (b)
        return "true";  // return a std::string_view viewing "true"

    return "false"; // return a std::string_view viewing "false"
} // "true" and "false" are not destroyed at the end of the function

int main()
{
    std::cout << getBoolName(true) << ' ' << getBoolName(false) << '\n'; // ok

    return 0;
}
```
Це виводе:
```
true false
```
При виклику `getBoolName(true)` функція поверне `std::string_view`, що містить рядок у стилі C `"true"`. Оскільки `"true"` існує для всієї програми, не виникає жодних проблем, коли ми використовуємо повернутий `std::string_view` для виведення `"true"` в `main()`.

По-друге, повертати параметр функції типу `std::string_view` взагалі нормально:
```cpp
#include <iostream>
#include <string>
#include <string_view>

std::string_view firstAlphabetical(std::string_view s1, std::string_view s2)
{
    return s1 < s2 ? s1: s2; // uses operator?: (the conditional operator)
}

int main()
{
    std::string a { "World" };
    std::string b { "Hello" };

    std::cout << firstAlphabetical(a, b) << '\n'; // prints "Hello"

    return 0;
}
```
Можливо, не так очевидно, чому це нормально. По-перше, зауважте, що аргументи `a` і `b` існують в області видимості того, хто викликає функцію. Коли функція викликається, параметр функції `s1` є видом на a, а параметр функції `s2` - видом на `b`. Коли функція повертає або `s1`, або `s2`, вона повертає вид на `a` або `b` тому, хто її викликає. Оскільки `a` і `b` все ще існують у цей момент, можна використовувати повернутий `std::string_view` до `a` або `b`.

Тут є одна важлива тонкість. Якщо аргумент є тимчасовим об'єктом (який буде знищено в кінці повного виразу, що містить виклик функції), значення, що повертається `std::string_view`, має бути використано у цьому ж виразі. Після цього тимчасовий об'єкт буде знищено, а `std::string_view` залишиться бовтатися.
> [!caution]
> Якщо аргумент є тимчасовим, який знищується в кінці повного виразу, що містить виклик функції, повернутий `std::string_view` має бути використаний негайно, оскільки після знищення тимчасового він залишиться "висіти".
## Переглянути функції модифікації
Уявіть собі вікно у вашому будинку, з якого ви бачите електромобіль, що стоїть на вулиці. Ви можете дивитися у вікно і бачити автомобіль, але не можете доторкнутися до нього або перемістити його. Ваше вікно лише забезпечує вид на автомобіль, який є абсолютно окремим об'єктом.

У багатьох вікнах є штори, які дозволяють нам модифікувати наш погляд. Ми можемо закрити ліву чи праву шторку, щоб зменшити те, що ми можемо бачити. Ми не змінюємо те, що зовні, ми просто зменшуємо видиму зону.

Оскільки `std::string_view` - це вигляд, він містить функції, які дозволяють нам змінювати наш вигляд, "закриваючи шторки". Це ніяк не змінює рядок, який ви переглядаєте, лише сам вигляд.
- Функція-член `remove_prefix()` видаляє символи з лівого боку подання.
- Функція-член `remove_suffix()` видаляє символи з правого боку подання.
```cpp
#include <iostream>
#include <string_view>

int main()
{
	std::string_view str{ "Peach" };
	std::cout << str << '\n';

	// Remove 1 character from the left side of the view
	str.remove_prefix(1);
	std::cout << str << '\n';

	// Remove 2 characters from the right side of the view
	str.remove_suffix(2);
	std::cout << str << '\n';

	str = "Peach"; // reset the view
	std::cout << str << '\n';

	return 0;
}
```
Ця програма виводить наступний результат:
```
Peach
each
ea
Peach
```
На відміну від реальних штор, після виклику `remove_prefix()` та `remove_suffix()` єдиний спосіб скинути вигляд - це знову призначити йому вихідний рядок.
## `std::string_view` може переглядати підрядок
Це підводить нас до важливого застосування `std::string_view`. Хоча `std::string_view` можна використовувати для перегляду цілого рядка без створення копії, він також корисний, коли ми хочемо переглянути підрядок без створення копії. Підрядок - це неперервна послідовність символів всередині існуючого рядка. Наприклад, у рядку `"snowball"` деякими підрядками є `"snow"`, `"all"` і `"now"`. `"owl"` не є підрядком `"snowball"`, оскільки ці символи не з'являються поруч у рядку `"snowball"`.
## `std::string_view` може бути або не бути завершеним нулем
Можливість перегляду лише підрядка більшого рядка має один важливий наслідок: `std::string_view` може бути, а може і не бути завершеним нулем.

Розглянемо рядок `"snowball"`, який завершується нульовим закінченням (тому що це рядковий літерал у стилі C, який завжди завершується нульовим закінченням). Якщо `std::string_view` переглядає весь рядок, то він переглядає рядок з нульовим закінченням. Однак, якщо `std::string_view` переглядає лише підрядок `"now"`, то цей підрядок не є нульовим (наступний символ - `'b'`).
> [!NOTE]
> Рядковий літерал у стилі C та `std::string` завжди завершуються нульовим закінченням.
> Подання `std::string_view` може закінчуватися або не закінчуватися нулем.

Майже у всіх випадках це не має значення - `std::string_view` відстежує довжину рядка або підрядка, який він переглядає, тому йому не потрібен нуль-термінатор. Перетворення `std::string_view` у `std::string` працюватиме незалежно від того, чи є `std::string_view` нуль-термінатором, чи ні.
> [!caution]
> Не пишіть код, який припускає, що `std::string_view` завершується нульовим завершенням.

> [!tip]
> Якщо у вас є `std::string_view`, що не завершується нульовим закінченням, а вам з якихось причин потрібен рядок з нульовим закінченням, перетворіть `std::string_view` у `std::string`.
## Короткий посібник з використання `std::string` та `std::string_view`
Цей посібник не претендує на вичерпність, але має на меті висвітлити найпоширеніші випадки:

### Змінні
Використовуйте змінну `std::string` коли:
- Вам потрібен рядок, який можна змінювати.
- Вам потрібно зберігати введений користувачем текст.
- Вам потрібно зберігати значення, що повертається функцією, яка повертає 'std::string'.

Використовуйте змінну `std::string_view` коли:
- Вам потрібен доступ тільки для читання до частини або всього рядка, який вже існує в іншому місці і не буде змінений або знищений до завершення використання `std::string_view`.
- Вам потрібна символьна константа для рядка у стилі C.
- Вам потрібно продовжити перегляд значення, що повертається функцією, яка повертає рядок у стилі C або `std::string_vie`w, що не бовтається.

### Параметри функції
Використовуйте параметр функції `std::string` коли:
- Функція повинна змінювати рядок, переданий як аргумент, не впливаючи на користувача, який її викликає. Це трапляється рідко.
- Ви використовуєте стандарт мови C++14 або старішу версію і ще не знайомі з використанням посилань.
Використовуйте параметр функції `std::string_view` коли:
- Функції потрібен рядок, доступний тільки для читання.
- Функція повинна працювати з рядками, що не закінчуються нулем.

> [!NOTE]
> Використовуйте параметр функції `const std::string&` коли:
> - Ви використовуєте стандарт мови C++14 або старішу версію, і для роботи функції потрібен рядок, доступний лише для читання (оскільки `std::string_view` недоступний до C++17).
> - Ви викликаєте інші функції, які потребують const std::string, `const std::string&` або `const` у стилі C (оскільки `std::string_view` не може завершуватися нулем).
> 
> Використовуйте параметр функції `std::string&` коли:
> - Ви використовуєте `std::string` як вихідний параметр.
> - Ви викликаєте інші функції, які вимагають `std::string&` або неконстантний рядок у стилі C.

### Типи повернень
Використовуйте тип повернення `std::string` коли:
- Значення, що повертається, є локальною змінною `std::string` або параметром функції.
- Значенням, що повертається, є виклик функції або оператор, який повертає `std::string` за значенням.
Використовуйте тип повернення `std::string_view` коли:
- Функція повертає рядковий літерал у стилі C або локальне представлення `std::string_view`, ініціалізоване рядковим літералом у стилі C.
- Функція повертає параметр `std::string_view`.

> [!NOTE]
> Використовуйте тип повернення `std::string_view` коли:
> - Запис аксесора для члена std::string_view.
> 
> Використовувати тип повернення `std::string&` коли:
> - Функція повертає параметр типу `std::string&`.
> 
> Використовувати тип повернення `const std::string&` коли:
> - Функція повертає параметр `const std::string&`.
> - Запис аксесора для члена `std::string` або `const std::string`.
> - Функція повертає статичну (локальну або глобальну) константу `std::string`.

### Інсайти
Що потрібно пам'ятати про `std::string`:
- Ініціалізація та копіювання `std::string` коштує дорого, тому уникайте цього якомога менше.
- Не передавайте `std::string` за значенням, оскільки це призводить до копіювання.
- Якщо можливо, уникайте створення недовговічних об'єктів `std::string`.
- Модифікація `std::string` зробить недійсними будь-які представлення цього рядка.
- Можна повертати локальний `std::string` за значенням.

Що потрібно пам'ятати про `std::string_view`:
- `std::string_view` зазвичай використовується для передачі параметрів рядкових функцій і повернення рядкових літералів.
- Оскільки рядкові літерали у стилі C існують для всієї програми, завжди можна встановити `std::string_view` як рядковий літерал у стилі C.
- Коли рядок знищується, всі представлення цього рядка стають недійсними.
- Використання недійсного представлення (за винятком використання присвоєння для повторної перевірки представлення) призведе до невизначеної поведінки.
- Подання `std::string_view` може бути або не бути завершеним нулем.