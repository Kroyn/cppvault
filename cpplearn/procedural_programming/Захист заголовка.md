---
date: 2024-09-06
tags:
  - Процедурне_програмування
  - Основи
---
## Проблема дублювання визначень
```cpp
int main()
{
    int x; // this is a definition for variable x
    int x; // compile error: duplicate definition

    return 0;
}
```

Аналогічно, програми, які визначають функцію більше одного разу, також призведуть до помилки компіляції:

```cpp
#include <iostream>

int foo() // this is a definition for function foo
{
    return 5;
}

int foo() // compile error: duplicate definition
{
    return 5;
}

int main()
{
    std::cout << foo();
    return 0;
}
```

Якщо ці програми легко виправити (видалити дублікат визначення), то з заголовними файлами досить легко опинитися в ситуації, коли визначення в заголовному файлі включається більше одного разу. Це може статися, коли заголовний файл `#include` включає інший заголовний файл (що є поширеним явищем).

> [!NOTE]
> У наступних прикладах ми визначимо деякі функції всередині заголовних файлів. Зазвичай цього робити не слід.
> 
> Ми робимо так, тому що це найефективніший спосіб продемонструвати деякі концепції, використовуючи функціональність, яку ми вже розглянули.

Розглянемо наступний академічний приклад:

`square.h`:

```cpp
int getSquareSides()
{
    return 4;
}
```

`wave.h`:

```cpp
#include "square.h"
```

`main.cpp`:

```cpp
#include "square.h"
#include "wave.h"

int main()
{
    return 0;
}
```

Ця, на перший погляд, безневинна програма не компілюється! Ось що відбувається. Спочатку `main.cpp` `#include` `square.h`, який копіює визначення функції `getSquareSides` в `main.cpp`. Потім `main.cpp` `#include` wave.h, який `#include` сам square.h. Це копіює вміст square.h (включаючи визначення функції `getSquareSides`) у wave.h, який потім копіюється у `main.cpp`.

Таким чином, після розв'язання всіх `#include`, `main.cpp` має такий вигляд:

```cpp
int getSquareSides()  // from square.h
{
    return 4;
}

int getSquareSides() // from wave.h (via square.h)
{
    return 4;
}

int main()
{
    return 0;
}
```

Дублікати визначень і помилка компіляції. Кожен файл, окремо, є нормальним. Однак, оскільки `main.cpp` двічі `#include` вміст square.h, ми зіткнулися з проблемою. Якщо `wave.h` потребує `getSquareSides()`, а `main.cpp` потребує і `wave.h`, і `square.h`, як би ви вирішили цю проблему?
## Захист зоголовка
Хороша новина полягає в тому, що ми можемо уникнути вищезгаданої проблеми за допомогою механізму, який називається захистом заголовка (також званим захистом включення). Захисники заголовків - це директиви умовної компіляції, які мають наступний вигляд:

```cpp
#ifndef SOME_UNIQUE_NAME_HERE
#define SOME_UNIQUE_NAME_HERE

// your declarations (and certain types of definitions) here

#endif
```

Коли цей заголовок `#include`, препроцесор перевірить, чи було раніше визначено `SOME_UNIQUE_NAME_HERE` у цьому блоці перекладу. Якщо ми включаємо цей заголовок уперше, `SOME_UNIQUE_NAME_HERE` не буде визначено. Отже, він `#define` `SOME_UNIQUE_NAME_HERE` і включає вміст файлу. Якщо заголовок буде включено до того самого файлу повторно, `SOME_UNIQUE_NAME_HERE` вже буде визначено з моменту першого включення вмісту заголовка, і вміст заголовка буде проігноровано (завдяки `#ifndef`).

Усі ваші файли заголовків повинні мати захисники заголовків. `SOME_UNIQUE_NAME_HERE` може бути будь-якою назвою, яку ви хочете, але за домовленістю це повна назва заголовного файлу, набрана великими літерами, з використанням підкреслень для пробілів або розділових знаків. Наприклад, square.h матиме заголовок guard:

`square.h`:

```cpp
#ifndef SQUARE_H
#define SQUARE_H

int getSquareSides()
{
    return 4;
}

#endif
```

Навіть стандартні заголовки бібліотек використовують захисники заголовків. Якщо ви подивитеся на заголовний файл `iostream` з Visual Studio, ви побачите це:

```
```cpp
#ifndef _IOSTREAM_
#define _IOSTREAM_

// content here

#endif
```

> [!NOTE]
> У великих програмах можлива наявність двох окремих заголовних файлів (включених з різних каталогів), які зрештою мають однакове ім'я (наприклад, `directoryA\config.h` і `directoryB\config.h`). Якщо для захисту від включення використовується лише ім'я файлу (наприклад, `CONFIG_H`), ці два файли можуть мати однакове ім'я захисту. Якщо це станеться, будь-який файл, який включає (прямо чи опосередковано) обидва файли `config.h`, не отримає вміст файлу `include`, який буде включено другим. Це, ймовірно, призведе до помилки компіляції.
> 
> Через таку можливість конфлікту імен захисних елементів, багато розробників рекомендують використовувати складніші/унікальні імена для захисних елементів заголовків. Деякі з них рекомендують використовувати такі імена, як `PROJECT_PATH_FILE_H`, `FILE_LARGE-RANDOM-NUMBER_H`, or `FILE_CREATION-DATE_H`.
## Оновлення нашого попереднього прикладу з захисниками заголовків
Повернімося до прикладу з square.h, використовуючи square.h з захисниками заголовків. Для гарного вигляду ми також додамо захисники заголовків до wave.h.

`square.h`

```cpp
#ifndef SQUARE_H
#define SQUARE_H

int getSquareSides()
{
    return 4;
}

#endif
```

`wave.h`:

```cpp
#ifndef WAVE_H
#define WAVE_H

#include "square.h"

#endif
```

`main.cpp`:

```cpp
#include "square.h"
#include "wave.h"

int main()
{
    return 0;
}
```

Після того, як препроцесор вирішить всі директиви `#include`, ця програма має такий вигляд:

`main.cpp`:

```cpp
// Square.h included from main.cpp
#ifndef SQUARE_H // square.h included from main.cpp
#define SQUARE_H // SQUARE_H gets defined here

// and all this content gets included
int getSquareSides()
{
    return 4;
}

#endif // SQUARE_H

#ifndef WAVE_H // wave.h included from main.cpp
#define WAVE_H
#ifndef SQUARE_H // square.h included from wave.h, SQUARE_H is already defined from above
#define SQUARE_H // so none of this content gets included

int getSquareSides()
{
    return 4;
}

#endif // SQUARE_H
#endif // WAVE_H

int main()
{
    return 0;
}
```

Давайте подивимося, як це оцінюється.

Спочатку препроцесор обчислює `#ifndef` SQUARE_H. SQUARE_H ще не визначено, тому код від `#ifndef` до наступного `#endif` включено для компіляції. Цей код визначає SQUARE_H і містить визначення функції getSquareSides.

Пізніше обчислюється наступний `#ifndef` SQUARE_H. Цього разу SQUARE_H визначено (оскільки його було визначено вище), тому код від `#ifndef` до наступного `#endif` виключено з компіляції.

Захисти заголовків запобігають повторним включенням, оскільки при першій зустрічі з захистом макрос захисту не визначено, тому захищений вміст включається. Після цього макрос захисту визначено, тому будь-які наступні копії вмісту, що захищається, виключаються.

## Захисники заголовків не перешкоджають повторному включенню заголовка в різні файли коду
Зауважте, що метою захисників заголовків є запобігання отриманню файлом коду більше ніж однієї копії захищеного заголовка. За задумом, захисники заголовків не запобігають включенню певного заголовка (один раз) до окремих файлів коду. Це також може спричинити неочікувані проблеми. Розглянемо приклад:

`square.h`:

```cpp
#ifndef SQUARE_H
#define SQUARE_H

int getSquareSides()
{
    return 4;
}

int getSquarePerimeter(int sideLength); // forward declaration for getSquarePerimeter

#endif
```

`square.cpp`:

```cpp
#include "square.h"  // square.h is included once here

int getSquarePerimeter(int sideLength)
{
    return sideLength * getSquareSides();
}
```

`main.cpp`:

```cpp
#include "square.h" // square.h is also included once here
#include <iostream>

int main()
{
    std::cout << "a square has " << getSquareSides() << " sides\\n";
    std::cout << "a square of length 5 has perimeter length " << getSquarePerimeter(5) << '\\n';

    return 0;
}
```

Зверніть увагу, що файл square.h включається як з `main.cpp`, так і з `square.cpp`. Це означає, що вміст файлу square.h буде включено один раз до файлу `square.cpp` і один раз до файлу `main.cpp`.

Давайте розглянемо, чому це відбувається більш детально. Коли `square.h` включається з `square.cpp`, `SQUARE_H` визначається до кінця `square.cpp`. Це визначення запобігає повторному включенню `square.h` в `square.cpp` (в цьому і полягає сенс захисту заголовків). Однак, після завершення роботи `square.cpp`, `SQUARE_H` більше не вважається визначеною. Це означає, що коли препроцесор запускається на `main.cpp`, `SQUARE_H` не визначено в `main.cpp`.

У результаті і `square.cpp`, і `main.cpp` отримають копію визначення `getSquareSides`. Програма скомпілюється, але компонувальник поскаржиться на те, що у вашій програмі є декілька визначень для ідентифікатора `getSquareSides`!

Найкращий спосіб обійти цю проблему - просто помістити визначення функції в один з `.cpp`-файлів так, щоб заголовок містив лише пряме оголошення:

`square.h`:

```cpp
#ifndef SQUARE_H
#define SQUARE_H

int getSquareSides(); // forward declaration for getSquareSides
int getSquarePerimeter(int sideLength); // forward declaration for getSquarePerimeter

#endif
```

`square.cpp`:

```cpp
#include "square.h"

int getSquareSides() // actual definition for getSquareSides
{
    return 4;
}

int getSquarePerimeter(int sideLength)
{
    return sideLength * getSquareSides();
}
```

`main.cpp`:

```cpp
#include "square.h" // square.h is also included once here
#include <iostream>

int main()
{
    std::cout << "a square has " << getSquareSides() << " sides\\n";
    std::cout << "a square of length 5 has perimeter length " << getSquarePerimeter(5) << '\\n';

    return 0;
}
```

Тепер при компіляції програми функція `getSquareSides` матиме лише одне визначення (через `square.cpp`), тому компонувальник задоволений. Файл `main.cpp` може викликати цю функцію (хоча вона живе в `square.cpp`), тому що він містить файл square.h, який має пряме оголошення функції (компонувальник зв'яже виклик `getSquareSides` з `main.cpp` з визначенням `getSquareSides` в `square.cpp`).

## Чи не можна просто уникнути визначень у заголовних файлах?
Ми вже говорили, що не варто включати визначення функцій у заголовки. Тож вам може бути цікаво, навіщо включати захисники заголовків, якщо вони захищають вас від того, чого вам не слід робити.

Існує досить багато випадків, які ми покажемо вам у майбутньому, коли необхідно розміщувати нефункціональні визначення у заголовному файлі. Наприклад, C++ дозволяє створювати власні типи. Ці користувацькі типи зазвичай визначаються у заголовних файлах, тому визначення типів можна поширювати на файли коду, які мають їх використовувати. Без захисту заголовків у файлі коду може з'явитися декілька (ідентичних) копій визначення типу, що компілятор буде вважати помилкою.

Отже, хоча на даному етапі вивчення цієї серії підручників не обов'язково використовувати захисники заголовків, ми створюємо хороші звички зараз, щоб вам не довелося відучуватися від поганих звичок пізніше.

## `#pragma once`

Сучасні компілятори підтримують простішу, альтернативну форму захисників заголовків за допомогою директиви препроцесора `#pragma`:

```cpp
#pragma once

// your code here
```

`#pragma` виконує ту саму функцію, що й захисники заголовків: запобігає багаторазовому включенню файлу заголовка. За допомогою традиційних захисників заголовків розробник відповідає за захист заголовка (використовуючи директиви препроцесора `#ifndef`, `#define` та `#endif`). За допомогою `#pragma` one ми просимо компілятор захистити заголовок. Як саме він це робить, залежить від конкретної реалізації.

> [!NOTE]
> Існує один відомий випадок, коли `#pragma once` зазвичай не спрацьовує. Якщо файл заголовка скопійовано так, що він існує у кількох місцях файлової системи, і якщо якимось чином обидві копії заголовка потрапляють до неї, захисники заголовків успішно дедупують ідентичні заголовки, але `#pragma once` не зможе (тому що компілятор не зрозуміє, що це насправді ідентичний вміст).

Для більшості проектів `#pragma once` працює добре, і багато розробників надають перевагу цьому, оскільки він простіший і менш схильний до помилок. Багато IDE також автоматично включають `#pragma once` на початку нового заголовного файлу, що генерується за допомогою IDE.

> [!caution]
> Директиву `#pragma` було розроблено для того, щоб реалізатори компіляторів могли використовувати її для будь-яких цілей. Таким чином, те, які прагматики підтримуються і яке значення вони мають, повністю залежить від конкретної реалізації. За винятком одного випадку, не очікуйте, що прагматика, яка працює на одному компіляторі, буде підтримуватися іншим компілятором.

Оскільки `#pragma` once не визначено стандартом C++, існує ймовірність того, що деякі компілятори можуть не реалізувати її. З цієї причини деякі розробники (наприклад, Google) рекомендують використовувати традиційні захисники заголовків. У цій серії підручників ми надаватимемо перевагу захисникам заголовків, оскільки вони є найбільш традиційним способом захисту заголовків. Проте, підтримка `#pragma` once є досить поширеною, і якщо ви бажаєте використовувати `#pragma` once замість них, це є загальноприйнятим у сучасній C++.
## Підсумок
Засоби захисту заголовків призначені для того, щоб вміст певного файлу заголовків не копіювався більше одного разу в один і той самий файл, щоб запобігти дублюванню визначень.

Повторювані декларації - це нормально, але навіть якщо ваш заголовний файл складається з одних декларацій (без визначень), все одно рекомендується включати захисники заголовків.

Зауважте, що засоби захисту заголовків не перешкоджають копіюванню вмісту заголовного файлу (один раз) до окремих файлів проекту. Це добре, оскільки нам часто потрібно посилатися на вміст певного заголовка у різних файлах проекту.