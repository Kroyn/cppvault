---
date: 2024-09-22
tags:
  - Процедурне_програмування
  - Константи_та_рядки
---

| Operator    | Symbol | Form      | Meaning                                                                |
| ----------- | ------ | --------- | ---------------------------------------------------------------------- |
| Conditional | ?:     | c ? x : y | If conditional `c` is `true` then evaluate `x`, otherwise evaluate `y` |
**Умовний оператор** (`?:`) (який також іноді називають **арифметичним оператором if**) є **тернарним оператором** (оператором, який приймає 3 операнди). Оскільки історично це був єдиний тернарний оператор у C++, його також іноді називають "тернарним оператором".

Оператор `?:` надає скорочений метод для виконання певного типу інструкцій if-else.

Нагадаємо, що інструкція if-else має наступний вигляд:
```
if (умова)
    твердження1;
else
    твердження2;
```
Якщо `умова` набуває значення `true`, то виконується `твердження1`, інакше виконується `твердження2`. Оператор `else` та `оператор2` не є обов'язковими.

Оператор `?:` має наступний вигляд:
```
умова ? твердження1 : твердження2;
```
Якщо `умова` набуває значення `true`, то обчислюється `твердження1`, інакше обчислюється `твердження2`. Символи `:` та `твердження2` не є обов'язковими.

Розглянемо інструкцію if-else, яка має такий вигляд:
```cpp
if (x > y)
    greater = x;
else
    greater = y;
```
Це можна переписати як:
```cpp
greater = ((x > y) ? x : y);
```
У таких випадках умовний оператор може допомогти ущільнити код без втрати читабельності.
## Умовний оператор обчислює у вигляді виразу
Оскільки операндами умовного оператора є вирази, а не оператори, умовний оператор можна використовувати там, де потрібен вираз.

Наприклад, при ініціалізації змінної:
```cpp
#include <iostream>

int main()
{
    constexpr bool inBigClassroom { false };
    constexpr int classSize { inBigClassroom ? 30 : 20 };
    std::cout << "The class size is: " << classSize << '\n';

    return 0;
}
```
Для цього немає прямої заміни if-else. Ви можете спробувати щось подібне:
```cpp
#include <iostream>

int main()
{
    constexpr bool inBigClassroom { false };

    if (inBigClassroom)
        constexpr int classSize { 30 };
    else
        constexpr int classSize { 20 };

    std::cout << "The class size is: " << classSize << '\n';

    return 0;
}
```
Однак це не буде скомпільовано, і ви отримаєте повідомлення про помилку, що `classSize` не визначено. Подібно до того, як змінні, визначені всередині функцій, знищуються в кінці функції, змінні, визначені всередині if- або else-інструкції, знищуються в кінці if- або else-інструкції. Таким чином, `classSize` вже буде знищено, коли ми спробуємо його надрукувати.

Якщо ви хочете використовувати if-else, вам доведеться зробити щось подібне:
```cpp
#include <iostream>

int getClassSize(bool inBigClassroom)
{
    if (inBigClassroom)
        return 30;
    else
        return 20;
}

int main()
{
    const int classSize { getClassSize(false) };
    std::cout << "The class size is: " << classSize << '\n';

    return 0;
}
```
Цей варіант працює, тому що `getClassSize(false)` є виразом, а логіка if-else знаходиться всередині функції (де ми можемо використовувати оператори). Але це багато зайвого коду, коли ми могли б просто використати умовний оператор.
## Взяття умовного оператора в круглі дужки
Оскільки C++ надає пріоритет обчисленню більшості операторів над обчисленню умовного оператора, досить легко написати вирази з використанням умовного оператора, які не обчислюються так, як очікується.

Наприклад:
```cpp
#include <iostream>

int main()
{
    int x { 2 };
    int y { 1 };
    int z { 10 - x > y ? x : y };
    std::cout << z;

    return 0;
}
```
Ви можете очікувати, що це буде `10 - (x > y ? x : y)` (що дорівнює `8`), але насправді це буде `(10 - x) > y ? x : y` (що дорівнює `2`).

З цієї причини умовний оператор слід брати у круглі дужки наступним чином:
- Беруть у круглі дужки всю умовну операцію (включно з операндами), якщо вона використовується у складеному виразі (виразі з іншими операторами).
- Для зручності читання умови слід брати її в круглі дужки, якщо вона містить будь-які оператори (окрім оператора виклику функції).

Операнди умовного оператора не потрібно брати в круглі дужки.

Давайте розглянемо деякі оператори, що містять умовний оператор, і те, як їх слід брати в круглі дужки:
```cpp
return isStunned ? 0 : movesLeft;           // not used in compound expression, condition contains no operators
int z { (x > y) ? x : y };                  // not used in compound expression, condition contains operators
std::cout << (isAfternoon() ? "PM" : "AM"); // used in compound expression, condition contains no operators (function call operator excluded)
std::cout << ((x > y) ? x : y);             // used in compound expression, condition contains operators
```

> [!tip]
> Взяти в круглі дужки всю умовну операцію (включно з операндами), якщо вона використовується у складеному виразі.
> 
> Для зручності читання слід брати умову в круглі дужки, якщо вона містить будь-які оператори (крім оператора виклику функції).
## Типи виразів повинні збігатися або бути конвертованими
Щоб відповідати правилам перевірки типів у C++, одна з наступних умов повинна бути істинною:
- Тип другого та третього операндів повинен співпадати.
- Компілятор повинен знайти спосіб перетворення одного або обох другого та третього операндів до відповідних типів. Правила перетворення, які використовує компілятор, досить складні і в деяких випадках можуть давати несподівані результати.

> [!NOTE]
> Альтернативно, один або обидва з другого та третього операндів можуть бути виразами, що викидаються(`throw`).

Наприклад:
```cpp
#include <iostream>

int main()
{
    std::cout << (true ? 1 : 2) << '\n';    // okay: both operands have matching type int

    std::cout << (false ? 1 : 2.2) << '\n'; // okay: int value 1 converted to double

    std::cout << (true ? -1 : 2u) << '\n';  // surprising result: -1 converted to unsigned int, result out of range

    return 0;
}
```
Припускаючи, що виводиться 4-байтне ціле число, виводиться вищенаведений приклад:
```
1
2.2
4294967295
```
Загалом, можна змішувати операнди з фундаментальними типами (за винятком змішування знакових і беззнакових значень). Якщо один з операндів не є фундаментальним типом, краще явно перетворити один або обидва операнди до відповідного типу самостійно, щоб ви точно знали, що ви отримаєте.

Якщо компілятор не зможе знайти спосіб перетворення другого та третього операндів до відповідного типу, буде видано помилку компіляції:
```cpp
#include <iostream>

int main()
{
    constexpr int x{ 5 };
    std::cout << ((x != 5) ? x : "x is 5"); // compile error: compiler can't find common type for constexpr int and C-style string literal

    return 0;
}
```
У наведеному вище прикладі один з виразів є цілим числом, а інший - рядковим літералом у стилі C. Компілятор не зможе самостійно знайти відповідний тип, тому виникне помилка компіляції.

У таких випадках ви можете або зробити явне перетворення, або використати інструкцію if-else:
```cpp
#include <iostream>
#include <string>

int main()
{
    int x{ 5 }; // intentionally non-constexpr for this example

    // We can explicitly convert the types to match
    std::cout << ((x != 5) ? std::to_string(x) : std::string{"x is 5"}) << '\n';

    // Or use an if-else statement
    if (x != 5)
        std::cout << x << '\n';
    else
        std::cout << "x is 5" << '\n';

    return 0;
}
```

> [!NOTE]
> Якщо `x` є `constexpr`, то умова `x != 5` є константним виразом. У таких випадках слід використовувати `if constexpr`, а не `if`, і компілятор може згенерувати попередження про це (яке буде перетворено на помилку, якщо ви вважаєте попередження помилками).
> 
> Оскільки ми ще не розглядали `if constexpr`, у цьому прикладі `x` не є `constexpr`, щоб уникнути потенційного попередження компілятора.
## Так коли ж слід використовувати умовний оператор?
Умовний оператор найбільш корисний при виконанні однієї з наступних дій:
- Ініціалізація об'єкта одним з двох значень.
- Присвоєння об'єкту одного з двох значень.
- Передача одного з двох значень у функцію.
- Повернення одного з двох значень з функції.
- Виведення одного з двох значень.

У складних виразах, як правило, слід уникати використання умовного оператора, оскільки вони схильні до помилок і важко читаються.
> [!tip]
> Надавайте перевагу уникненню умовного оператора у складних виразах.