---
date: 2024-09-06
tags:
  - Процедурне_програмування
  - Основи
---
У попередньому уроці ми дізналися, що функція може повертати значення назад тому, хто її викликав. Ми використали це для створення модульної функції `getValueFromUser`, яку використали у цій програмі:

```cpp
#include <iostream>

int getValueFromUser()
{
 	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;

	return input;
}

int main()
{
	int num { getValueFromUser() };

	std::cout << num << " doubled is: " << num * 2 << '\n';

	return 0;
}
```

Однак, що, якщо ми хочемо помістити рядок виводу у власну функцію? Ви можете спробувати щось подібне:

```cpp
#include <iostream>

int getValueFromUser()
{
 	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;

	return input;
}

// This function won't compile
void printDouble()
{
	std::cout << num << " doubled is: " << num * 2 << '\n';
}

int main()
{
	int num { getValueFromUser() };

	printDouble();

	return 0;
}
```

Це не буде скомпільовано, тому що функція `printDouble` не знає, що таке ідентифікатор num. Ви можете спробувати визначити num як змінну всередині функції `printDouble()`:

```cpp
void printDouble()
{
	int num{}; // we added this line
	std::cout << num << " doubled is: " << num * 2 << '\n';
}
```

Хоча це виправляє помилку компілятора і робить програму придатною для компіляції, програма все одно працює неправильно (вона завжди друкує "0 подвоєне є: 0"). Суть проблеми полягає в тому, що функція `printDouble` не має можливості отримати доступ до значення, яке ввів користувач.

Нам потрібно якось передати значення змінної num у функцію `printDouble`, щоб `printDouble` могла використовувати це значення в тілі функції.
## Параметри та аргументи функції
У багатьох випадках корисно мати можливість передавати інформацію функції, яку викликається, щоб функція мала дані для роботи. Наприклад, якщо ми хочемо написати функцію для додавання двох чисел, нам потрібно якось вказати функції, які саме два числа додавати, коли ми її викликаємо. Інакше, як функція дізнається, що саме додавати? Ми робимо це за допомогою параметрів та аргументів функції.

**Параметр функції** - це змінна, яка використовується в заголовку функції. Параметри функції працюють майже так само, як і змінні, визначені всередині функції, але з однією відмінністю: вони ініціалізуються значенням, яке надає користувач, що викликає функцію.

Параметри функції визначаються в заголовку функції, розміщуючи їх між круглими дужками після імені функції, причому декілька параметрів розділяються комами.

Нижче наведено приклади функцій з різною кількістю параметрів:

```cpp
// This function takes no parameters
// It does not rely on the caller for anything
void doPrint()
{
    std::cout << "In doPrint()\n";
}

// This function takes one integer parameter named x
// The caller will supply the value of x
void printValue(int x)
{
    std::cout << x  << '\n';
}

// This function has two integer parameters, one named x, and one named y
// The caller will supply the value of both x and y
int add(int x, int y)
{
    return x + y;
}
```

**Аргумент** - це значення, яке передається від викликувача до функції під час виклику функції:

```cpp
doPrint(); // this call has no arguments
printValue(6); // 6 is the argument passed to function printValue()
add(2, 3); // 2 and 3 are the arguments passed to function add()
```

Зверніть увагу, що декілька аргументів також відокремлюються комами.
## Як параметри та аргументи працюють разом
Під час виклику функції всі її параметри створюються як змінні, і значення кожного з аргументів копіюється у відповідний параметр (за допомогою ініціалізації копіювання). Цей процес називається **передачею за значенням**. Параметри функції, які використовують передачу за значенням, називаються параметрами-значеннями.

Наприклад:

```cpp
#include <iostream>

// This function has two integer parameters, one named x, and one named y
// The values of x and y are passed in by the caller
void printValues(int x, int y)
{
    std::cout << x << '\n';
    std::cout << y << '\n';
}

int main()
{
    printValues(6, 7); // This function call has two arguments, 6 and 7

    return 0;
}
```

Коли функція `printValues` викликається з аргументами `6` і `7`, параметр x функції `printValues` створюється та ініціалізується значенням `6`, а параметр y функції `printValues` створюється та ініціалізується значенням `7`.

Це призводить до виводу:

```cpp
6
7
```

Зауважте, що кількість аргументів повинна збігатися з кількістю параметрів функції, інакше компілятор видасть помилку. Аргументом, що передається у функцію, може бути будь-який допустимий вираз (оскільки аргумент по суті є лише ініціалізатором параметра, а ініціалізатори можуть бути будь-якими допустимими виразами).
## Виправлення нашої програми челенджів
Тепер у нас є інструмент, необхідний для виправлення програми, яку ми представили на початку уроку:

```cpp
#include <iostream>

int getValueFromUser()
{
 	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;

	return input;
}

void printDouble(int value) // This function now has an integer parameter
{
	std::cout << value << " doubled is: " << value * 2 << '\n';
}

int main()
{
	int num { getValueFromUser() };

	printDouble(num);

	return 0;
}
```

У цій програмі змінна num спочатку ініціалізується значенням, введеним користувачем. Потім викликається функція `printDouble`, і значення аргументу num копіюється у параметр `value` функції `printDouble`. Потім функція `printDouble` використовує значення параметра `value`.
## Використання значень, що повертаються, як аргументів
У вищенаведеній задачі ми бачимо, що змінна num використовується лише один раз, для передачі значення, що повертається функцією `getValueFromUser`, в аргумент виклику функції `printDouble`.

Ми можемо дещо спростити вищенаведений приклад наступним чином:

```cpp
#include <iostream>

int getValueFromUser()
{
 	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;

	return input;
}

void printDouble(int value)
{
	std::cout << value << " doubled is: " << value * 2 << '\n';
}

int main()
{
	printDouble(getValueFromUser());

	return 0;
}
```

Тепер ми використовуємо значення, що повертається функцією `getValueFromUser`, безпосередньо як аргумент функції `printDouble`!

Хоча ця програма більш лаконічна (і дає зрозуміти, що значення, прочитане користувачем, не буде використано ні для чого іншого), такий "компактний синтаксис" може здатися вам дещо важким для читання. Якщо вам зручніше користуватися версією, яка використовує змінну, то нічого страшного.
## Як параметри та значення, що повертаються, працюють разом
Використовуючи як параметри, так і значення, що повертається, ми можемо створювати функції, які приймають дані на вхід, виконують з ними певні обчислення і повертають значення користувачеві.

Ось приклад дуже простої функції, яка додає два числа і повертає результат користувачеві:

```cpp
#include <iostream>

// add() takes two integers as parameters, and returns the result of their sum
// The values of x and y are determined by the function that calls add()
int add(int x, int y)
{
    return x + y;
}

// main takes no parameters
int main()
{
    std::cout << add(4, 5) << '\n'; // Arguments 4 and 5 are passed to function add()
    return 0;
}
```

Виконання починається з початку `main`. При обчисленні `add(4, 5)` викликається функція `add`, параметр x ініціалізується значенням 4, а параметр y - значенням 5.

Оператор return у функції add обчислює `x + y` для отримання значення 9, яке потім повертається назад в `main`. Це значення 9 надсилається до `std::cout` для виведення на консоль.

Виведіть результат:
```cpp
9
```

В ілюстрованому форматі:

![Pasted image 20240902124654.png](./images/Pasted%20image%2020240902124654.png)
## Більше прикладів
Давайте розглянемо ще кілька викликів функцій:

```cpp
#include <iostream>

int add(int x, int y)
{
    return x + y;
}

int multiply(int z, int w)
{
    return z * w;
}

int main()
{
    std::cout << add(4, 5) << '\n'; // within add() x=4, y=5, so x+y=9
    std::cout << add(1 + 2, 3 * 4) << '\n'; // within add() x=3, y=12, so x+y=15

    int a{ 5 };
    std::cout << add(a, a) << '\n'; // evaluates (5 + 5)

    std::cout << add(1, multiply(2, 3)) << '\n'; // evaluates 1 + (2 * 3)
    std::cout << add(1, add(2, 3)) << '\n'; // evaluates 1 + (2 + 3)

    return 0;
}
```

Ця програма виводить результат:

```cpp
9
15
10
7
6
```

Перше твердження просте.

У другому операторі аргументами є вирази, які обчислюються перед передачею. У цьому випадку `1 + 2` обчислюється до 3, тому 3 копіюється до параметра `x`. `3 * 4` обчислюється до 12, тому 12 копіюється до параметра y. `add(3, 12)` перетворює до `15`.

Наступна пара операторів також відносно проста:

```cpp
int a{ 5 };
std::cout << add(a, a) << '\n'; // evaluates (5 + 5)
```

У цьому випадку викликається add(), де значення a копіюється в обидва параметри x і y. Оскільки a має значення 5, add(a, a) = add(5, 5), що призводить до значення 10.

Давайте подивимось на перший складний оператор у цій пачці:

```cpp
std::cout << add(1, multiply(2, 3)) << '\n'; // evaluates 1 + (2 * 3)
```

Коли виконується функція add, програмі потрібно визначити значення параметрів x та y. З x все просто, оскільки ми щойно передали їй ціле число 1. Щоб отримати значення параметра y, потрібно спочатку обчислити multiply(2, 3). Програма викликає multiply та ініціалізує z = 2 і w = 3, тому multiply(2, 3) повертає ціле значення 6. Тепер це значення 6 можна використати для ініціалізації параметра y функції add. add(1, 6) повертає ціле число 7, яке потім передається до std::cout для виводу на друк.

Висловлюємось менш багатослівно: add(1, multiply(2, 3)) обчислює до add(1, 6) обчислює до 7

Наступний вираз виглядає хитромудро, тому що один з аргументів, переданих для додавання, є ще одним викликом додавання.

```cpp
std::cout << add(1, add(2, 3)) << '\n'; // evaluates 1 + (2 + 3)
```

Але цей випадок працює точно так само, як і попередній. add(2, 3) спочатку виконує обчислення, в результаті чого повертає значення 5. Тепер вона може обчислити add(1, 5), яка обчислює значення 6, яке передається до std::cout для виведення на друк.

Менш багатослівно: add(1, add(2, 3)) обчислює до add(1, 5) => обчислює до 6
## Параметри без посилань
У деяких випадках ви зустрінете функції, які мають параметри, що не використовуються у тілі функції. Такі параметри називаються параметрами без посилань.

Як тривіальний приклад:

```cpp
void doSomething(int count) // warning: unreferenced parameter count
{
    // This function used to do something with count but it is not used any longer
}

int main()
{
    doSomething(4);

    return 0;
}
```

Як і у випадку з невикористаними локальними змінними, ваш компілятор, ймовірно, попередить, що змінна count була визначена, але не використовується.

У визначенні функції ім'я параметра функції не є обов'язковим. Тому у випадках, коли параметр функції має існувати, але не використовується у тілі функції, ви можете просто опустити його ім'я. Параметр без імені називається **неіменованим параметром**:

```cpp
void doSomething(int) // ok: unnamed parameter will not generate warning
{
}
```

Посібник зі стилю Google C++ рекомендує використовувати коментар, щоб задокументувати, що це був за неназваний параметр:

```cpp
void doSomething(int /*count*/)
{
}
```

> [!NOTE] 
> Вам, напевно, цікаво, навіщо писати функцію, яка має параметр, значення якого не використовується. Найчастіше це відбувається у випадках, подібних до наступного:
> 
> 1. Припустимо, у нас є функція з одним параметром. Пізніше функція якимось чином оновлюється, і значення параметра більше не потрібне. Якщо просто видалити невикористаний параметр функції, то кожен існуючий виклик функції завершиться помилково (тому що при виклику функції буде передано більше аргументів, ніж функція може прийняти). Це вимагало б від нас знайти кожен виклик функції і видалити непотрібний аргумент. Це може зайняти багато часу (і вимагатиме багато повторних тестувань). Це також може виявитися неможливим (у випадках, коли ми не контролюємо весь код, що викликає функцію). Тому замість цього ми можемо залишити параметр як є, і просто змусити його нічого не робити.

> [!tip] 
> Якщо параметр функції існує, але не використовується в тілі функції, не давайте йому імені. За бажанням ви можете вказати ім'я у коментарі.
## Висновок
Параметри функції та значення, що повертаються, є ключовими механізмами, за допомогою яких можна писати функції для багаторазового використання, оскільки це дозволяє нам писати функції, які можуть виконувати завдання і повертати отримані або обчислені результати назад тому, хто їх викликає, не знаючи заздалегідь, якими будуть конкретні вхідні або вихідні дані.