---
date: 2024-09-01
tags:
  - Процедурне_програмування
  - Основи
---
Нагадуємо, що спочатку виділяється одна ціла змінна з іменем x, а потім виділяються ще дві цілі змінні з іменами y та z:

```cpp
int x;    // оголосити цілочисельну змінну з іменем x
int y, z; // оголосити дві цілочисельні змінні з іменами y та z
```

## Присвоєння змінних

Після визначення змінної ви можете надати їй значення (в окремому операторі) за допомогою оператора =. Цей процес називається **присвоюванням**, а оператор = - **оператором присвоювання**.

```cpp
int width; // оголосити цілочисельну змінну з іменем width
width = 5; // присвоїти змінній width значення 5

// змінна width тепер має значення 5
```

За замовчуванням присвоювання копіює значення у правій частині оператора = до змінної у лівій частині оператора. Це називається **присвоюванням з копіюванням**.

Ось приклад, де ми використовуємо присвоювання двічі:

```cpp
#include <iostream>

int main()
{
	int width;
	width = 5; // скопіювати присвоєння значення 5 у змінну width

	std::cout << width; // вивести 5

	width = 7; // змінити значення, що зберігається у змінній width на 7

	std::cout << width; // вивести 7

	return 0;
}
```

```
57
```

Коли ми присвоюємо змінній width значення 7, значення 5, яке було там раніше, перезаписується. Звичайні змінні можуть зберігати лише одне значення одночасно.


> [!attention] 
> Одна з найпоширеніших помилок програмістів-початківців - плутати оператор присвоювання (`=`) з оператором рівності (`==`). Присвоєння (`=`) використовується для присвоєння значення змінній. Оператор рівності (`==`) використовується для перевірки рівності двох операндів за значенням.
## Ініціалізація
Недоліком присвоювання є те, що воно вимагає щонайменше двох операторів: один для визначення змінної, а інший для присвоювання значення.

Ці два кроки можна комбінувати. Коли об'єкт визначено, ви можете за бажанням надати йому початкове значення. Процес визначення початкового значення для об'єкта називається **ініціалізацією**, а синтаксис, який використовується для ініціалізації об'єкта, називається **ініціалізатором**.

```cpp
int width { 5 }; // визначити змінну width та ініціалізувати початковим значенням 5

// змінна width тепер має значення 5
```

У наведеній вище ініціалізації змінної `width`, `{ 5 }` є ініціалізатором, а `5` - початковим значенням.

## Різні форми ініціалізації

Якщо не передбачено ініціалізатора (наприклад, для змінної `a` вище), це називається **ініціалізацією за замовчуванням**. У більшості випадків ініціалізація за замовчуванням не виконує ніякої ініціалізації і залишає змінну з невизначеним значенням.

## Ініціалізація копіювання

Коли початкове значення вказується після знаку рівності, це називається **ініціалізацією копіюванням**. Ця форма ініціалізації була успадкована з мови C.

```cpp
int width = 5; // скопіювати ініціалізацію значення 5 у змінну width
```

Подібно до присвоювання копіювання, цей метод копіює значення у правій частині рівності у змінну, що створюється у лівій частині. У наведеному вище фрагменті змінну `width` буде ініціалізовано значенням `5`.

Ініціалізація копіюванням впала в немилість у сучасній C++ через те, що вона менш ефективна, ніж інші форми ініціалізації для деяких складних типів. Однак у C++17 було виправлено більшість цих проблем, і зараз ініціалізація копіями знаходить нових прихильників. Ви також знайдете її у старому коді (особливо у коді, перенесеному з C), або у розробників, які просто вважають, що вона виглядає більш природно і легше читається.

> [!NOTE] 
> Ініціалізація копіюванням також використовується, коли значення неявно копіюються або перетворюються, наприклад, при передачі аргументів у функцію за значенням, поверненні з функції за значенням або перехопленні винятків за значенням.
## Пряма ініціалізація
Коли початкове значення вказується у круглих дужках, це називається **прямою ініціалізацією**.

```cpp
int width( 5 ); // безпосередня ініціалізація значення 5 у змінну width
```

Пряму ініціалізацію було запроваджено для більш ефективної ініціалізації складних об'єктів. Як і ініціалізація копіями, пряма ініціалізація втратила популярність у сучасній C++, здебільшого через те, що була витіснена ініціалізацією списками. Однак тепер ми знаємо, що ініціалізація списками має свої особливості, і тому пряма ініціалізація знову знаходить застосування у певних випадках.

> [!NOTE] 
> Пряма ініціалізація також використовується, коли значення явно приводяться до іншого типу.
> 
> Однією з причин, чому пряма ініціалізація втратила популярність, є те, що через неї важко відрізнити змінні від функцій. Наприклад:
> ```cpp
> int x(); // пряме оголошення функції x
int x(0); // оголошення змінної x з ініціалізатором 0
## Ініціалізація списку
Сучасним способом ініціалізації об'єктів у C++ є використання форми ініціалізації, яка використовує фігурні дужки. Це називається **ініціалізацією списком** (або **рівномірною ініціалізацією**, або **ініціалізацією фігурними дужками**).

Ініціалізація списком буває трьох видів:

```cpp
int width { 5 }; // пряма ініціалізація списку початкового значення 5 у змінну width
int height = { 6 }; // ініціалізація списку копіювання початкового значення 6 у змінну height
int depth {}; // ініціалізація значення (описується нижче)
```

До запровадження ініціалізації списками деякі типи ініціалізації вимагали використання ініціалізації копіями, а інші типи ініціалізації вимагали використання прямої ініціалізації. Ініціалізацію списком було введено для забезпечення більш узгодженого синтаксису ініціалізації (саме тому її іноді називають "уніфікованою ініціалізацією"), який працює у більшості випадків.
## Ініціалізація списку забороняє звуження перетворень
Основною перевагою ініціалізації списком є те, що "звужуючі перетворення" заборонено. Це означає, що якщо ви спробуєте ініціалізувати змінну списком, використовуючи значення, яке змінна не може безпечно зберігати, компілятор видасть діагностичне повідомлення (зазвичай це помилка). Наприклад:

```cpp
int main()
{
    // Ціле число може містити тільки не дробові значення
    int w1 { 4.5 }; // помилка компіляції: список init не допускає звужуючого перетворення 4.5 до 4

    int w2 = 4.5; // компіляція: copy init ініціалізує width значенням 4
    int w3(4.5); // компіляція: прямий init ініціалізує width 4

    return 0;
}
```

У рядку 4 вищенаведеної програми ми використовуємо значення (`4.5`) з дробовим компонентом (`.5`) для ініціалізації цілої змінної (яка може містити лише недробові значення). Оскільки це звужуюче перетворення, компілятор повинен видавати діагностику у таких випадках.

Ініціалізація копією (рядок 6) і пряма ініціалізація (рядок 7) не помічають `.5` і ініціалізують змінну значенням `4` (що, ймовірно, не те, чого ми хочемо). Ваш компілятор може попередити вас про це, оскільки втрата даних рідко буває бажаною, але може і не попередити.

Зауважте, що це обмеження на звуження перетворень стосується лише ініціалізації списку, а не будь-яких наступних присвоювань змінної:

```cpp
int main()
{
    int w1 { 4.5 }; // помилка компіляції: список init не дозволяє звуження з 4.5 до 4

    w1 = 4.5; // все гаразд: присвоєння копії дозволяє звузити приведення 4.5 до 4

    return 0;
}
```
## Ініціалізація списком є переважною формою ініціалізації в сучасному C++
Підсумовуючи, можна сказати, що ініціалізація списком є кращою за інші форми ініціалізації, оскільки вона працює у більшості випадків (а отже, є найбільш послідовною), не допускає звужуючих перетворень (що зазвичай нам не потрібно) і підтримує ініціалізацію списками значень (про це ми поговоримо у наступному уроці). Поки ви вчитеся, ми рекомендуємо дотримуватися прямої ініціалізації списками (та ініціалізації значеннями).

> [!success] Найкращі практики
> Надавайте перевагу прямій ініціалізації списком (або ініціалізації значенням) для ініціалізації ваших змінних.

> [!NOTE] 
> Б'ярн Строуструп (творець C++) та Герб Саттер (експерт з C++) також рекомендують [використовувати ініціалізацію списком](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-list) для ініціалізації ваших змінних.
> 
> Через такі примхи деякі досвідчені розробники рекомендують використовувати поєднання ініціалізації копіюванням, безпосередньою ініціалізацією та ініціалізацією списком, залежно від обставин. Після того, як ви будете достатньо знайомі з мовою, щоб зрозуміти нюанси кожного типу ініціалізації та аргументацію таких рекомендацій, ви зможете самостійно оцінити, наскільки переконливими ви вважаєте ці аргументи
## Ініціалізація значення та нульова ініціалізація
Коли змінну ініціалізовано за допомогою порожніх дужок, відбувається ініціалізація значення. У більшості випадків ініціалізація значенням ініціалізує змінну нулем (або порожнім значенням, якщо це більш прийнятно для даного типу). У таких випадках, коли відбувається обнулення, це називається нульовою ініціалізацією.

```cpp
int width {}; // ініціалізація значенням / ініціалізація нуля значенням 0
```

## Ініціалізуйте ваші змінні
Ініціалізуйте змінні при створенні. З часом ви можете виявити випадки, коли ви захочете проігнорувати цю пораду з певних причин (наприклад, критична для продуктивності ділянка коду, яка використовує багато змінних), і це нормально, якщо вибір зроблено свідомо.

> [!NOTE] 
> Для більш детального обговорення цієї теми, Б'ярн Строуструп (творець C++) та Герб Саттер (експерт з C++) самі дають цю рекомендацію [тут](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#es20-always-initialize-an-object).
Ініціалізуйте змінні після створення!

## Ініціалізація декількох змінних
Ми також зазначали, що найкращою практикою є повне уникнення цього синтаксису. Однак, оскільки ви можете зіткнутися з іншим кодом, який використовує цей стиль, корисно поговорити про нього трохи докладніше, хоча б для того, щоб підкреслити деякі з причин, чому його слід уникати.

Ви можете ініціалізувати декілька змінних, визначених в одному рядку:

```cpp
int a = 5, b = 6;          // ініціалізація копіюванням
int c( 7 ), d( 8 );        // пряма ініціалізація
int e { 9 }, f { 10 };     // пряма ініціалізація з фігурних дужок
int g = { 9 }, h = { 10 }; // скопіювати ініціалізацію через фігурні дужки
int i {}, j {};            // ініціалізація значення
```

На жаль, тут існує поширена пастка, яка може виникнути, коли програміст помилково намагається ініціалізувати обидві змінні за допомогою одного оператора ініціалізації:

```cpp
int a, b = 5; // неправильно (a не ініціалізовано!)

int a = 5, b = 5; // правильно
```

У верхньому операторі змінна "a" залишиться неініціалізованою, і компілятор може поскаржитися, а може і не поскаржитися. Якщо ні, то це чудовий спосіб змусити вашу програму періодично падати або видавати спорадичні результати. Про те, що станеться, якщо ви будете використовувати неініціалізовані змінні, ми поговоримо далі.

Найкращий спосіб запам'ятати, що це неправильно, - розглянути випадок прямої ініціалізації або ініціалізації фігурними дужками:

```cpp
int a, b( 5 );
int c, d{ 5 };
```

Оскільки дужки зазвичай ставляться безпосередньо біля імені змінної, це дає змогу зрозуміти, що значення 5 використовується лише для ініціалізації змінних b і d, а не a або c.
## Попередження про невикористані ініціалізовані змінні
Сучасні компілятори зазвичай видають попередження, якщо змінну ініціалізовано, але не використано (оскільки це рідко буває бажаним). А якщо увімкнено опцію "розглядати попередження як помилки", ці попередження буде підвищено до рівня помилок, що призведе до збою компіляції.

Розглянемо наступну невинну на вигляд програму:

```cpp
int main()
{
    int x { 5 }; // визначена змінна

    // але ніде не використовується

    return 0;
}
```

При компіляції цього коду компілятором g++ видається наступна помилка:

```
prog.cc: In function 'int main()':
prog.cc:3:9: error: unused variable 'x' [-Werror=unused-variable]
```

і програма не компілюється.

Є кілька простих способів виправити це.

1. Якщо змінна дійсно не використовується, то найпростіший варіант - видалити визначення x (або закоментувати його). Зрештою, якщо вона не використовується, то її видалення ні на що не вплине.
2. Інший варіант - просто десь використовувати змінну:

```cpp
#include <iostream>

int main()
{
    int x { 5 };

    std::cout << x; // змінна тепер десь використовується

    return 0;
}
```

Але це вимагає певних зусиль для написання коду, який його використовує, і має зворотній бік у вигляді потенційної зміни поведінки вашої програми.
## Атрибут `[[maybe_unused]]` C++17
У деяких випадках жоден з наведених вище варіантів не є бажаним. Розглянемо випадок, коли у нас є набір математичних/фізичних величин, які ми використовуємо у багатьох різних програмах:

```cpp
#include <iostream>

int main()
{
    // Ось деякі математичні/фізичні значення, які ми скопіювали з іншого місця
    double pi { 3.14159 };
    double gravity { 9.8 };
    double phi { 1.61803 };

    std::cout << pi << '\\n';
    std::cout << phi << '\\n';

    // У цій програмі ми не використовуємо гравітацію
    // Компілятор, скоріш за все, поскаржиться на те, що гравітація визначена, але не використовується

    return 0;
}
```
Якщо ми часто використовуємо ці значення, ми, ймовірно, зберегли їх десь і копіюємо/вставляємо/імпортуємо їх усі разом.

Однак у будь-якій програмі, де ми не використовуємо всі ці значення, компілятор, швидше за все, поскаржиться на кожну змінну, яка насправді не використовується. Хоча ми могли б пройтись і видалити/закоментувати невикористовувані змінні для кожної програми, це займе багато часу та енергії. І пізніше, якщо нам знадобиться змінна, яку ми раніше видалили, нам доведеться повернутися і додати її знову.

Для вирішення таких випадків у C++17 введено атрибут `[[maybe_unused]]`, який дозволяє нам повідомити компілятору, що ми не проти того, щоб змінна була невикористаною. Компілятор не буде видавати попередження про невикористовувані змінні для таких змінних.

Наступна програма не повинна видавати жодних попереджень/помилок:

```cpp
int main()
{
    [[maybe_unused]] double pi { 3.14159 };
    [[maybe_unused]] double gravity { 9.8 };
    [[maybe_unused]] double phi { 1.61803 };

    std::cout << pi << '\\n';
    std::cout << phi << '\\n';

    // Компілятор більше не буде попереджати про невикористання гравітації

    return 0;
}
```

Крім того, компілятор, швидше за все, оптимізує ці змінні поза програмою, тому вони не впливають на продуктивність.

Атрибут `[[maybe_unused]]` слід застосовувати лише вибірково до змінних, які мають конкретну та обґрунтовану причину для невикористання.