---
date: 2024-09-02
tags:
  - Процедурне_програмування
  - Основи
---
## Додавання файлів до проекту
Коли програми стають більшими, зазвичай їх розбивають на декілька файлів для організації або повторного використання. Однією з переваг роботи з IDE є те, що вони значно спрощують роботу з декількома файлами. Ви вже знаєте, як створювати і компілювати однофайлові проекти. Додавання нових файлів до існуючих проектів є дуже простим.
> [!success] 
> Коли ви додаєте нові файли коду до вашого проекту, надавайте їм розширення .cpp.
## Приклад з кількома файлами
Передбачувані оголошення та визначення, ми розглянули однофайлову програму, яка не компілюється:

```cpp
#include <iostream>

int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\\n';
    return 0;
}

int add(int x, int y)
{
    return x + y;
}
```

Коли компілятор доходить до виклику функції add у рядку 5 main, він не знає, що таке add, тому що ми не визначили add до рядка 9! Ми вирішили цю проблему або змінити порядок функцій (помістивши add першою), або використати пряме оголошення для add.

Тепер давайте подивимось на подібну багатофайлову програму:

add.cpp:

```cpp
int add(int x, int y)
{
    return x + y;
}
```

main.cpp:

```cpp
#include <iostream>

int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\\n'; // compile error
    return 0;
}
```

Ваш компілятор може скомпілювати спочатку add.cpp або main.cpp. У будь-якому випадку, main.cpp не буде скомпільовано, що призведе до тієї ж помилки компілятора, що й у попередньому прикладі:

```
main.cpp(5) : error C3861: 'add': identifier not found
```

Причина та сама: коли компілятор доходить до рядка 5 main.cpp, він не знає, що таке ідентифікатор add.

Пам'ятайте, що компілятор компілює кожен файл окремо. Він не знає про вміст інших файлів коду і не пам'ятає нічого з того, що бачив у раніше скомпільованих файлах коду. Тому навіть якщо компілятор бачив визначення функції add раніше (якщо він компілював add.cpp першим), він його не пам'ятає.

Така обмежена видимість і коротка пам'ять є навмисною з кількох причин:

1. Він дозволяє компілювати вихідні файли проекту у будь-якому порядку.
2. Коли ми змінюємо вихідний файл, перекомпілювати потрібно лише цей файл.
3. Це зменшує ймовірність конфліктів імен між ідентифікаторами у різних файлах.

У нас є ті самі варіанти вирішення проблеми, що й раніше: розмістити визначення функції add перед функцією main або задовольнити компілятор прямим оголошенням. У цьому випадку, оскільки функція add знаходиться в іншому файлі, варіант зі зміною порядку неможливий.

Рішенням тут є використання прямого оголошення:

main.cpp (з прямим оголошенням):

```cpp
#include <iostream>

int add(int x, int y); // needed so main.cpp knows that add() is a function defined elsewhere

int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\\n';
    return 0;
}
```

add.cpp (залишається без змін):

```cpp
int add(int x, int y)
{
    return x + y;
}
```

Тепер, коли компілятор компілює main.cpp, він знатиме, що таке ідентифікатор add і буде задоволений. Компонувальник з'єднає виклик функції add у main.cpp з визначенням функції add у add.cpp.

Використовуючи цей метод, ми можемо надавати файлам доступ до функцій, які знаходяться в іншому файлі.

Спробуйте самі скомпілювати add.cpp і main.cpp з оголошенням forward. Якщо ви отримаєте помилку компонувальника, переконайтеся, що ви правильно додали add.cpp до вашого проекту або рядка компіляції.

> [!NOTE]
> Оскільки компілятор компілює кожен файл коду окремо (а потім забуває, що він бачив), кожен файл коду, який використовує `std::cout` або `std::cin`, повинен `#include <iostream>`.
> 
> У наведеному вище прикладі, якби `add.cpp` використовував `std::cout` або `std::cin`, йому потрібно було б `#include <iostream>`.

> [!NOTE]
> Коли ідентифікатор використовується у виразі, він повинен бути пов'язаний з його визначенням.
> - Якщо компілятор не побачив у файлі, що компілюється, ані прямого оголошення, ані визначення ідентифікатора, він видасть помилку у місці використання ідентифікатора.
> - Інакше, якщо визначення існує у тому самому файлі, компілятор зв'яже використання ідентифікатора з його визначенням.
> - Інакше, якщо визначення існує в іншому файлі (і є видимим для компонувальника), компонувальник зв'яже використання ідентифікатора з його визначенням.
> - В іншому випадку компонувальник видасть помилку, яка вказує на те, що він не зміг знайти визначення для ідентифікатора.

## Щось пішло не так!
Є багато речей, які можуть піти не так при першій спробі роботи з декількома файлами. Якщо ви спробували наведений вище приклад і зіткнулися з помилкою, перевірте наступне:

1. Якщо ви отримуєте помилку компілятора про те, що add не визначено в main, ймовірно, ви забули пряме оголошення функції add у файлі main.cpp.
2. Якщо ви отримуєте помилку компонувальника про те, що add не визначено, наприклад

```
unresolved external symbol "int __cdecl add(int,int)" (?add@@YAHHH@Z) referenced in function _main
```

2a. ...найімовірнішою причиною є те, що add.cpp не додано до вашого проекту коректно. Під час компіляції ви повинні бачити у списку компілятора як main.cpp, так і add.cpp. Якщо ви бачите тільки main.cpp, то add.cpp точно не компілюється. Якщо ви використовуєте Visual Studio або Code::Blocks, ви повинні побачити add.cpp у списку в Solution Explorer/панелі проектів ліворуч або праворуч від IDE. Якщо цього не сталося, клацніть правою кнопкою миші на вашому проекті і додайте файл, а потім спробуйте скомпілювати ще раз. Якщо ви компілюєте з командного рядка, не забудьте включити у команду компіляції і main.cpp, і add.cpp.

2b. ...можливо, ви додали add.cpp не до того проекту.

2c. ...можливо, файл не налаштовано на компіляцію або компонування. Перевірте властивості файлу і переконайтеся, що він налаштований на компіляцію/компонування. У Code::Blocks компілювати та компонувати - це окремі прапорці, які слід позначити. У Visual Studio є опція "виключити зі збірки", яку слід встановити на "ні" або залишити порожньою.

1. Не #include "add.cpp" з main.cpp. Це призведе до того, що препроцесор вставить вміст add.cpp безпосередньо в main.cpp замість того, щоб розглядати їх як окремі файли.
## Підсумок
C++ розроблено так, що кожен вихідний файл може бути скомпільовано незалежно, без знання того, що міститься в інших файлах. Тому порядок, у якому файли фактично компілюються, не має значення.

Ми почнемо багато працювати з декількома файлами, коли перейдемо до об'єктно-орієнтованого програмування, тому зараз найкращий час, щоб переконатися, що ви розумієте, як додавати і компілювати проекти з декількома файлами.

Нагадування: Щоразу, коли ви створюєте новий файл коду (.cpp), вам потрібно додати його до вашого проекту, щоб він був скомпільований.