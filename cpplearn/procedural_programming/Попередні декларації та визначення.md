---
date: 2024-09-06
tags:
  - Процедурне_програмування
  - Основи
---
Погляньте на цей, на перший погляд, невинний приклад програми:

```cpp
#include <iostream>

int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n';
    return 0;
}

int add(int x, int y)
{
    return x + y;
}
```

Можна було б очікувати, що ця програма дасть результат:

```
Сума 3 і 4 дорівнює: 7
```

Але насправді він не компілюється взагалі! Visual Studio видає наступну помилку компіляції:

```
add.cpp(5) : error C3861: 'add': identifier not found
```

Причина, по якій ця програма не компілюється, полягає в тому, що компілятор компілює вміст файлів коду послідовно. Коли компілятор доходить до виклику функції add у рядку 5 основного файлу, він не знає, що таке add, тому що ми не визначили add до рядка 9! Це призводить до помилки, ідентифікатор не знайдено.

Старіші версії Visual Studio видадуть додаткову помилку:

```
add.cpp(9) : error C2365: 'add'; : redefinition; previous definition was 'formerly unknown identifier'
```

Це дещо вводить в оману, враховуючи, що add взагалі ніколи не було визначено. Незважаючи на це, корисно зазначити, що досить часто одна помилка призводить до появи багатьох дублюючих або пов'язаних з нею помилок або попереджень. Іноді буває важко визначити, чи є будь-яка помилка або попередження, що виходять за межі першої, наслідком першої помилки, чи це незалежна проблема, яку потрібно вирішувати окремо.

> [!tip] 
> При усуненні помилок компіляції або попереджень у ваших програмах, вирішіть першу з перелічених проблем, а потім компілюйте знову.

Щоб виправити цю проблему, нам потрібно звернути увагу на те, що компілятор не знає, що таке add. Існує два поширених способи вирішення цієї проблеми.
## Варіант 1: Переупорядкуйте визначення функцій
Одним із способів вирішення проблеми є зміна порядку визначення функцій так, щоб add була визначена перед main:

```cpp
#include <iostream>

int add(int x, int y)
{
    return x + y;
}

int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n';
    return 0;
}
```

Таким чином, до моменту виклику add компілятор вже знатиме, що таке add. Оскільки це дуже проста програма, цю зміну відносно легко зробити. Однак, у більшій програмі може бути нудно з'ясовувати, які функції викликають інші функції (і в якому порядку), щоб їх можна було оголошувати послідовно.

Крім того, такий варіант не завжди можливий. Скажімо, ми пишемо програму, яка містить дві функції A і B. Якщо функція A викликає функцію B, а функція B викликає функцію A, то не існує способу впорядкувати функції так, щоб компілятор був задоволений. Якщо ви визначите A першою, компілятор поскаржиться, що він не знає, що таке B. Якщо спочатку визначити B, компілятор поскаржиться, що він не знає, що таке A.
## Варіант 2: Використовуйте форвардну декларацію
Ми також можемо виправити це за допомогою форвардної декларації.

**Пряме оголошення** дозволяє нам повідомити компілятор про існування ідентифікатора до того, як він буде визначений.

У випадку з функціями це дозволяє нам повідомити компілятору про існування функції до того, як ми визначимо тіло функції. Таким чином, коли компілятор зустріне виклик функції, він зрозуміє, що ми робимо виклик функції, і зможе перевірити, чи правильно ми її викликаємо, навіть якщо він ще не знає, як і де визначено функцію.

Щоб написати пряме оголошення функції, ми використовуємо інструкцію **оголошення функції** (також звану прототипом функції). **Оголошення функції** складається з типу повернення, імені функції та типів параметрів, які закінчуються крапкою з комою. Імена параметрів можуть бути включені необов'язково. Тіло функції не включається в оголошення.

Нижче наведено оголошення функції add:

```cpp
int add(int x, int y); // function declaration includes return type, name, parameters, and semicolon.  No function body!
```

Ось наша оригінальна програма, яка не скомпілювалася, з використанням оголошення функції як прямого оголошення для функції add:

```cpp
#include <iostream>

int add(int x, int y); // forward declaration of add() (using a function declaration)

int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n'; // this works because we forward declared add() above
    return 0;
}

int add(int x, int y) // even though the body of add() isn't defined until here
{
    return x + y;
}
```

Тепер, коли компілятор дійде до виклику add в main, він знатиме, як виглядає add (функція, яка отримує два цілочисельні параметри і повертає ціле число), і не буде скаржитися.

Варто зазначити, що в оголошеннях функцій не потрібно вказувати імена параметрів (оскільки вони не вважаються частиною оголошення функції). У вищенаведеному коді ви також можете переслати оголошення функції таким чином:

```cpp
int add(int, int); // valid function declaration
```

Однак, ми вважаємо за краще називати наші параметри (використовуючи ті ж імена, що і в самій функції). Це дозволяє вам зрозуміти, якими є параметри функції, просто подивившись на оголошення. Наприклад, якщо ви побачите оголошення `void doSomething(int, int, int)`, ви можете подумати, що пам'ятаєте, що представляє кожен з параметрів, але ви також можете помилитися.

Крім того, багато автоматизованих засобів створення документації генерують документацію на основі вмісту заголовних файлів, у яких часто розміщують оголошення.

> [!tip] 
> Зберігайте імена параметрів в оголошеннях функцій.

> [!NOTE] 
> Ви можете легко створювати оголошення функцій, скопіювавши/вставивши заголовок функції і додавши крапку з комою.
## Навіщо пересилати декларації?
Вам може бути цікаво, навіщо нам використовувати форвардне оголошення, якщо ми можемо просто змінити порядок функцій, щоб змусити наші програми працювати.

Найчастіше перехресні оголошення використовуються для того, щоб повідомити компілятору про існування деякої функції, яка була визначена в іншому файлі коду. У цьому випадку перевпорядкування неможливе, тому що викликувач і отримувач знаходяться в абсолютно різних файлах!

Форвардні оголошення також можуть бути використані для визначення наших функцій з діагностикою порядку. Це дозволяє нам визначати функції у будь-якому порядку, який максимізує організацію (наприклад, шляхом об'єднання пов'язаних функцій разом) або зрозумілість для читача.

Рідше трапляються випадки, коли ми маємо дві функції, які викликають одна одну. У цьому випадку зміна порядку також неможлива, оскільки не існує способу переставити функції так, щоб кожна з них була перед іншою. Форвардні оголошення дають нам спосіб вирішити такі циклічні залежності.
## Забуваємо про функціональне тіло
Програмісти-початківці часто задаються питанням, що станеться, якщо вони передадуть оголошення функції, але не визначать її.

Відповідь така: це залежить від ситуації. Якщо оголошено пряме оголошення, але функція ніколи не викликається, програма буде скомпільована і працюватиме нормально. Однак, якщо пряме оголошення зроблено і функція викликається, але програма ніколи не визначає функцію, програма скомпілюється нормально, але компонувальник поскаржиться, що він не може вирішити виклик функції.

Розглянемо наступну програму:

```cpp
#include <iostream>

int add(int x, int y); // forward declaration of add()

int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n';
    return 0;
}

// note: No definition for function add
```

У цій програмі ми пересилаємо оголошення add і викликаємо add, але ніде не визначаємо add. Коли ми намагаємося скомпілювати цю програму, Visual Studio видає наступне повідомлення:

```
Compiling...
add.cpp
Linking...
add.obj : error LNK2001: unresolved external symbol "int __cdecl add(int,int)" (?add@@YAHHH@Z)
add.exe : fatal error LNK1120: 1 unresolved externals
```

Як бачите, програма скомпілювалася нормально, але на етапі компонування вона зазнала невдачі, оскільки int add(int, int) так і не було визначено.
## Інші види форвардних декларацій
Найчастіше прямі оголошення використовуються з функціями. Однак, прямі оголошення також можна використовувати з іншими ідентифікаторами у C++, такими як змінні та типи. Змінні та типи мають інший синтаксис прямого оголошення, тому ми розглянемо їх у наступних уроках.
## Декларації проти визначень
У мові C++ ви часто чуєте слова "оголошення" та "визначення", які часто використовуються як взаємозамінні. Що вони означають? Тепер у вас є достатньо фундаментальних знань, щоб зрозуміти різницю між ними.

**Оголошення** повідомляє компілятору про існування ідентифікатора та пов'язаної з ним інформації про тип. Ось декілька прикладів оголошень:

```cpp
int add(int x, int y); // tells the compiler about a function named "add" that takes two int parameters and returns an int.  No body!
int x;                 // tells the compiler about an integer variable named x
```

**Визначення** - це оголошення, яке фактично реалізує (для функцій і типів) або створює (для змінних) ідентифікатор.

Ось кілька прикладів визначень:

```cpp
// because this function has a body, it is an implementation of function add()
int add(int x, int y)
{
    int z{ x + y };   // instantiates variable z

    return z;
}

int x;                // instantiates variable x
```

У C++ всі визначення є деклараціями. Тому `int x;` є одночасно і визначенням, і декларацією.

І навпаки, не всі оголошення є визначеннями. Оголошення, які не є визначеннями, називаються чистими оголошеннями. Типи чистих оголошень включають прямі оголошення функцій, змінних та типів.

> [!NOTE] 
> У звичайній мові термін "декларація" зазвичай використовується для позначення "чистої декларації", а "визначення" - для позначення "визначення, яке також слугує декларацією". Таким чином, ми зазвичай називаємо int x; визначенням, хоча це і визначення, і декларація.

Коли компілятор зустрічає ідентифікатор, він перевіряє правильність використання цього ідентифікатора (наприклад, чи знаходиться ідентифікатор в області видимості, чи використовується він синтаксично правильно і т.д.).

У більшості випадків достатньо оголошення, щоб компілятор міг переконатися, що ідентифікатор використовується належним чином. Наприклад, коли компілятор зустрічає виклик функції add(5, 6), якщо він вже бачив оголошення `add(int, int)`, то він може перевірити, що `add` - це дійсно функція, яка приймає два параметри типу `int`. Компілятору не обов'язково бачити оголошення функції `add` (яке може існувати в іншому файлі).

Однак є кілька випадків, коли компілятор повинен бачити повне визначення, щоб використовувати ідентифікатор (наприклад, визначення шаблонів і типів, про які ми поговоримо у наступних уроках).

Ось підсумкова таблиця:

|Термін|Технічне значення|Приклади|
|---|---|---|
|Декларація|Повідомляє компілятору про ідентифікатор та пов'язану з ним інформацію про тип.|void foo(); // function forward declaration (no body)|
|void goo() {}; // function definition (has body)|||
|int x; // variable definition|||
|Визначення|Реалізує функцію або створює змінну.||
|Визначення - це теж декларації.|void foo() { } // function definition (has body)||
|int x; // variable definition|||
|Чиста декларація|Декларація, яка не є визначенням.|void foo(); // function forward declaration (no body)|
|Ініціалізація|Надає початкове значення для визначеного об'єкта.|int x { 2 }; // x is initialized to value 2|
Термін "декларація" зазвичай використовується для позначення "чистої декларації", а термін "дефініція" - для всього, що є одночасно і дефініцією, і декларацією. Ми використовуємо цю загальну номенклатуру в коментарях до прикладу стовпчика.
## Правило одного визначення (ОВС)
Правило одного визначення (або скорочено ОДР) є добре відомим правилом у мові C++. ОВВ складається з трьох частин:
1. У файлі кожна функція, змінна, тип або шаблон у певній області видимості може мати лише одне визначення. Визначення, що зустрічаються в різних областях видимості (наприклад, локальні змінні, визначені в різних функціях, або функції, визначені в різних просторах імен), не порушують цього правила.
2. У програмі кожна функція або змінна у заданій області видимості може мати лише одне визначення. Це правило існує тому, що програми можуть мати більше одного файлу (ми розглянемо це у наступному уроці).
3. Типи, шаблони, вбудовані функції та вбудовані змінні можуть мати подвійні визначення у різних файлах, якщо кожне визначення є ідентичним. Ми ще не розглянули більшість з цих речей, тому поки що не хвилюйтеся про це - ми повернемося до цього питання, коли воно стане актуальним.

Порушення частини 1 ODR призведе до того, що компілятор видасть помилку перевизначення. Порушення частини 2 ODR призведе до того, що компонувальник видасть помилку перевизначення. Порушення частини 3 ODR призведе до невизначеної поведінки.

Ось приклад порушення частини 1:

```cpp
int add(int x, int y)
{
     return x + y;
}

int add(int x, int y) // violation of ODR, we've already defined function add(int, int)
{
     return x + y;
}

int main()
{
    int x{};
    int x{ 5 }; // violation of ODR, we've already defined x
}
```

У даному прикладі функція `add(int, int)` оголошена двічі (у глобальній області видимості), а локальна змінна `int x` оголошена двічі (в області видимості методу `main()`). Компілятор Visual Studio видасть наступні помилки компіляції:

```
project3.cpp(9): error C2084: function 'int add(int,int)' already has a body
project3.cpp(3): note: see previous definition of 'add'
project3.cpp(16): error C2086: 'int x': redefinition
project3.cpp(15): note: see declaration of 'x'
```

Однак, не є порушенням частини 1 ODR те, що `main()` має локальну змінну, визначену як `int x`, а `add()` також має параметр функції, визначений як `int x`. Ці визначення зустрічаються в різних областях видимості (в області видимості кожної відповідної функції), тому вони вважаються окремими визначеннями для двох різних об'єктів, а не визначенням і перевизначенням одного і того ж об'єкту.