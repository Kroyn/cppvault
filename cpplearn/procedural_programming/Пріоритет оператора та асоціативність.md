---
date: 2024-09-29
tags:
  - Процедурне_програмування
  - Оператори
---
**Операція** - це математичний процес, що включає нуль або більше вхідних значень (так званих **операндів**), який створює нове значення (так зване вихідне значення). Конкретна операція, що виконується, позначається конструкцією (зазвичай символом або парою символів), яка називається **оператором**.

Наприклад, ще в дитинстві ми всі знаємо, що `2 + 3` дорівнює `5`. У цьому випадку літерали `2` і `3` є операндами, а символ `+` є оператором, який вказує нам застосувати математичне додавання до операндів, щоб отримати нове значення `5`. Оскільки тут використовується лише один оператор, це дуже просто.

У цій главі ми обговоримо теми, пов'язані з операторами, і розглянемо багато поширених операторів, які підтримує C++.
## Обчислення складених виразів
Тепер давайте розглянемо складений вираз, наприклад, `4 + 2 * 3`. Чи слід його згрупувати як `(4 + 2) * 3`, що дає `18`, або як `4 + (2 * 3)`, що дає `10`? Використовуючи звичайні математичні правила пріоритету (які стверджують, що множення вирішується перед додаванням), ми знаємо, що наведений вище вираз слід згрупувати як `4 + (2 * 3)`, щоб отримати значення `10`. Але як про це дізнається компілятор?

Щоб обчислити вираз, компілятор повинен зробити дві речі:
- Під час компіляції компілятор повинен розібрати вираз і визначити, як операнди згруповані з операторами. Це робиться за допомогою правил пріоритету та асоціативності, про які ми поговоримо далі.
- Під час компіляції або виконання, операнди обчислюються і виконуються операції для отримання результату.
## Пріоритет оператора
Щоб полегшити розбір складеного виразу, всім операторам присвоюється рівень пріоритету. Оператори з вищим рівнем пріоритету групуються з операндами першими.

У таблиці нижче видно, що множення і ділення (рівень пріоритету 5) мають вищий рівень пріоритету, ніж додавання і віднімання (рівень пріоритету 6). Таким чином, множення і ділення будуть згруповані з операндами перед додаванням і відніманням. Іншими словами, `4 + 2 * 3` буде згруповано як `4 + (2 * 3)`.
## Асоціативність операторів
Розглянемо складений вираз типу `7 - 4 - 1`. Чи слід його групувати як `(7 - 4) - 1`, що дає значення `2`, чи як `7 - (4 - 1)`, що дає значення `4`? Оскільки обидва оператори віднімання мають однаковий рівень пріоритету, компілятор не може використовувати тільки пріоритет для визначення того, як його згрупувати.

Якщо два оператори з однаковим рівнем пріоритету стоять поруч у виразі, асоціативність оператора вказує компілятору, як обчислювати оператори - зліва направо чи справа наліво. Віднімання має рівень пріоритету 6, а оператори на рівні пріоритету 6 мають асоціативність зліва направо. Тому цей вираз групується зліва направо:` (7 - 4) - 1`.
## Таблиця пріоритету операторів та асоціативності
Наведена нижче таблиця в першу чергу призначена для довідкової таблиці, до якої ви можете звернутися в майбутньому, щоб вирішити будь-які питання щодо пріоритетності або асоціативності, які у вас виникнуть.

Нотатки:
- Рівень пріоритету 1 є найвищим, а рівень 17 - найнижчим. Оператори з вищим рівнем пріоритету групують операнди першими.
- L->R означає асоціативність зліва направо.
- R->L означає асоціативність справа наліво.

|Prec/Ass|Operator|Description|Pattern|
|---|---|---|---|
|1 L->R|::  <br>::|Global scope (unary)  <br>Namespace scope (binary)|::name  <br>class_name::member_name|
|2 L->R|()  <br>()  <br>type()  <br>type{}  <br>[]  <br>.  <br>->  <br>++  <br>––  <br>typeid  <br>const_cast  <br>dynamic_cast  <br>reinterpret_cast  <br>static_cast  <br>sizeof…  <br>noexcept  <br>alignof|Parentheses  <br>Function call  <br>Functional cast  <br>List init temporary object (C++11)  <br>Array subscript  <br>Member access from object  <br>Member access from object ptr  <br>Post-increment  <br>Post-decrement  <br>Run-time type information  <br>Cast away const  <br>Run-time type-checked cast  <br>Cast one type to another  <br>Compile-time type-checked cast  <br>Get parameter pack size  <br>Compile-time exception check  <br>Get type alignment|(expression)  <br>function_name(arguments)  <br>type(expression)  <br>type{expression}  <br>pointer[expression]  <br>object.member_name  <br>object_pointer->member_name  <br>lvalue++  <br>lvalue––  <br>typeid(type) or typeid(expression)  <br>const_cast<type>(expression)  <br>dynamic_cast<type>(expression)  <br>reinterpret_cast<type>(expression)  <br>static_cast<type>(expression)  <br>sizeof…(expression)  <br>noexcept(expression)  <br>alignof(type)|
|3 R->L|+  <br>-  <br>++  <br>––  <br>!  <br>not  <br>~  <br>(type)  <br>sizeof  <br>co_await  <br>&  <br>*  <br>new  <br>new[]  <br>delete  <br>delete[]|Unary plus  <br>Unary minus  <br>Pre-increment  <br>Pre-decrement  <br>Logical NOT  <br>Logical NOT  <br>Bitwise NOT  <br>C-style cast  <br>Size in bytes  <br>Await asynchronous call  <br>Address of  <br>Dereference  <br>Dynamic memory allocation  <br>Dynamic array allocation  <br>Dynamic memory deletion  <br>Dynamic array deletion|+expression  <br>-expression  <br>++lvalue  <br>––lvalue  <br>!expression  <br>not expression  <br>~expression  <br>(new_type)expression  <br>sizeof(type) or sizeof(expression)  <br>co_await expression (C++20)  <br>&lvalue  <br>*expression  <br>new type  <br>new type[expression]  <br>delete pointer  <br>delete[] pointer|
|4 L->R|->*  <br>.*|Member pointer selector  <br>Member object selector|object_pointer->*pointer_to_member  <br>object.*pointer_to_member|
|5 L->R|*  <br>/  <br>%|Multiplication  <br>Division  <br>Remainder|expression * expression  <br>expression / expression  <br>expression % expression|
|6 L->R|+  <br>-|Addition  <br>Subtraction|expression + expression  <br>expression - expression|
|7 L->R|<<  <br>>>|Bitwise shift left / Insertion  <br>Bitwise shift right / Extraction|expression << expression  <br>expression >> expression|
|8 L->R|<=>|Three-way comparison (C++20)|expression <=> expression|
|9 L->R|<  <br><=  <br>>  <br>>=|Comparison less than  <br>Comparison less than or equals  <br>Comparison greater than  <br>Comparison greater than or equals|expression < expression  <br>expression <= expression  <br>expression > expression  <br>expression >= expression|
|10 L->R|==  <br>!=|Equality  <br>Inequality|expression == expression  <br>expression != expression|
|11 L->R|&|Bitwise AND|expression & expression|
|12 L->R|^|Bitwise XOR|expression ^ expression|
|13 L->R|\||Bitwise OR|expression \| expression|
|14 L->R|&&  <br>and|Logical AND  <br>Logical AND|expression && expression  <br>expression and expression|
|15 L->R|\|  <br>or|Logical OR  <br>Logical OR|expression \| expression  <br>expression or expression|
|16 R->L|throw  <br>co_yield  <br>?:  <br>=  <br>*=  <br>/=  <br>%=  <br>+=  <br>-=  <br><<=  <br>>>=  <br>&=  <br>\|=  <br>^=|Throw expression  <br>Yield expression (C++20)  <br>Conditional  <br>Assignment  <br>Multiplication assignment  <br>Division assignment  <br>Remainder assignment  <br>Addition assignment  <br>Subtraction assignment  <br>Bitwise shift left assignment  <br>Bitwise shift right assignment  <br>Bitwise AND assignment  <br>Bitwise OR assignment  <br>Bitwise XOR assignment|throw expression  <br>co_yield expression  <br>expression ? expression : expression  <br>lvalue = expression  <br>lvalue *= expression  <br>lvalue /= expression  <br>lvalue %= expression  <br>lvalue += expression  <br>lvalue -= expression  <br>lvalue <<= expression  <br>lvalue >>= expression  <br>lvalue &= expression  <br>lvalue \|= expression  <br>lvalue ^= expression|
|17 L->R|,|Comma operator|expression, expression|
Деякі з цих операторів, такі як `+`, `-`, `*`, `/`, `()` та `sizeof`, ви вже маєте знати. Однак, якщо у вас немає досвіду роботи з іншою мовою програмування, більшість операторів у цій таблиці, ймовірно, будуть для вас незрозумілими. Це очікувано на даному етапі. Ми розглянемо багато з них у цій главі, а решту будемо вводити в міру необхідності.
> [!NOTE]
> У C++ немає оператора для піднесення до степеня (оператор`^` має іншу функцію у C++). 

Зауважте, що оператор`<<` виконує як побітний зсув вліво, так і вставку, а оператор`>>` - як побітний зсув вправо, так і вилучення. Компілятор може визначити, яку операцію слід виконати, виходячи з типів операндів.
## Взяття в круглі дужки
Згідно з правилами старшинства, `4 + 2 * 3` буде згруповано як `4 + (2 * 3)`. Але що, якщо ми насправді маємо на увазі `(4 + 2) * 3`? Як і у звичайній математиці, у C++ ми можемо явно використовувати круглі дужки, щоб задати групування операндів за власним бажанням. Це працює тому, що дужки мають один з найвищих рівнів пріоритету, тому дужки зазвичай обчислюються перед тим, що знаходиться всередині них.
## Використовуйте круглі дужки, щоб полегшити розуміння складних виразів
Тепер розглянемо вираз типу` x && y || z`. Чи буде він обчислюватися як `(x && y) || z` або `x && (y || z)`? Ви можете подивитися в таблицю і побачити, що `&&` має пріоритет над `||`. Але існує так багато операторів і рівнів пріоритету, що важко запам'ятати їх усі. І ви не хочете постійно шукати оператори, щоб зрозуміти, як обчислюється складений вираз.

Щоб зменшити кількість помилок і полегшити розуміння коду без звернення до таблиці прецедентів, варто брати нетривіальні складені вирази у круглі дужки, щоб було зрозуміло, що ви маєте на увазі.
> [!tip]
> Використовуйте круглі дужки, щоб пояснити, як має обчислюватися нетривіальний складений вираз (навіть якщо вони технічно непотрібні).
## Обчислення вартості (операцій)
Стандарт C++ використовує термін "**обчислення значення**" для позначення виконання операторів у виразі для отримання значення. Порядок, у якому відбувається обчислення значень, визначають правила пріоритету та асоціації.

Наприклад, якщо задано вираз `4 + 2 * 3`, то за правилами пріоритету він групується як `4 + (2 * 3)`. Обчислення значення для `(2 * 3)` має відбутися першим, щоб можна було завершити обчислення значення для `4 + 6`.
## Порядок обчислення (операндів)
Стандарт C++ здебільшого використовує термін обчислення для позначення обчислення операндів (не обчислення операторів або виразів!). Наприклад, якщо задано вираз `a + b`, `a` буде обчислено для отримання деякого значення, `а` `b` буде обчислено для отримання деякого значення. Ці значення можна використовувати як операнди в операторі`+` для обчислення значень.
> [!NOTE]
> Неформально ми зазвичай використовуємо термін "обчислює" для позначення обчислення цілого виразу (обчислення значення), а не тільки операндів виразу.
## Порядок обчислення операндів та аргументів функції здебільшого не визначений
У більшості випадків порядок обчислення операндів та аргументів функції не визначений, тобто вони можуть обчислюватися у довільному порядку.

Розглянемо наступний вираз:
```cpp
a * b + c * d
```
З наведених вище правил пріоритету та асоціативності ми знаємо, що цей вираз буде згруповано так, як якщо б ми його набрали:
```cpp
(a * b) + (c * d)
```
Якщо a дорівнює `1`, `b` дорівнює `2`, `c` дорівнює `3`, а `d` дорівнює `4`, цей вираз завжди обчислює значення `14`.

Однак, правила пріоритету та асоціативності говорять нам лише про те, як групуються оператори та операнди і в якому порядку відбуватиметься обчислення значень. Вони не визначають порядок обчислення операндів або підвиразів. Компілятор може обчислювати операнди `a`, `b`, `c` або `d` у довільному порядку. Компілятор також може спочатку обчислити `a * b` або `c * d`.

Для більшості виразів це не має значення. У нашому прикладі виразу вище не має значення, в якому порядку обчислюються значення змінних `a`,` b`, `c` або `d`: обчислене значення завжди буде дорівнювати `14`. Тут немає ніякої двозначності.

Але можна писати вирази, де порядок обчислень має значення. Розглянемо програму, яка містить помилку, якої часто припускаються програмісти-початківці на C++:
```cpp
#include <iostream>

int getValue()
{
    std::cout << "Enter an integer: ";

    int x{};
    std::cin >> x;
    return x;
}

void printCalculation(int x, int y, int z)
{
    std::cout << x + (y * z);
}

int main()
{
    printCalculation(getValue(), getValue(), getValue()); // this line is ambiguous

    return 0;
}
```
Якщо ви запустите цю програму і введете вхідні дані `1`, `2` і `3`, ви можете припустити, що вона обчислить `1 + (2 * 3)` і виведе `7`. Але це припущення ґрунтується на тому, що аргументи функції `printCalculation()` обчислюються у порядку зліва направо (тобто параметр x отримує значення `1`, y отримує значення `2`, а `z` отримує значення `3`). Якщо ж аргументи обчислюються справа наліво (тобто параметр `z` отримує значення `1`, y отримує значення `2`, а `x` отримує значення `3`), то програма виведе `5`.
> [!tip]
> Компілятор Clang обчислює аргументи у порядку зліва направо. Компілятор GCC обчислює аргументи у порядку справа наліво.
> 
> Якщо ви хочете побачити цю поведінку на власні очі, ви можете зробити це у [Wandbox](https://wandbox.org/#). Вставте наведену вище програму, введіть `1 2 3` на вкладці Stdin, виберіть GCC або Clang, а потім скомпілюйте програму. Результат буде показано внизу сторінки (можливо, вам доведеться прокрутити сторінку вниз, щоб побачити його). Зверніть увагу, що результати для GCC і Clang відрізняються!

Вищенаведену програму можна зробити однозначною, зробивши кожен виклик функції `getValue()` окремим оператором:
```cpp
#include <iostream>

int getValue()
{
    std::cout << "Enter an integer: ";

    int x{};
    std::cin >> x;
    return x;
}

void printCalculation(int x, int y, int z)
{
    std::cout << x + (y * z);
}

int main()
{
    int a{ getValue() }; // will execute first
    int b{ getValue() }; // will execute second
    int c{ getValue() }; // will execute third

    printCalculation(a, b, c); // this line is now unambiguous

    return 0;
}
```
У цій версії a завжди матиме значення `1`, `b` матиме значення `2`, а c матиме значення `3`. При обчисленні аргументів функції `printCalculation()` не має значення, в якому порядку відбувається обчислення аргументів - параметр x завжди отримає значення `1`, y отримає значення `2`, а `z` отримає значення `3`. Ця версія детерміновано виведе `7`.
> [!NOTE]
> Операнди, аргументи функцій і під-вирази можна обчислювати в будь-якому порядку.
> 
> Поширеною помилкою є думка, що пріоритет і асоціативність операторів впливають на порядок обчислення. Перевага та асоціативність використовуються лише для визначення того, як операнди групуються з операторами, а також порядку обчислення значень.

> [!caution]
> Переконайтеся, що вирази (або виклики функцій), які ви пишете, не залежать від порядку обчислення операндів (або аргументів).

> [!NOTE]
> Оператори з побічними ефектами також можуть спричинити неочікувані результати оцінки.