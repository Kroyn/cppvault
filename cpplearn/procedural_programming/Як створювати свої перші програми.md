---
date: 2024-09-06
tags:
  - Процедурне_програмування
  - Основи
---
Тепер, коли ви дізналися деякі основи про програми, давайте розглянемо більш детально, як створювати програми.

Коли ви сідаєте за написання програми, зазвичай у вас є якась ідея, для якої ви хочете написати програму. Програмістам-початківцям часто важко зрозуміти, як перетворити цю ідею на реальний код. Але виявляється, що у вас вже є багато навичок вирішення проблем, які вам потрібні, набуті з повсякденного життя.

Найважливіше, про що слід пам'ятати (і що найважче зробити) - це спроектувати свою програму до того, як ви почнете кодувати. Багато в чому програмування схоже на архітектуру. Що станеться, якщо ви спробуєте побудувати будинок, не дотримуючись архітектурного плану? Швидше за все, якщо ви не дуже талановитий, у вас вийшов би будинок з великою кількістю проблем: нерівні стіни, дах, що протікає, і т.д. Так само, якщо ви спробуєте програмувати до того, як у вас буде хороший план, ви, швидше за все, виявите, що ваш код має багато проблем, і вам доведеться витратити багато часу на виправлення проблем, яких можна було б уникнути, якщо б ви трохи подумали про це наперед.

Невелике попереднє планування заощадить вам час і позбавить від розчарувань у довгостроковій перспективі.

У цьому уроці ми розглянемо узагальнений підхід до перетворення ідей на прості функціональні програми.
## Крок 1: Визначте свою мету
Для того, щоб написати успішну програму, спочатку потрібно визначити, яку мету ви перед собою ставите. В ідеалі, ви повинні бути в змозі сформулювати її в одному-двох реченнях. Часто корисно виразити її у вигляді результату, зрозумілого користувачеві. Наприклад:
- Дозволити користувачеві організувати список імен і пов'язаних з ними телефонних номерів.
- Згенерувати рандомізовані підземелля, які створять цікаві на вигляд печери.
- Згенеруйте список рекомендацій щодо акцій, які мають високі дивіденди.
- Змоделюйте, скільки часу потрібно, щоб м'яч, скинутий з вежі, впав на землю.

Хоча цей крок здається очевидним, він також дуже важливий. Найгірше, що ви можете зробити, це написати програму, яка насправді не робить того, що ви (або ваш бос) хотіли!
## Крок 2: Визначення вимог
Хоча визначення проблеми допомагає вам визначити, якого результату ви хочете досягти, воно все ще залишається розпливчастим. Наступний крок - обміркувати вимоги.

**Вимоги** - це вигадливе слово, що означає як обмеження, яких має дотримуватися ваше рішення (наприклад, бюджет, часові рамки, простір, пам'ять тощо...), так і можливості, які програма повинна демонструвати, щоб задовольнити потреби користувачів. Зауважте, що ваші вимоги також повинні бути зосереджені на "що", а не на "як".

Наприклад:
- Номери телефонів повинні зберігатися, щоб їх можна було викликати пізніше.
- Рандомізоване підземелля завжди повинно містити спосіб дістатися від входу до виходу.
- Рекомендації щодо акцій повинні використовувати історичні дані про ціни.
- Користувач повинен мати можливість ввести висоту вежі.
- Нам потрібна тестова версія протягом 7 днів.
- Програма повинна видавати результати протягом 10 секунд після того, як користувач надішле свій запит.
- Програма повинна аварійно завершувати роботу менш ніж в 0,1% сеансів користувача.

До однієї задачі може бути висунуто багато вимог, і рішення не є "готовим", доки воно не задовольнить їх усі.
## Крок 3: Визначте інструменти, цілі та план резервного копіювання

Коли ви досвідчений програміст, є багато інших кроків, які зазвичай відбуваються на цьому етапі, в тому числі:
- Визначення цільової архітектури та/або ОС, на якій буде працювати ваша програма.
- Визначення набору інструментів, які ви будете використовувати.
- Визначення того, чи будете ви писати програму самостійно, чи в команді.
- Визначити стратегію тестування/відгуків/випуску.
- Визначте, як ви будете створювати резервні копії вашого коду.

Однак для програміста-початківця відповіді на ці питання, як правило, прості: Ви пишете програму для власного використання, самостійно, на власній системі, використовуючи IDE, яку ви завантажили, і ваш код, ймовірно, не буде використовуватися ніким, крім вас. Це спрощує завдання.

Тим не менш, якщо ви збираєтеся працювати над чимось нетривіально складним, ви повинні мати план резервного копіювання вашого коду. Недостатньо просто заархівувати або скопіювати каталог в інше місце на вашому комп'ютері (хоча це краще, ніж нічого). Якщо ваша система вийде з ладу, ви втратите все. Хороша стратегія резервного копіювання передбачає повне видалення копії коду з вашої системи. Існує багато простих способів зробити це: Заархівуйте його і надішліть собі електронною поштою, завантажте на хмарне сховище (наприклад, Dropbox), скористайтеся протоколом передачі файлів (наприклад, SFTP), щоб завантажити його на інший комп'ютер, скопіюйте його на інший комп'ютер у вашій локальній мережі або скористайтеся системою контролю версій, розташованою на іншому комп'ютері або в хмарі (наприклад, github). Системи контролю версій мають додаткову перевагу - вони дозволяють не лише відновлювати файли, але й відкочувати їх до попередньої версії.
## Крок 4: Розбийте складні проблеми на прості

У реальному житті нам часто доводиться виконувати дуже складні завдання. Спроба з'ясувати, як виконати ці завдання, може бути дуже складною. У таких випадках ми часто використовуємо метод розв'язання проблем за принципом "зверху вниз". Тобто замість того, щоб вирішувати одну складну задачу, ми розбиваємо її на кілька підзадач, кожну з яких окремо вирішити легше. Якщо ці підзадачі все ще занадто складні для вирішення, їх можна розбити ще більше. Безперервно розбиваючи складні завдання на простіші, ви можете врешті-решт дійти до того, що кожне окреме завдання стане керованим, якщо не тривіальним.

Давайте розглянемо приклад. Припустимо, ми хочемо прибрати в будинку. Наразі наша ієрархія завдань виглядає так:

- Прибирання в будинку

Прибирання всього будинку - досить велике завдання, щоб виконати його за один раз, тому давайте розділимо його на підзадачі:

- Clean the house
	- Пилососьте килими
    - Прибирати у ванних кімнатах
    - Прибирати на кухні

Це більш керовано, оскільки тепер у нас є підзадачі, на яких ми можемо зосередитися окремо. Однак деякі з них ми можемо розбити ще більше:

- Прибирання в будинку
    - Пилососити килими
    - Приберіть у ванних кімнатах
        - Почистити унітаз (фу!)
        - Вимити раковину
- Прибрати на кухні
    - Очистити стільниці
    - Почистити стільниці
    - Почистіть раковину
    - Винести сміття

Тепер у нас є ієрархія завдань, жодне з яких не є особливо складним. Виконавши кожен з цих відносно керованих підпунктів, ми зможемо виконати більш складне загальне завдання - прибрати будинок.

Інший спосіб створити ієрархію завдань - це зробити це знизу вгору. У цьому методі ми почнемо зі списку легких завдань і побудуємо ієрархію, групуючи їх.

Наприклад, багатьом людям доводиться ходити на роботу або навчання в будні дні, тому припустимо, що ми хочемо вирішити проблему "ходити на роботу". Якби вас запитали, які завдання ви виконуєте вранці, щоб дістатися з ліжка на роботу, ви могли б скласти наступний список:

- Обираємо одяг
- Одягаємось
- Снідаємо
- Їдеш на роботу
- Чистити зуби
- Встати з ліжка
- Готуємо сніданок
- Сідаємо на велосипед
- Прийняти душ

Використовуючи висхідний метод, ми можемо організувати їх в ієрархію елементів, шукаючи способи згрупувати елементи за схожими ознаками:

- З ліжка на роботу
    - Речі для спальні
        - Вимкнути будильник
        - Вставай з ліжка
        - Обирай одяг
    - Речі для ванної кімнати
        - Прийми душ.
        - Одягайся.
        - Почистити зуби
    - Сніданок
        - Приготуйте каву або чай
        - Їжте каші
    - Транспортні речі
        - Сідайте на велосипед
        - Поїздки на роботу

Як виявляється, ці ієрархії завдань є надзвичайно корисними у програмуванні, тому що коли у вас є ієрархія завдань, ви, по суті, визначаєте структуру вашої програми в цілому. Завдання верхнього рівня (в даному випадку "Прибрати в будинку" або "Піти на роботу") стає main() (тому що це головна проблема, яку ви намагаєтесь вирішити). Підпункти стають функціями у програмі.

Якщо виявиться, що один з пунктів (функцій) занадто складний для реалізації, просто розбийте його на кілька підпунктів/підфункцій. Зрештою, ви повинні досягти точки, коли кожна функція у вашій програмі буде тривіальною для реалізації.

## Крок 5: Визначте послідовність подій

Тепер, коли ваша програма має структуру, настав час визначити, як пов'язати всі завдання між собою. Перший крок - визначити послідовність подій, які будуть виконуватися. Наприклад, коли ви прокидаєтеся вранці, в якому порядку ви виконуєте перераховані вище завдання? Це може виглядати так:

- Речі для спальні
- Речі для ванної кімнати
- Речі для сніданку
- Транспортні речі

Якби ми писали калькулятор, ми могли б робити речі в такому порядку:

- Отримати перше число від користувача
- Отримати математичну операцію від користувача
- Отримати друге число від користувача
- Обчислити результат
- Вивести результат

На даний момент ми готові до впровадження.
## Крок 1: Окресліть свою основну функцію

Тепер ми готові розпочати реалізацію. Наведені вище послідовності можуть бути використані для того, щоб окреслити вашу основну програму. Поки що не хвилюйтеся про входи та виходи.

```cpp
int main()
{
//    doBedroomThings();
//    doBathroomThings();
//    doBreakfastThings();
//    doTransportationThings();

    return 0;
}
```

Або у випадку з калькулятором:

```cpp
int main()
{
    // Get first number from user
//    getUserInput();

    // Get mathematical operation from user
//    getMathematicalOperation();

    // Get second number from user
//    getUserInput();

    // Calculate result
//    calculateResult();

    // Print result
//    printResult();

    return 0;
}
```

Зауважте, що якщо ви збираєтеся використовувати цей метод для побудови ваших програм, ваші функції не компілюватимуться, оскільки їхніх визначень ще не існує. Одним із способів вирішення цієї проблеми є коментування викликів функцій, доки ви не будете готові реалізувати визначення функцій (і саме цей спосіб ми покажемо тут). Крім того, ви можете замінити функції (створити функції-заповнювачі з порожніми тілами), щоб ваша програма компілювалася.
## Крок 2: Реалізуйте кожну функцію

На цьому кроці для кожної функції ви виконаєте три дії:
1. Визначте прототип функції (входи та виходи)
2. Напишіть функцію
3. Протестуйте функцію

Якщо ваші функції досить деталізовані, кожна функція повинна бути досить простою і зрозумілою. Якщо певна функція все ще здається надто складною для реалізації, можливо, її потрібно розбити на підфункції, які легше реалізувати (або, можливо, ви зробили щось у неправильному порядку, і вам потрібно переглянути послідовність подій).

Давайте розглянемо першу функцію з прикладу з калькулятором:

```cpp
#include <iostream>

// Full implementation of the getUserInput function
int getUserInput()
{
    std::cout << "Enter an integer: ";
    int input{};
    std::cin >> input;

    return input;
}

int main()
{
    // Get first number from user
    int value{ getUserInput() }; // Note we've included code here to test the return value!
    std::cout << value << '\n'; // debug code to ensure getUserInput() is working, we'll remove this later

    // Get mathematical operation from user
//    getMathematicalOperation();

    // Get second number from user
//    getUserInput();

    // Calculate result
//    calculateResult();

    // Print result
//    printResult();

    return 0;
}
```

По-перше, ми визначили, що функція getUserInput не приймає аргументів і повертає користувачеві значення int. Це відображено у прототипі функції, яка повертає значення int і не має параметрів. Далі ми написали тіло функції, яке складається з 4 простих операторів. Нарешті, ми реалізували деякий тимчасовий код у функції main, щоб перевірити, що функція getUserInput (включаючи її значення, що повертається) працює коректно.

Ми можемо запустити цю програму багато разів з різними вхідними значеннями і переконатися, що програма поводиться так, як ми очікуємо на даний момент. Якщо ми виявимо, що щось не працює, ми знатимемо, що проблема в коді, який ми щойно написали.

Після того, як ми переконалися, що програма працює так, як було задумано, ми можемо видалити тимчасовий тестовий код і перейти до реалізації наступної функції (функція getMathematicalOperation). На цьому уроці ми не завершимо програму, оскільки спочатку нам потрібно розглянути деякі додаткові теми.

Запам'ятайте: Не реалізовуйте всю програму за один раз. Працюйте над нею поетапно, тестуючи кожен крок, перш ніж продовжувати.
## Крок 3: Фінальне тестування
Після того, як ваша програма "закінчена", останній крок - протестувати всю програму і переконатися, що вона працює належним чином. Якщо вона не працює, виправте її.

## Поради щодо написання програм
**Нехай ваші програми будуть простими для запуску.** Часто програмісти-початківці мають грандіозне бачення того, що вони хочуть, щоб їхня програма робила. "Я хочу написати рольову гру з графікою і звуком, з випадковими монстрами і підземеллями, з містом, яке можна відвідати, щоб продати речі, які ви знайдете в підземеллі". Якщо ви спробуєте написати щось надто складне для початку, ви будете пригнічені і розчаровані відсутністю прогресу. Натомість, зробіть свою першу мету якомога простішою, такою, що точно знаходиться в межах вашої досяжності. Наприклад, "Я хочу вміти відображати двовимірне поле на екрані".

**Додавайте функції з часом.** Після того, як ваша проста програма запрацює і буде добре працювати, ви можете додавати до неї нові функції. Наприклад, як тільки ви зможете відображати поле, додайте персонажа, який може ходити по ньому. Після того, як ви зможете ходити, додайте стіни, які можуть перешкоджати вашому просуванню. Коли у вас є стіни, побудуйте з них просте місто. Коли у вас буде місто, додайте торговців. Додаючи кожну функцію поступово, ваша програма буде поступово ускладнюватися, не перевантажуючи вас в процесі.

**Зосередьтеся на одній ділянці за раз.** Не намагайтеся кодувати все одразу і не розпорошуйте свою увагу на декілька завдань. Зосередьтеся на одному завданні за раз. Набагато краще мати одне працююче завдання і п'ять ще не розпочатих, ніж шість частково працюючих завдань. Якщо ви розпорошуєте свою увагу, ви з більшою ймовірністю зробите помилки і забудете важливі деталі.

**Тестуйте кожен фрагмент коду на ходу.** Програмісти-початківці часто пишуть всю програму за один прохід. Потім, коли вони компілюють її вперше, компілятор повідомляє про сотні помилок. Це може не тільки лякати, якщо ваш код не працює, може бути важко з'ясувати, чому. Замість цього, напишіть шматок коду, а потім негайно скомпілюйте і протестуйте його. Якщо він не працює, ви точно знатимете, в чому проблема, і її буде легко виправити. Коли ви переконаєтесь, що код працює, переходьте до наступного фрагменту і повторюйте. Написання коду може зайняти більше часу, але коли ви закінчите, все повинно працювати, і вам не доведеться витрачати вдвічі більше часу, намагаючись з'ясувати, чому воно не працює.

**Не інвестуйте у вдосконалення раннього коду.** Перший проект функції (або програми) рідко буває хорошим. Крім того, програми мають тенденцію розвиватися з часом, коли ви додаєте нові можливості та знаходите кращі способи структурувати речі. Якщо ви занадто рано інвестуєте у відшліфовування коду (додавання великої кількості документації, повна відповідність найкращим практикам, оптимізація), ви ризикуєте втратити всі ці інвестиції, коли виникне потреба у зміні коду. Замість цього, зробіть так, щоб ваші функції працювали на мінімальному рівні, а потім рухайтеся далі. Коли ви здобудете впевненість у своїх рішеннях, наносьте послідовні шари полірування. Не прагнете досконалості - нетривіальні програми ніколи не бувають досконалими, і завжди є ще щось, що можна зробити для їх покращення. Досягніть "достатньо добре" і рухайтеся далі.

**Оптимізуйте для зручності обслуговування, а не для продуктивності.** Існує відома цитата (Дональда Кнута), яка говорить, що "передчасна оптимізація - це корінь усього зла". Програмісти-початківці часто витрачають занадто багато часу на роздуми про те, як мікрооптимізувати свій код (наприклад, намагаючись з'ясувати, який з 2 операторів працює швидше). Це рідко має значення. Більшість переваг у продуктивності досягається завдяки хорошій структурі програми, використанню правильних інструментів і можливостей для вирішення поставленої задачі, а також дотриманню найкращих практик. Додатковий час слід використовувати для покращення супроводжуваності вашого коду. Знайдіть надмірність і видаліть її. Розділіть довгі функції на коротші. Замініть незручний або складний у використанні код на щось краще. Кінцевим результатом буде код, який буде легше покращувати та оптимізувати пізніше (після того, як ви визначите, де оптимізація дійсно потрібна), і в якому буде менше помилок.

> Складна система, яка працює, незмінно еволюціонувала з простої системи, яка працювала - **Джон Голл**, Систематика: Як системи насправді працюють і як вони зазнають невдачі, с. 71

## Висновок
Багато програмістів-початківців пропускають процес проектування (тому що це здається великою роботою і/або це не так весело, як написання коду). Однак, для будь-якого нетривіального проекту, виконання цих кроків заощадить вам багато часу в довгостроковій перспективі. Невелике планування заздалегідь економить багато налагодження в кінці.

> [!NOTE]
> Витративши трохи часу на обдумування структури вашої програми, ви отримаєте кращий код і менше часу витратите на пошук і виправлення помилок.
> 
> > Я б сказав, що це, мабуть, найважливіша річ у програмуванні, і деякі з нас, як і я спочатку, сприймали це як належне. -Читач **Емека Даніель**, коментар на [learncpp.com](http://learncpp.com/

Коли ви відчуєте себе більш комфортно з цими концепціями та порадами, вони почнуть сприйматися вами більш природно. Зрештою, ви дійдете до того, що зможете писати цілі функції (і короткі програми) з мінімальним попереднім плануванням.