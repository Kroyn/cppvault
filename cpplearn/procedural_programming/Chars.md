---
date: 2024-09-11
tags:
  - Процедурне_програмування
  - Фундаментальні_типи_дани
---
До цього моменту основні типи даних, які ми розглянули, використовувалися для зберігання чисел (цілі числа і числа з плаваючою комою) або значень true/false (булеві). Але що, якщо ми хочемо зберігати літери або знаки пунктуації?
```cpp
#include <iostream>

int main()
{
    std::cout << "Would you like a burrito? (y/n)";

    // We want the user to enter a 'y' or 'n' character
    // How do we do this?

    return 0;
}
```
Тип даних `char` було розроблено для зберігання одного символу. **Символом** може бути одна літера, цифра, символ або пробіл.

Тип даних `char` є цілим типом, тобто базове значення зберігається як ціле число. Подібно до того, як булеве значення `0` інтерпретується як `false`, а ненульове - як `true`, ціле число, що зберігається у змінній типу `char`, інтерпретується як `ASCII-символ`.

**ASCII** розшифровується як American Standard Code for Information Interchange (Американський стандартний код для обміну інформацією) і визначає особливий спосіб представлення англійських символів (а також деяких інших символів) у вигляді чисел від 0 до 127 (так званий ASCII-код або кодова точка). Наприклад, код ASCII 97 інтерпретується як символ "a".

Символьні літерали завжди беруться в одинарні лапки (наприклад, 'g', '1', ' ').

Ось повна таблиця символів ASCII:

|Code|Symbol|Code|Symbol|Code|Symbol|Code|Symbol|
|---|---|---|---|---|---|---|---|
|0|NUL (null)|32|(space)|64|@|96|`|
|1|SOH (start of header)|33|!|65|A|97|a|
|2|STX (start of text)|34|”|66|B|98|b|
|3|ETX (end of text)|35|#|67|C|99|c|
|4|EOT (end of transmission)|36|$|68|D|100|d|
|5|ENQ (enquiry)|37|%|69|E|101|e|
|6|ACK (acknowledge)|38|&|70|F|102|f|
|7|BEL (bell)|39|’|71|G|103|g|
|8|BS (backspace)|40|(|72|H|104|h|
|9|HT (horizontal tab)|41|)|73|I|105|i|
|10|LF (line feed/new line)|42|*|74|J|106|j|
|11|VT (vertical tab)|43|+|75|K|107|k|
|12|FF (form feed / new page)|44|,|76|L|108|l|
|13|CR (carriage return)|45|-|77|M|109|m|
|14|SO (shift out)|46|.|78|N|110|n|
|15|SI (shift in)|47|/|79|O|111|o|
|16|DLE (data link escape)|48|0|80|P|112|p|
|17|DC1 (data control 1)|49|1|81|Q|113|q|
|18|DC2 (data control 2)|50|2|82|R|114|r|
|19|DC3 (data control 3)|51|3|83|S|115|s|
|20|DC4 (data control 4)|52|4|84|T|116|t|
|21|NAK (negative acknowledge)|53|5|85|U|117|u|
|22|SYN (synchronous idle)|54|6|86|V|118|v|
|23|ETB (end of transmission block)|55|7|87|W|119|w|
|24|CAN (cancel)|56|8|88|X|120|x|
|25|EM (end of medium)|57|9|89|Y|121|y|
|26|SUB (substitute)|58|:|90|Z|122|z|
|27|ESC (escape)|59|;|91|[|123|{|
|28|FS (file separator)|60|<|92|\|124|\||
|29|GS (group separator)|61|=|93|]|125|}|
|30|RS (record separator)|62|>|94|^|126|~|
|31|US (unit separator)|63|?|95|_|127|DEL (delete)|
Коди 0-31 і 127 називаються недрукованими символами. Ці коди були розроблені для керування периферійними пристроями, такими як принтери (наприклад, для вказівки принтеру, як рухати друкуючу головку). Більшість з них вже застаріли. Якщо ви спробуєте надрукувати ці символи, результати залежатимуть від вашої операційної системи (можливо, ви отримаєте символи, схожі на емодзі).

Коди 32-126 називаються друкованими символами, і вони представляють літери, цифри та розділові знаки, які більшість комп'ютерів використовують для відображення основного англійського тексту.
## Ініціалізація символів
Ви можете ініціалізувати змінні типу char за допомогою символьних літералів:
```cpp
char ch2{ 'a' }; // initialize with code point for 'a' (stored as integer 97) (preferred)
```
Ви також можете ініціалізувати символи цілими числами, але цього слід уникати, якщо це можливо
```cpp
char ch1{ 97 }; // initialize with integer 97 ('a') (not preferred)
```

> [!caution]
> Будьте уважні, щоб не переплутати символьні числа з цілими числами. Наступні дві ініціалізації не є однаковими:
> ```cpp
> char ch{5}; // initialize with integer 5 (stored as integer 5)
> char ch{'5'}; // initialize with code point for '5' (stored as integer 53)
> ```
> Символьні числа призначені для використання, коли ми хочемо представити числа у вигляді тексту, а не як числа, до яких можна застосовувати математичні операції.
## Друк символів
При використанні std::cout для друку char, std::cout виводить змінну char як ASCII-символ:
```cpp
#include <iostream>

int main()
{
    char ch1{ 'a' }; // (preferred)
    std::cout << ch1; // cout prints character 'a'

    char ch2{ 98 }; // code point for 'b' (not preferred)
    std::cout << ch2; // cout prints a character ('b')


    return 0;
}
```
Це дає результат:
```
ab
```
Ми також можемо виводити літерали типу char безпосередньо:
```cpp
std::cout << 'c';
```
Це дає результат:
```
c
```
## Введення символів
Наступна програма просить користувача ввести символ, а потім виводить його на екран:
```cpp
#include <iostream>

int main()
{
    std::cout << "Input a keyboard character: ";

    char ch{};
    std::cin >> ch;
    std::cout << "You entered: " << ch << '\n';

    return 0;
}
```
Ось результат одного прогону:
```
Input a keyboard character: q
You entered: q
```
Зверніть увагу, що std::cin дозволяє вводити декілька символів. Однак, змінна ch може містити лише 1 символ. Отже, до змінної ch буде витягнуто лише перший введений символ. Решта введених користувачем даних залишається у буфері вводу, який використовує std::cin, і може бути витягнута наступними викликами std::cin.

Ви можете побачити таку поведінку у наступному прикладі:
```cpp
#include <iostream>

int main()
{
    std::cout << "Input a keyboard character: "; // assume the user enters "abcd" (without quotes)

    char ch{};
    std::cin >> ch; // ch = 'a', "bcd" is left queued.
    std::cout << "You entered: " << ch << '\n';

    // Note: The following cin doesn't ask the user for input, it grabs queued input!
    std::cin >> ch; // ch = 'b', "cd" is left queued.
    std::cout << "You entered: " << ch << '\n';

    return 0;
}
```
```
Input a keyboard character: abcd
You entered: a
You entered: b
```
Якщо ви хочете прочитати більше одного символу за раз (наприклад, ім'я, слово або речення), вам слід використовувати рядок замість символу. Рядок - це набір послідовних символів (отже, рядок може містити декілька символів).
## Розмір символу, діапазон та знак за замовчуванням
У C++ визначено, що char завжди має розмір 1 байт. За замовчуванням, символ може бути знаковим або беззнаковим (хоча зазвичай він є знаковим). Якщо ви використовуєте символи для зберігання ASCII-символів, вам не потрібно вказувати знак (оскільки як знакові, так і беззнакові символи можуть містити значення від 0 до 127).

Якщо ви використовуєте символ для зберігання невеликих цілих чисел (чого не слід робити, якщо тільки ви явно не оптимізуєте простір), ви завжди повинні вказувати, чи є він знаковим або беззнаковим. Знаковий тип char може містити число у діапазоні від -128 до 127. Беззнаковий символ може містити число від 0 до 255.
## Послідовності евакуації
У мові C++ існують деякі послідовності символів, які мають особливе значення. Ці символи називаються екранованими послідовностями. Послідовність екранування починається з символу '\' (зворотна коса риска), а потім наступної літери або цифри.

Ви вже бачили найпоширенішу екрануючу послідовність: `'\n'`, яку можна використовувати для друку нового рядка:
```cpp
#include <iostream>

int main()
{
    int x { 5 };
    std::cout << "The value of x is: " << x << '\n'; // standalone \n goes in single quotes
    std::cout << "First line\nSecond line\n";        // \n can be embedded in double quotes
    return 0;
}
```
Це виходить:
```
The value of x is: 5
First line
Second line
```
Іншою часто використовуваною екрануючою послідовністю є '\t', яка вбудовує горизонтальну табуляцію:
```cpp
#include <iostream>

int main()
{
    std::cout << "First part\tSecond part";
    return 0;
}
```
Що виходить:
```
First part	Second part
```
Три інші помітні екрановані послідовності:
`\'` виводить одинарні лапки
`\"` друкує подвійні лапки
`\\` друкує зворотну косу риску

Ось таблиця з переліком усіх екранованих послідовностей:

|Name|Symbol|Meaning|
|---|---|---|
|Alert|\a|Makes an alert, such as a beep|
|Backspace|\b|Moves the cursor back one space|
|Formfeed|\f|Moves the cursor to next logical page|
|Newline|\n|Moves cursor to next line|
|Carriage return|\r|Moves cursor to beginning of line|
|Horizontal tab|\t|Prints a horizontal tab|
|Vertical tab|\v|Prints a vertical tab|
|Single quote|\’|Prints a single quote|
|Double quote|\”|Prints a double quote|
|Backslash|\\|Prints a backslash.|
|Question mark|\?|Prints a question mark.  <br>No longer relevant. You can use question marks unescaped.|
|Octal number|\(number)|Translates into char represented by octal|
|Hex number|\x(number)|Translates into char represented by hex number|
Ось кілька прикладів:
```cpp
#include <iostream>

int main()
{
    std::cout << "\"This is quoted text\"\n";
    std::cout << "This string contains a single backslash \\\n";
    std::cout << "6F in hex is char '\x6F'\n";
    return 0;
}
```
Відбитки:
```
"This is quoted text"
This string contains a single backslash \
6F in hex is char 'o'
```

> [!caution]
> Ескейп-послідовності починаються зі зворотної косої риски (\), а не з прямої (/). Якщо ви випадково використаєте пряму похилу риску, вона все одно буде скомпільована, але не дасть бажаного результату.

## Яка різниця між взяттям символів в одинарні та подвійні лапки?
Текст між одинарними лапками розглядається як літерал char, який представляє один символ. Наприклад, `'a'` позначає символ a, `'+'` позначає символ плюс, `'5'` позначає символ `5` (не число 5), а `'\n'` позначає символ переходу на новий рядок.

Текст між подвійними лапками (наприклад, "Hello, world!") розглядається як рядковий літерал у стилі C, який може містити декілька символів.
> [!tip]
> Поодинокі символи зазвичай слід брати у одинарні лапки, а не у подвійні (наприклад, `'t'` або `'\n'`, а не `"t"` або `"\n"`). Один можливий виняток виникає при виведенні даних, коли для узгодженості може бути краще взяти все у подвійні лапки.
## Уникайте багатосимвольних літералів
З міркувань зворотної сумісності багато компіляторів C++ підтримують багатосимвольні літерали, тобто літерали типу char, які містять декілька символів (наприклад, '56'). Якщо вони підтримуються, то мають значення, визначене реалізацією (тобто змінюються залежно від компілятора). Оскільки вони не є частиною стандарту C++, і їх значення не є строго визначеним, багатосимвольних літералів слід уникати.
> [!tip]
> Уникайте багатосимвольних літералів (наприклад, `'56'`).

Підтримка багатосимвольних літералів іноді викликає проблеми у програмістів-початківців. Розглянемо наступну просту програму:
```cpp
#include <iostream>

int add(int x, int y)
{
	return x + y;
}

int main()
{
	std::cout << add(1, 2) << '/n';

	return 0;
}
```
Програміст очікує, що ця програма виведе значення `3` і новий рядок. Але натомість на машині автора вона виводить наступне:
```
312142
```
Проблема полягає у тому, що програміст випадково використав`'/n'` (багатосимвольний літерал, що складається з прямої похилої риски та символу `'n'`) замість `'\n'` (екрануюча послідовність для переходу на новий рядок). Спочатку програма коректно виводить `3` (результат `add(1, 2)`). Але потім вона виводить значення `'/n'`, яке на машині автора мало визначене реалізацією значення `12142`.
> [!caution]
> Переконайтеся, що у ваших нових рядках використовується екранована послідовність `'\n'`, а не багатосимвольний літерал `'/n'`.

> [!NOTE]
> Зауважте, що якби ми взяли вивід `"/n"` у подвійні лапки, програма вивела б `3/n`, що все одно неправильно, але набагато менш заплутано.

Ось ще один приклад:
```cpp
#include <iostream>

int main()
{
    int x { 5 };
    std::cout << "The value of x is " << x << '\n';

    return 0;
}
```
Ця програма виводить саме те, що ви очікуєте:
```
The value of x is 5
```
Але такий вивід не є достатньо цікавим, тому ми вирішили додати знак оклику перед новим рядком:
```cpp
#include <iostream>

int main()
{
    int x { 5 };
    std::cout << "The value of x is " << x << '!\n'; // added exclamation point

    return 0;
}
```
Оскільки `'!\n`' є багатосимвольним літералом, ця програма тепер друкує:
```
The value of x is 58458
```
Можливо, це не те, чого ви очікували.
## А як щодо інших типів `char`, `wchar_t`, `char8_t`, `char16_t` та `char32_t`?
`wchar_t` слід уникати майже у всіх випадках (окрім випадків взаємодії з Windows API). Його розмір визначається реалізацією і не є надійним. Він значною мірою застарілий.

> [!NOTE]
> Термін "застарілий" означає "все ще підтримується, але більше не рекомендується для використання, оскільки його замінили на щось краще або він більше не вважається безпечним".

Подібно до того, як ASCII відображає цілі числа 0-127 в символи американської англійської мови, існують інші стандарти кодування символів для відображення цілих чисел (різного розміру) в символи інших мов. Найвідомішим стандартом кодування, відмінним від ASCII, є стандарт Unicode, який відображає понад 144 000 цілих чисел у символи різних мов. Оскільки Unicode містить так багато кодових точок, одна кодова точка Unicode потребує 32 біти для представлення символу (так звана UTF-32). Однак символи Unicode також можуть бути закодовані за допомогою декількох 16-бітових або 8-бітових символів (UTF-16 і UTF-8 відповідно).

`char16_t` та `char32_t` було додано до C++11 для забезпечення явної підтримки 16-бітних та 32-бітних символів Unicode. Ці типи char мають той самий розмір, що й `std::uint_least16_t` та `std::uint_least32_t` відповідно (але є різними типами). `char8_t` було додано у C++20 для забезпечення підтримки 8-бітового Unicode (UTF-8). Це окремий тип, який використовує те саме представлення, що і беззнаковий char.

Вам не потрібно використовувати `char8_t`, `char16_t` або `char32_t`, якщо ви не плануєте зробити вашу програму сумісною з Unicode. Юнікод і локалізація загалом виходять за рамки цього підручника, тому ми не розглядатимемо цю тему далі

Тим часом, при роботі з символами (і рядками) слід використовувати лише символи ASCII. Використання символів з інших кодувань може призвести до некоректного відображення ваших символів.