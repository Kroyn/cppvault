---
date: 2024-09-03
tags:
  - Процедурне_програмування
  - Основи
---
Коли програма містить лише кілька невеликих файлів, додавання вручну кількох оголошень до початку кожного файлу не є надто складним завданням. Однак, коли програма стає більшою (і використовує більше файлів), ручне додавання оголошень до кожної функції, яка визначається в іншому файлі, стає все більш нудним. Наприклад, якщо у вас програма з 5 файлів, кожен з яких вимагає 10 оголошень, вам доведеться додати 50 таких оголошень. Тепер розглянемо випадок, коли у вас 100 файлів і кожен з них вимагає 100 попередніх декларацій. Це просто не масштабується!

Для вирішення цієї проблеми у програмах на C++ зазвичай використовують інший підхід.
## Заголовні файли
Файли коду C++ (з розширенням .cpp) - це не єдині файли, які зазвичай зустрічаються у програмах на C++. Інший тип файлів називається заголовним файлом. Зазвичай заголовні файли мають розширення .h, але іноді ви можете побачити їх з розширенням .hpp або взагалі без розширення.

Зазвичай, заголовні файли використовуються для розповсюдження групи пов'язаних між собою прямих оголошень у файлі коду.

> [!NOTE]
> Заголовні файли дозволяють нам зберігати декларації в одному місці, а потім імпортувати їх куди завгодно. Це може заощадити багато набору тексту в багатофайлових програмах.
## Використання стандартних заголовних файлів бібліотек
Розглянемо наступну програму:

```cpp
#include <iostream>

int main()
{
    std::cout << "Hello, world!";
    return 0;
}
```

Ця програма виводить "Hello, world!" на консоль за допомогою std::cout. Однак, у цій програмі не було надано визначення або оголошення std::cout, тож звідки компілятор знає, що таке std::cout?

Відповідь полягає у тому, що `std::cout` було оголошено у заголовному файлі "iostream". Коли ми `#include <iostream>,` ми просимо препроцесор скопіювати весь вміст (включаючи прямі оголошення для `std::cout`) з файлу з назвою "iostream" у файл, в якому виконується `#include`.

> [!NOTE]
> Коли ви `#include` файл, вміст файлу, що включається, вставляється в точку включення. Це надає зручний спосіб підтягувати декларації з іншого файлу.

Подумайте, що сталося б, якби заголовка iostream не існувало. Де б ви не використовували std::cout, вам довелося б вручну вводити або копіювати всі оголошення, пов'язані з std::cout, у початок кожного файлу, який використовує std::cout! Це вимагало б багато знань про те, як було оголошено std::cout, і було б тонною роботи. Ще гірше, якщо прототип функції було додано або змінено, нам довелося б вручну оновлювати всі прямі оголошення.

Набагато простіше просто `#include <iostream>`!
## Використання заголовних файлів для розповсюдження форвардних декларацій
Тепер давайте повернемося до прикладу, який ми обговорювали в попередньому уроці. Коли ми зупинилися, у нас було два файли, add.cpp і main.cpp, які виглядали наступним чином:

add.cpp:

```cpp
int add(int x, int y)
{
    return x + y;
}
```

main.cpp:

```cpp
#include <iostream>

int add(int x, int y); // forward declaration using function prototype

int main()
{
    std::cout << "The sum of 3 and 4 is " << add(3, 4) << '\\n';
    return 0;
}
```

(Якщо ви відтворюєте цей приклад з нуля, не забудьте додати add.cpp до вашого проекту, щоб він скомпілювався).

У цьому прикладі ми використали пряме оголошення, щоб компілятор знав, що таке ідентифікатор add під час компіляції main.cpp. Як згадувалося раніше, ручне додавання форвардних оголошень для кожної функції, яку ви хочете використати, але яка знаходиться в іншому файлі, може швидко набриднути.

Давайте напишемо заголовний файл, який звільнить нас від цього тягаря. Написати заголовний файл напрочуд легко, оскільки він складається лише з двох частин:
1. Захист заголовків.
2. Власне вміст заголовного файлу, який повинен містити прямі декларації для всіх ідентифікаторів, які ми хочемо, щоб інші файли могли бачити.

Додавання заголовного файлу до проекту працює аналогічно до додавання вихідного файлу.

Якщо ви використовуєте IDE, виконайте ті самі кроки і виберіть "Header" замість "Source", коли вас запитають про це. Файл заголовка має з'явитися у складі вашого проекту.

Якщо ви використовуєте командний рядок, просто створіть новий файл у вашому улюбленому редакторі у тій самій директорії, де знаходяться ваші вихідні файли (.cpp). На відміну від вихідних файлів, заголовні файли не слід додавати до команди компіляції (вони неявно включаються за допомогою інструкції `#include` і компілюються як частина вихідних файлів).

> [!success]
> Надавайте перевагу суфіксу .h при назві заголовних файлів (якщо тільки ваш проект не дотримується іншої конвенції).
> 
> Це давня угода для заголовних файлів C++, і більшість IDE за замовчуванням надають перевагу .h, а не іншим варіантам.

Заголовні файли часто йдуть у парі з файлами коду, при цьому заголовний файл містить прямі оголошення для відповідного файлу коду. Оскільки наш заголовний файл міститиме прямі оголошення для функцій, визначених у файлі add.cpp, ми назвемо наш новий заголовний файл add.h.

> [!success]
> Якщо заголовний файл поєднується з кодом (наприклад, add.h з add.cpp), вони повинні мати однакове базове ім'я (add).

Ось наш готовий заголовний файл:

add.h:

```cpp
// 1) We really should have a header guard here, but will omit it for simplicity (we'll cover header guards in the next lesson)

// 2) This is the content of the .h file, which is where the declarations go
int add(int x, int y); // function prototype for add.h -- don't forget the semicolon!
```

Щоб використовувати цей заголовний файл в main.cpp, ми повинні `#include` його (використовуючи лапки, а не кутові дужки).

main.cpp:

```cpp
#include "add.h" // Insert contents of add.h at this point.  Note use of double quotes here.
#include <iostream>

int main()
{
    std::cout << "The sum of 3 and 4 is " << add(3, 4) << '\\n';
    return 0;
}
```

add.cpp:

```cpp
#include "add.h" // Insert contents of add.h at this point.  Note use of double quotes here.

int add(int x, int y)
{
    return x + y;
}
```

Коли препроцесор обробляє рядок `#include "add.h"`, він копіює вміст add.h у поточний файл. Оскільки наш add.h містить прямий виклик функції add(), цей прямий виклик буде скопійовано в main.cpp. В результаті ми отримаємо програму, яка функціонально не відрізняється від тієї, в якій ми вручну додали оголошення forward у верхній частині main.cpp.

Отже, наша програма буде компілюватися і компонуватися коректно.
![Pasted image 20240903144241.png](./images/Pasted%20image%2020240903144241.png)
Зауваження: На наведеному вище графіку "Стандартна бібліотека виконання" має бути позначена як "Стандартна бібліотека C++".
## Як включення визначень у заголовний файл призводить до порушення правила одного визначення
Наразі вам слід уникати розміщення визначень функцій або змінних у заголовних файлах. Це, як правило, призводить до порушення правила одного визначення (ODR) у випадках, коли заголовний файл включається до більш ніж одного вихідного файлу.

Проілюструємо, як це відбувається:

add.h:

```cpp
// We really should have a header guard here, but will omit it for simplicity (we'll cover header guards in the next lesson)

// definition for add() in header file -- don't do this!
int add(int x, int y)
{
    return x + y;
}
```

main.cpp:

```cpp
#include "add.h" // Contents of add.h copied here
#include <iostream>

int main()
{
    std::cout << "The sum of 3 and 4 is " << add(3, 4) << '\\n';

    return 0;
}
```

add.cpp:

```cpp
#include "add.h" // Contents of add.h copied here
```

Коли компілюється `main.cpp`, `#include "add.h"` буде замінено на вміст `add.h`, а потім скомпільовано. Таким чином, компілятор скомпілює щось подібне до цього:

`main.cpp` (після препроцесування):

```cpp
// from add.h:
int add(int x, int y)
{
    return x + y;
}

// contents of iostream header here

int main()
{
    std::cout << "The sum of 3 and 4 is " << add(3, 4) << '\\n';

    return 0;
}
```

Це буде скомпільовано просто чудово.

Коли компілятор компілює `add.cpp`, `#include "add.h"` буде замінено на вміст `add.h`, а потім скомпільовано. Таким чином, компілятор скомпілює щось на зразок цього:

`add.cpp` (після препроцесування):

```cpp
int add(int x, int y)
{
    return x + y;
}
```

Це також буде скомпільовано просто чудово.

Нарешті, запуститься компонувальник. І компонувальник побачить, що для функції add() тепер є два визначення: одне в `main.cpp`, а інше в `add.cpp`. Це є порушенням частини 2 ODR, яка говорить: "У межах даної програми змінна або звичайна функція може мати тільки одне визначення".

> [!success]
> Не розміщуйте визначення функцій та змінних у заголовних файлах (поки що).
> Визначення будь-якого з них у заголовному файлі, ймовірно, призведе до порушення правила одного визначення (ODR), якщо цей заголовок потім буде `#included` у більш ніж одному вихідному (.cpp) файлі.
## Вихідні файли повинні містити їх парний заголовок
У C++ найкращою практикою для файлів коду є #include їх парний заголовний файл (якщо такий існує). У наведеному вище прикладі add.cpp включає add.h.

Це дозволяє компілятору перехоплювати певні типи помилок під час компіляції, а не під час компонування. Наприклад:

something.h:

```cpp
int something(int); // return type of forward declaration is int
```

something.cpp:

```cpp
#include "something.h"

void something(int) // error: wrong return type
{
}
```

Оскільки something.cpp `#includes` something.h, компілятор помітить, що функція something() має невідповідний тип повернення, і видасть нам помилку компіляції. Якби something.cpp не `#includв` something.h, нам довелося б чекати, поки компонувальник виявить невідповідність, а це марна трата часу. Інший приклад дивіться у цьому коментарі.
> [!success] 
> Вихідні файли повинні `#include` свій парний заголовний файл (якщо він існує).
## Не вписуйте `#include` до `.cpp` файлів
Хоча препроцесор із задоволенням це зробить, вам, як правило, не слід `#include` файли .cpp. Їх слід додати до вашого проекту і скомпілювати.

На це є декілька причин:
- Це може спричинити колізії імен між вихідними файлами.
- У великому проекті може бути важко уникнути проблем, пов'язаних з правилами одного визначення (ODR).
- Будь-яка зміна в такому .cpp-файлі призведе до перекомпіляції як самого .cpp-файлу, так і будь-якого іншого .cpp-файлу, який його містить, що може зайняти багато часу.
- Заголовки, як правило, змінюються рідше, ніж вихідні файли. Це не є загальноприйнятою практикою.

> [!success]
> Уникайте `#including` .cpp файлів.

> [!NOTE]
> Якщо ваш проект не компілюється, якщо ви не `#include` .cpp файли, це означає, що ці .cpp файли не компілюються як частина вашого проекту. Додайте їх до проекту або командного рядка, щоб вони були скомпільовані.
## Усунення несправностей
Якщо ви отримуєте помилку компілятора, яка вказує на те, що add.h не знайдено, переконайтеся, що файл дійсно має ім'я add.h. Залежно від того, як ви його створили і назвали, файл міг мати назву на кшталт add (без розширення), add.h.txt або add.hpp. Також переконайтеся, що він знаходиться в тому ж каталозі, що і решта ваших файлів коду.

Якщо компонувальник видає помилку про те, що функція add не визначена, переконайтеся, що ви включили файл add.cpp у ваш проект, щоб визначення функції add можна було підключити до програми.
## Кутові дужки проти подвійних лапок
Вам, мабуть, цікаво, чому ми використовуємо кутові дужки для `iostream` і подвійні лапки для add.h. Цілком можливо, що заголовний файл з однаковим іменем може існувати у декількох каталогах. Використання кутових дужок та подвійних лапок допомагає препроцесору отримати підказку, де саме шукати заголовні файли.

Коли ми використовуємо кутові дужки, ми говоримо препроцесору, що це заголовний файл, який ми не писали самі. Препроцесор шукатиме заголовний файл лише у каталогах, вказаних у каталогах include. Каталоги include налаштовуються як частина вашого проекту/налаштувань IDE/налаштувань компілятора і зазвичай за замовчуванням вказують на каталоги з заголовними файлами, які постачаються з вашим компілятором та/або операційною системою. Препроцесор не шукатиме заголовний файл у каталозі вихідного коду вашого проекту.

Коли ми використовуємо подвійні лапки, ми повідомляємо препроцесору, що це файл заголовка, який ми написали. Спочатку препроцесор шукатиме заголовний файл у поточному каталозі. Якщо він не знайде відповідного заголовка там, він шукатиме його у каталогах включення.

> [!NOTE]
> Використовуйте подвійні лапки для включення файлів заголовків, які ви написали або які, як очікується, буде знайдено у поточному каталозі. Використовуйте кутові дужки для включення заголовків, які постачаються з компілятором, операційною системою або сторонніми бібліотеками, які ви встановили деінде у вашій системі.
## Чому `iostream` не має розширення `.h`?
Ще одне питання, яке часто задають: "Чому `iostream` (або будь-який інший стандартний заголовний файл бібліотеки) не має розширення .h?". Відповідь полягає у тому, що `iostream.h` - це інший заголовний файл, ніж `iostream`! Щоб пояснити це, потрібен короткий урок історії.

Коли C++ було вперше створено, всі заголовки стандартної бібліотеки закінчувалися суфіксом .h. У тому числі і ці заголовки:

|Тип заголовка|Угода про іменування|Приклад|Ідентифікатори, розміщені у просторі імен|
|---|---|---|---|
|C++ specific|<xxx.h>|iostream.h|Global namespace|
|C compatability|<xxx.h>|stddef.h|Global namespace|

Початкові версії `cout` і `cin` були оголошені в `iostream.h` у глобальному просторі імен. Життя було послідовним, і це було добре.

Коли мову було стандартизовано комітетом ANSI, вони вирішили перенести всі імена, що використовуються у стандартній бібліотеці, до простору імен std, щоб уникнути конфліктів імен з ідентифікаторами, оголошеними користувачем. Однак це створило проблему: якщо перенести всі імена до простору імен std, жодна зі старих програм (у тому числі `iostream.h`) більше не працюватиме!

Щоб обійти цю проблему, C++ запровадила нові заголовні файли, які не мають розширення .h. Ці нові заголовні файли оголошують всі імена всередині простору імен std. Таким чином, старі програми, які включають `#include <iostream.h>`, не потрібно переписувати, а нові програми можуть `#include <iostream>`.

Сучасна C++ тепер містить 4 набори заголовних файлів:

| Тип заголовка         | Угода про іменування | Приклад    | Ідентифікатори, розміщені у просторі імен           |
| --------------------- | -------------------- | ---------- | --------------------------------------------------- |
| C++ specific (new)    | `<xxx>`              | iostream   | std namespace                                       |
| C compatibility (new) | `<cxxx>`             | cstddef    | std namespace (required)global namespace (optional) |
| C++ specific (old)    | `<xxx.h>`            | iostream.h | Global namespace                                    |
| C compatability (old) | `<xxx.h>`            | stddef.h   | Global namespace (required)std namespace (optional) |

> [!attention]
> Нові заголовки сумісності C `<cxxx>` можуть додатково оголошувати імена у глобальному просторі імен, а старі заголовки сумісності C `<xxx.h>` можуть додатково оголошувати імена у просторі імен std. Слід уникати використання імен у цих місцях, оскільки ці імена можуть бути не оголошені у цих місцях в інших реалізаціях.

> [!success]
> Використовуйте стандартні заголовки бібліотек без розширення .h. Користувацькі заголовки все одно повинні мати розширення .h.
## Включаючи заголовні файли з інших каталогів
Ще одне поширене питання стосується того, як включити заголовні файли з інших каталогів.

Один з (поганих) способів зробити це - вказати відносний шлях до заголовного файлу, який ви хочете включити, як частину рядка #include. Наприклад:

```cpp
#include "headers/myHeader.h"
#include "../moreHeaders/myOtherHeader.h"
```

Хоча це призведе до компіляції (якщо припустити, що файли існують у цих відносних каталогах), недоліком такого підходу є те, що він вимагає від вас відображення вашої структури каталогів у коді. Якщо ви коли-небудь оновите структуру каталогів, ваш код більше не працюватиме.

Кращий спосіб - вказати компілятору або IDE, що у вас є набір заголовних файлів у іншому місці, щоб він шукав їх там, коли не зможе знайти у поточному каталозі. Зазвичай це можна зробити, задавши шлях включення або каталог пошуку у налаштуваннях проекту у вашому середовищі розробки.

Приємною особливістю цього підходу є те, що якщо ви коли-небудь зміните структуру каталогів, вам потрібно буде змінити лише один параметр компілятора або IDE, а не кожен файл коду.
## Заголовки можуть включати в себе інші заголовки
Зазвичай заголовний файл потребує оголошення або визначення, яке міститься в іншому заголовному файлі. Через це заголовні файли часто `#include` інші заголовні файли.

Коли ваш файл коду `#include` перший заголовний файл, ви також отримаєте всі інші заголовні файли, які містить перший заголовний файл (і всі заголовні файли, які містять ці файли, і так далі). Ці додаткові заголовні файли іноді називають перехідними, оскільки вони включаються неявно, а не явно.

Вміст цих транзитивних включень доступний для використання у вашому файлі коду. Однак, як правило, не слід покладатися на вміст заголовків, що включаються транзитивно (якщо тільки у довідковій документації не вказано, що такі транзитивні включення є обов'язковими). Реалізація файлів заголовків може змінюватися з часом або відрізнятися у різних системах. Якщо це станеться, ваш код може компілюватися лише на певних системах, або може компілюватися зараз, але не компілюватися у майбутньому. Цього легко уникнути, явно включивши всі заголовні файли, яких вимагає вміст вашого файлу коду.

> [!success]
> Кожен файл повинен явно `#включати` всі заголовні файли, які йому потрібно скомпілювати. Не покладайтеся на заголовки, включені транзитивно з інших заголовків.

На жаль, не існує простого способу виявити, коли ваш файл коду випадково покладається на вміст заголовного файлу, який було включено іншим заголовним файлом.
## Порядок `#include` заголовних файлів

Якщо ваші заголовні файли написані правильно і `#include` все необхідне, порядок включення не повинен мати значення.

Тепер розглянемо наступний сценарій: скажімо, заголовку A потрібні декларації з заголовка B, але він забув їх включити. У нашому файлі коду, якщо ми включимо заголовок B перед заголовком A, наш код все одно буде скомпільовано! Це тому, що компілятор скомпілює всі оголошення з заголовка B до того, як він скомпілює код з заголовка A, який залежить від цих оголошень.

Однак, якщо ми включимо заголовок A першим, то компілятор поскаржиться, тому що код з A буде скомпільовано до того, як компілятор побачить оголошення з B. Насправді це краще, тому що помилка випливе на поверхню, і ми зможемо її виправити.

> [!success]
> Щоб максимізувати ймовірність того, що відсутні інклуди будуть помічені компілятором, впорядкуйте ваші `#include` наступним чином:
> 1. Парний заголовний файл
> 2. Інші заголовки з вашого проекту
> 3. Заголовки сторонніх бібліотек
> 4. Стандартні заголовки бібліотек
> Заголовки для кожної групи слід сортувати за алфавітом (якщо документація до сторонньої бібліотеки не вказує вам іншого).

Таким чином, якщо в одному з ваших користувацьких заголовків відсутній `#include` для бібліотеки сторонніх розробників або стандартного заголовка бібліотеки, це, швидше за все, спричинить помилку компіляції, яку ви зможете виправити.
## Найкращі практики щодо заголовного файлу
Ось ще кілька рекомендацій щодо створення та використання файлів заголовків.

- Завжди включайте захисники заголовків (ми розглянемо їх на наступному уроці).
- Не визначайте змінні та функції у заголовних файлах (поки що).
- Дайте заголовному файлу те саме ім'я, що і вихідному файлу, з яким він пов'язаний (наприклад, grades.h у парі з grades.cpp).
- Кожен заголовний файл повинен виконувати певну роботу і бути максимально незалежним. Наприклад, ви можете помістити всі ваші оголошення, пов'язані з функціональністю A, в A.h, а всі ваші оголошення, пов'язані з функціональністю B, в B.h. Таким чином, якщо пізніше вас буде цікавити тільки A, ви можете просто включити A.h і не отримати нічого з того, що пов'язано з B.
- Пам'ятайте про те, які заголовки потрібно явно включати для функціональності, яку ви використовуєте у ваших файлах коду, щоб уникнути ненавмисних транзитивних включень.
- Заголовний файл повинен `#include` будь-які інші заголовки, що містять необхідну йому функціональність. Такий заголовок має успішно скомпілюватися, коли його буде `#include` до .cpp-файлу самостійно.
- Включайте тільки те, що вам потрібно (не включайте все просто тому, що можете).
- Не `#include` файли .cpp.
- Надавайте перевагу розміщенню документації про те, що щось робить або як це використовувати, у заголовку. Там її з більшою ймовірністю побачать. Документація, що описує, як щось працює, повинна залишатися у вихідних файлах.