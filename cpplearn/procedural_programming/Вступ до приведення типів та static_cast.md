---
date: 2024-09-11
tags:
  - Процедурне_програмування
  - Фундаментальні_типи_дани
---
## Неявне приведення типів
Розглянемо наступну програму:
```cpp
#include <iostream>

void print(double x) // print takes a double parameter
{
	std::cout << x << '\n';
}

int main()
{
	print(5); // what happens when we pass an int value?

	return 0;
}
```
У вищенаведеному прикладі функція `print()` має параметр типу `double`, але користувач передає значення `5`, яке має тип `int`. Що відбувається у цьому випадку?

У більшості випадків C++ дозволяє конвертувати значення одного фундаментального типу в інший фундаментальний тип. Процес перетворення значення з одного типу в інший називається приведенням типу. Таким чином, аргумент типу `int 5` буде перетворено у значення типу `double 5.0`, а потім скопійовано у параметр `x`. Функція `print()` виведе це значення, в результаті чого буде отримано наступний результат:
```
5
```

> [!NOTE]
> За замовчуванням значення з плаваючою комою, десяткова частина яких дорівнює 0, друкуються без десяткових знаків (наприклад, `5.0` друкується як `5`).

Коли компілятор виконує перетворення типів від нашого імені без нашого явного запиту, ми називаємо це **неявним перетворенням типів**. Наведений вище приклад ілюструє це - ми ніде явно не вказуємо компілятору перетворити ціле значення `5` у значення типу `double` `5.0`. Швидше за все, функція очікує значення типу `double`, а ми передаємо цілий аргумент. Компілятор помітить невідповідність і неявно перетворить ціле число у число типу `double`.

Ось схожий приклад, де нашим аргументом є змінна типу `int`, а не літерал типу `int`:
```cpp
#include <iostream>

void print(double x) // print takes a double parameter
{
	std::cout << x << '\n';
}

int main()
{
	int y { 5 };
	print(y); // y is of type int

	return 0;
}
```
Цей варіант працює ідентично до вищеописаного. Значення, що міститься у змінній `int` `y` (`5`), буде перетворено у подвійне значення `5.0`, а потім скопійовано у параметр `x`.
## Перетворення типу створює нове значення
Незважаючи на те, що це називається перетворенням, перетворення типу насправді не змінює значення або тип значення, яке перетворюється. Натомість значення, що перетворюється, використовується як вхідне, а результатом перетворення є нове значення цільового типу (через пряму ініціалізацію).

У наведеному вище прикладі перетворення не змінює змінну y з типу `int` на `double`. Замість цього перетворення використовує значення y (`5`) як вхідні дані для створення нового значення типу `double` (`5.0`). Це значення типу `double` передається у функцію `print`.

> [!NOTE]
> Перетворення типів використовує пряму ініціалізацію для створення нового значення цільового типу зі значення іншого типу.
## Попередження про неявне приведення типів
Хоча неявне приведення типів є достатнім для більшості випадків, коли потрібне приведення типів, існує декілька випадків, коли воно не є достатнім. Розглянемо наступну програму, яка подібна до наведеного вище прикладу:
```cpp
#include <iostream>

void print(int x) // print now takes an int parameter
{
	std::cout << x << '\n';
}

int main()
{
	print(5.5); // warning: we're passing in a double value

	return 0;
}
```
У цій програмі ми змінили функцію `print()`, щоб вона приймала параметр типу `int`, і тепер при виклику функції `print()` передається значення типу `double` `5.5`. Як і у випадку з наведеним вище, компілятор використає неявне приведення типу, щоб перетворити значення типу `double` `5.5` у значення типу `int`, яке можна буде передати у функцію `print()`.

На відміну від початкового прикладу, при компіляції цієї програми компілятор видасть попередження про можливу втрату даних. І оскільки у вас увімкнено опцію "розглядати попередження як помилки" (у вас же вона увімкнена, чи не так?), компілятор перерве процес компіляції.
> [!NOTE]
> Якщо ви хочете скомпілювати цей приклад, вам потрібно тимчасово вимкнути опцію "вважати попередження помилками".

Після компіляції та запуску ця програма виводить наступне:
```
5
```
Зверніть увагу, що хоча ми передали значення `5.5`, програма вивела `5`. Оскільки цілі значення не можуть містити дробові, при неявному перетворенні подвійного значення `5.5` в тип `int` дробовий компонент відкидається, і зберігається лише ціле значення.

Оскільки при перетворенні значення з плаваючою комою в ціле значення будь-яка дробова складова відкидається, компілятор попередить нас про неявне перетворення типу з плаваючою комою в ціле значення. Це станеться навіть якщо ми передамо значення з плаваючою комою без дробової складової, наприклад, `5.0` - у цьому конкретному випадку фактичної втрати значення при перетворенні до цілого значення `5` не відбудеться, але компілятор все одно може попередити нас про небезпеку такого перетворення.

> [!NOTE]
> Деякі перетворення типів завжди безпечні (наприклад, `int` у `double`), тоді як інші можуть призвести до зміни значення під час перетворення (наприклад, `double` у `int`). Небезпечні неявні перетворення зазвичай генерують або попередження компілятора, або (у випадку ініціалізації у фігурних дужках) помилку.
> 
> Це одна з основних причин, чому ініціалізація дужками є найкращою формою ініціалізації. Ініціалізація у фігурних дужках гарантує, що ми не намагатимемося ініціалізувати змінну ініціалізатором, який втратить значення при неявному перетворенні типу:
> ```cpp
> int main()
> {
>     double d { 5 }; // okay: int to double is safe
>     int x { 5.5 }; // error: double to int not safe
> 
>     return 0;
> }
> ```
> 
## Вступ до явного приведення типів з допомогою оператора `static_cast`
Повертаючись до нашого останнього прикладу `print()`, що, якби ми навмисно хотіли передати значення типу double у функцію, яка отримує ціле число (знаючи, що перетворене значення відкине дробову складову)? Вимкнення опції "вважати попередження помилками" лише для того, щоб змусити програму компілюватися, є поганою ідеєю, оскільки тоді ми отримуватимемо попередження щоразу під час компіляції (які ми швидко навчимося ігнорувати), а також ризикуємо проігнорувати попередження про серйозніші проблеми.

C++ підтримує другий спосіб приведення типів, який називається **явним приведенням типів**. Явне приведення типів дозволяє нам (програмістам) явно вказати компілятору перетворити значення з одного типу в інший, і що ми беремо на себе повну відповідальність за результат цього перетворення. Якщо таке перетворення призведе до втрати значення, компілятор не попередить нас про це.

Для виконання явного приведення типів у більшості випадків використовується оператор `static_cast`. Синтаксис статичного приведення виглядає трохи кумедно:
```
static_cast<new_type>(expression)
```
`static_cast` отримує на вхід значення з виразу і повертає це значення, перетворене у тип, визначений `new_type` (наприклад, `int`, `bool`, `char`, `double`).

> [!NOTE]
> Кожного разу, коли ви бачите синтаксис C++ (за винятком препроцесора), який використовує кутові дужки (<>), те, що знаходиться між кутовими дужками, скоріш за все, є типом. Зазвичай так C++ працює з кодом, який потребує параметризованого типу.

Оновимо нашу попередню програму за допомогою `static_cast`:
```cpp
#include <iostream>

void print(int x)
{
	std::cout << x << '\n';
}

int main()
{
	print( static_cast<int>(5.5) ); // explicitly convert double value 5.5 to an int

	return 0;
}
```
Оскільки тепер ми явно запитуємо перетворення значення типу `double` `5.5` у значення типу `int`, компілятор не видасть попередження про можливу втрату даних під час компіляції (це означає, що ми можемо залишити опцію "вважати попередження помилками" увімкненою).
> [!NOTE]
> C++ підтримує інші типи приведення.
## Використання `static_cast` для перетворення `char` в `int`
```cpp
#include <iostream>

int main()
{
    char ch{ 97 }; // 97 is ASCII code for 'a'
    std::cout << ch << '\n';

    return 0;
}
```
Це відбиток:
```
a
```
Якщо ми хочемо вивести інтегральне значення замість `char`, ми можемо зробити це за допомогою `static_cast`, щоб перетворити значення з `char` в `int`:
```cpp
#include <iostream>

int main()
{
    char ch{ 97 }; // 97 is ASCII code for 'a'
    // print value of variable ch as an int
    std::cout << ch << " has value " << static_cast<int>(ch) << '\n';

    return 0;
}
```
Це відбиток:
```
a has value 97
```
Варто зазначити, що аргумент `static_cast` обчислюється як вираз. Коли ми передаємо змінну, ця змінна обчислюється для отримання її значення, а потім це значення перетворюється в новий тип. На саму змінну не впливає приведення її значення до нового типу. У наведеному вище прикладі змінна `ch` залишається символьним типом і зберігає те саме значення, навіть після приведення її до типу `int`.
## Перетворення знаків з використанням `static_cast`
Знакові інтеграли можуть бути перетворені в беззнакові, і навпаки, за допомогою статичного приведення.

Якщо значення, що перетворюється, може бути представлене в типі призначення, то перетворене значення залишиться незмінним (зміниться лише тип). Наприклад:
```cpp
#include <iostream>

int main()
{
    unsigned int u1 { 5 };
    // Convert value of u1 to a signed int
    int s1 { static_cast<int>(u1) };
    std::cout << s1 << '\n'; // prints 5

    int s2 { 5 };
    // Convert value of s2 to an unsigned int
    unsigned int u2 { static_cast<unsigned int>(s2) };
    std::cout << u2 << '\n'; // prints 5

    return 0;
}
```
Це відбиток:
```
5
5
```
Оскільки значення `5` знаходиться в діапазоні як знакових, так і беззнакових типів, значення `5` можна без проблем перетворити до будь-якого типу.

Якщо значення, що перетворюється, не може бути представлене в типі призначення:
- Якщо тип призначення беззнаковий, значення буде обернуто за модулем
- Якщо тип призначення є знаковим, значення визначається реалізацією до C++20, і буде обгорнуте по модулю, починаючи з C++20.
Ось приклад перетворення двох значень, які не можуть бути представлені в цільовому типі (припускаючи, що це 32-розрядні цілі числа):
```cpp
#include <iostream>

int main()
{
    int s { -1 };
    std::cout << static_cast<unsigned int>(s) << '\n'; // prints 4294967295

    unsigned int u { 4294967295 }; // largest 32-bit unsigned int
    std::cout << static_cast<int>(u) << '\n'; // implementation-defined prior to C++20, -1 as of C++20

    return 0;
}
```
Починаючи з C++20, це дає такий результат:
```
4294967295
-1
```
Знакове значення `-1` не може бути представлене як беззнаковий int. Результат за модулем обертається до значення беззнакового типу int `4294967295`.

Значення беззнакового типу int `4294967295` не може бути представлене як знаковий тип int. До C++20 результат визначається реалізацією (але, ймовірно, буде `-1`). Починаючи з C++20, результат буде обертатися по модулю до `-1`.

> [!caution]
> Перетворення беззнакового інтегрального значення у знакове призведе до поведінки, визначеної реалізацією до C++20, якщо значення, що перетворюється, не може бути представлене у знаковому типі.
## `std::int8_t` та `std::uint8_t`, ймовірно, поводяться як символи, а не цілі числа
Більшість компіляторів визначають та обробляють `std::int8_t` та `std::uint8_t` (і відповідні швидкі типи та типи з найменшою фіксованою шириною) ідентично типам `signed char` та `unsigned char` відповідно. Тепер, коли ми з'ясували, що таке символи, ми можемо продемонструвати, де це може бути проблематично:
```cpp
#include <cstdint>
#include <iostream>

int main()
{
    std::int8_t myInt{65};      // initialize myInt with value 65
    std::cout << myInt << '\n'; // you're probably expecting this to print 65

    return 0;
}
```
Оскільки `std::int8_t` описує себе як `int`, ви можете повірити, що наведена вище програма виведе ціле число `65`. Однак на більшості систем ця програма виведе `A` (розглядаючи `myInt` як знаковий символ). Втім, це не гарантується (на деяких системах може бути виведено `65`).

Якщо ви хочете переконатися, що об'єкт `std::int8_t` або `std::uint8_t` обробляється як ціле число, ви можете перетворити його значення до цілого за допомогою `static_cast`:
```cpp
#include <cstdint>
#include <iostream>

int main()
{
    std::int8_t myInt{65};
    std::cout << static_cast<int>(myInt) << '\n'; // will always print 65

    return 0;
}
```
У випадках, коли `std::int8_t` розглядається як `char`, введення з консолі також може викликати проблеми:
```cpp
#include <cstdint>
#include <iostream>

int main()
{
    std::cout << "Enter a number between 0 and 127: ";
    std::int8_t myInt{};
    std::cin >> myInt;

    std::cout << "You entered: " << static_cast<int>(myInt) << '\n';

    return 0;
}
```
Приклад запуску цієї програми:
```
Enter a number between 0 and 127: 35
You entered: 51
```
Ось що відбувається. Коли `std::int8_t` розглядається як `char`, процедури вводу інтерпретують наш ввід як послідовність символів, а не як ціле число. Отже, коли ми вводимо `35`, ми фактично вводимо дві символи, `'3'` і `'5'`. Оскільки об'єкт типу `char` може містити лише один символ, витягується символ `'3'` (символ `'5'` залишається у вхідному потоці для можливого вилучення пізніше). Оскільки символ `'3'` має кодову точку ASCII 51, значення `51` зберігається в `myInt`, який ми потім виводимо як `int`.

На противагу цьому, інші типи з фіксованою шириною завжди будуть виводитись і вводитись як цілі значення.