---
date: 2024-09-06
tags:
  - Процедурне_програмування
  - Налагодження
---
- Оператори налагодження захаращують ваш код.
- Оператори налагодження захаращують вивід вашої програми.
- Налагоджувальні оператори вимагають модифікації вашого коду як для додавання, так і для видалення, що може призвести до появи нових помилок.
- Налагоджувальні оператори повинні бути видалені після того, як ви закінчите з ними, що робить їх не придатними для повторного використання.

Ми можемо пом'якшити деякі з цих проблем. У цьому уроці ми розглянемо деякі основні методи для цього.
## Умовне позначення коду для налагодження
Розглянемо наступну програму, яка містить деякі налагоджувальні оператори:

```cpp
#include <iostream>

int getUserInput()
{
std::cerr << "getUserInput() called\\n";
	std::cout << "Enter a number: ";
	int x{};
	std::cin >> x;
	return x;
}

int main()
{
std::cerr << "main() called\\n";
    int x{ getUserInput() };
    std::cout << "You entered: " << x << '\\n';

    return 0;
}
```

Коли ви закінчите налагоджувальний оператор, вам потрібно буде або видалити його, або закоментувати. Якщо пізніше ви захочете повернути їх назад, вам потрібно буде додати їх назад або розкоментувати.

Один із способів полегшити вимкнення та увімкнення налагодження у вашій програмі - це зробити налагоджувальні оператори умовними за допомогою директив препроцесора:

```cpp
#include <iostream>

#define ENABLE_DEBUG // comment out to disable debugging

int getUserInput()
{
#ifdef ENABLE_DEBUG
std::cerr << "getUserInput() called\\n";
#endif
	std::cout << "Enter a number: ";
	int x{};
	std::cin >> x;
	return x;
}

int main()
{
#ifdef ENABLE_DEBUG
std::cerr << "main() called\\n";
#endif
    int x{ getUserInput() };
    std::cout << "You entered: " << x << '\\n';

    return 0;
}
```

Тепер ми можемо увімкнути налагодження, просто закоментувавши/незакоментувавши `#define` ENABLE_DEBUG. Це дозволяє нам повторно використовувати раніше додані оператори налагодження, а потім просто вимкнути їх, коли ми закінчимо з ними, замість того, щоб видаляти їх з коду. Якби це була багатофайлова програма, `#define` ENABLE_DEBUG містився б у заголовному файлі, який включається у всі файли коду, тому ми можемо коментувати/не коментувати `#define` в одному місці і поширювати його на всі файли коду.

Це вирішує проблему видалення операторів налагодження і пов'язаного з цим ризику, але ціною ще більшого захаращення коду. Іншим недоліком такого підходу є те, що якщо ви зробите друкарську помилку (наприклад, неправильно напишете "DEBUG") або забудете додати заголовок до файлу коду, частково або повністю налагодження для цього файлу може бути не ввімкнено. Отже, хоча це краще, ніж безумовна версія, все ще є місце для вдосконалення.
## Використання логгера
Альтернативним підходом до умовного налагодження за допомогою препроцесора є надсилання налагоджувальної інформації до журналу. Журнал - це послідовний запис подій, що відбулися, зазвичай з позначкою часу. Процес створення журналу називається логуванням. Зазвичай журнали записуються у файл на диску (так званий файл журналу), щоб їх можна було переглянути пізніше. Більшість програм і операційних систем записують файли журналів, які можна використовувати для діагностики проблем, що виникають.

Файли журналів мають кілька переваг. Оскільки інформація, записана у файл журналу, відокремлена від виводу програми, ви можете уникнути безладу, спричиненого змішуванням звичайного виводу і виводу для налагодження. Файли журналів також можна легко надсилати іншим людям для діагностики - тож якщо у когось з користувачів вашого програмного забезпечення виникла проблема, ви можете попросити їх надіслати вам файл журналу, і це може допомогти вам визначити, у чому саме полягає проблема.

C++ містить потік виводу з назвою `std::clog`, який призначено для запису інформації до журналу. Однак, за замовчуванням, `std::clog` пише у стандартний потік помилок (той самий, що і `std::cerr`). І хоча ви можете перенаправити його у файл, це одна з областей, де вам краще використовувати один з багатьох існуючих сторонніх інструментів для ведення журналу. Який саме - вирішувати вам.

Для ілюстрації ми покажемо, як виглядає виведення даних до логера за допомогою логера [plog](https://github.com/SergiusTheBest/plog). Plog реалізовано у вигляді набору заголовних файлів, тому його легко включити куди завгодно, він легкий і простий у використанні.

```cpp
#include <plog/Log.h> // Step 1: include the logger headers
#include <plog/Initializers/RollingFileInitializer.h>
#include <iostream>

int getUserInput()
{
	PLOGD << "getUserInput() called"; // PLOGD is defined by the plog library

	std::cout << "Enter a number: ";
	int x{};
	std::cin >> x;
	return x;
}

int main()
{
	plog::init(plog::debug, "Logfile.txt"); // Step 2: initialize the logger

	PLOGD << "main() called"; // Step 3: Output to the log as if you were writing to the console

	int x{ getUserInput() };
	std::cout << "You entered: " << x << '\\n';

	return 0;
}
```

Ось вихідні дані з наведеного вище логера (у файлі Logfile.txt):

```
2018-12-26 20:03:33.295 DEBUG [4752] [main@19] main() called
2018-12-26 20:03:33.296 DEBUG [4752] [getUserInput@7] getUserInput() called
```

Спосіб включення, ініціалізації та використання логгера залежить від конкретного обраного вами логгера.

Зауважте, що директиви умовної компіляції також не потрібні при використанні цього методу, оскільки більшість логгерів мають можливість зменшити/виключити вивід даних до журналу. Це значно полегшує читання коду, оскільки рядки умовної компіляції додають багато безладу. За допомогою plog можна тимчасово вимкнути запис до журналу, змінивши інструкцію init на наступну:

```cpp
plog::init(plog::none , "Logfile.txt"); // plog::none eliminates writing of most messages, essentially turning logging off
```

> [!NOTE]
> У наступних уроках ми не будемо використовувати plog, тому вам не потрібно турбуватися про його вивчення.
> Якщо ви хочете самостійно скомпілювати наведений вище приклад або використовувати plog у своїх проектах, ви можете скористатися цією інструкцією, щоб встановити його:
> 
> По-перше, завантажте останню версію plog:
> 
> - Загляніте в [plog](https://github.com/SergiusTheBest/plog) репозоторії.
> - Натисніть зелену кнопку "Code" у верхньому правому куті та виберіть "Download zip”
> 
> Потім розархівуйте весь архів кудись(наприклад `somewhere`) на жорсткий диск. Нарешті, для кожного проекту встановіть директорію `somewhere\\plog-master\\include\\` як директорію включення у вашій IDE. Оскільки plog не має попередньо скомпільованих файлів бібліотек, ви можете проігнорувати будь-які кроки, пов'язані з ними. Згенерований файл журналу зазвичай створюється у тому ж каталозі, що і ваш виконуваний файл.

> [!NOTE]
> У великих проектах або проектах, чутливих до продуктивності, можна віддати перевагу швидшим і багатофункціональнішим логгерам, таким як [spdlog](https://github.com/gabime/spdlog).

