---
date: 2024-09-06
tags:
  - Процедурне_програмування
  - Налагодження
---
У попередньому уроці ми розглянули стратегію пошуку проблем шляхом запуску програм і використання здогадок, щоб визначити, в чому полягає проблема. У цьому уроці ми розглянемо деякі основні тактичні прийоми для того, щоб зробити ці здогадки і зібрати інформацію, яка допоможе знайти проблему.
## Тактика налагодження #1: Коментування коду
Почнемо з простого. Якщо ваша програма демонструє помилкову поведінку, один із способів зменшити кількість коду, який вам доведеться переглядати - це закоментувати частину коду і подивитися, чи проблема не зникає. Якщо проблема залишається незмінною, то закоментований код, ймовірно, не є причиною помилки.

Розглянемо наступний код:

```cpp
int main()
{
    getNames(); // ask user to enter a bunch of names
    doMaintenance(); // do some random stuff
    sortNames(); // sort them in alphabetical order
    printNames(); // print the sorted list of names

    return 0;
}
```

Скажімо, програма повинна друкувати імена, які вводить користувач, в алфавітному порядку, але вона друкує їх у зворотному алфавітному порядку. У чому проблема? GetNames неправильно вводить імена? SortNames сортує імена у зворотному порядку? PrintNames друкує імена у зворотному порядку? Це може бути будь-яка з цих причин. Але ми можемо підозрювати, що doMaintenance() не має відношення до проблеми, тому давайте прокоментуємо її.

```cpp
int main()
{
    getNames(); // ask user to enter a bunch of names
//    doMaintenance(); // do some random stuff
    sortNames(); // sort them in alphabetical order
    printNames(); // print the sorted list of names

    return 0;
}
```

Існує три ймовірні варіанти розвитку подій:

- Якщо проблема зникає, значить, причиною проблеми є doMaintenance, і нам слід зосередити свою увагу на ньому.
- Якщо проблема не змінилася (що більш ймовірно), то ми можемо обґрунтовано припустити, що `doMaintenance` не винен, і ми можемо виключити всю функцію з нашого пошуку на даний момент. Це не допоможе нам зрозуміти, чи була проблема до чи після виклику `doMaintenance`, але зменшить кількість коду, який нам доведеться згодом переглянути.
- Якщо коментування doMaintenance призводить до того, що проблема перетворюється на якусь іншу проблему (наприклад, програма перестає друкувати імена), то цілком ймовірно, що doMaintenance робить щось корисне, від чого залежить інший код. У цьому випадку ми, ймовірно, не зможемо визначити, чи проблема у doMaintenance, чи деінде, тому ми можемо відкоментувати doMaintenance і спробувати інший підхід.

> [!caution]
> Не забувайте, які функції ви закоментували, щоб пізніше їх можна було видалити!
> 
> Після внесення багатьох змін, пов'язаних з налагодженням, дуже легко пропустити скасування однієї або двох. Якщо це трапиться, то в результаті ви виправите одну помилку, але внесете інші!
> 
> Наявність хорошої системи контролю версій тут надзвичайно корисна, оскільки ви можете порівняти свій код з основною гілкою, щоб побачити всі зроблені вами зміни, пов'язані з налагодженням (і переконатися, що їх було відкореговано до того, як ви зафіксуєте свої зміни).

> [!NOTE]
> Альтернативним підходом до багаторазового додавання/видалення або коментування/некоментування налагоджувальних операторів є використання сторонніх бібліотек, які дозволять вам залишати налагоджувальні оператори у вашому коді, але компілювати їх у режимі випуску за допомогою макросу препроцесора. [dbg](https://github.com/sharkdp/dbg-macro/blob/master/dbg.h) є однією з таких бібліотек, що містить лише заголовки, яка допомагає полегшити цю задачу (за допомогою макросу препроцесора `DBG_MACRO_DISABLE`).
## Тактика налагодження #2: Перевірка потоку коду
Інша проблема, поширена в більш складних програмах, полягає в тому, що програма викликає функцію занадто багато або занадто мало разів (у тому числі взагалі не викликає).

У таких випадках може бути корисно розмістити оператори у верхній частині функцій, щоб виводити ім'я функції. Таким чином, під час виконання програми ви зможете бачити, які функції викликаються.

> [!NOTE]
> Для виведення інформації з метою налагодження використовуйте `std::cerr` замість `std::cout`. Однією з причин цього є те, що `std::cout` може буферизуватися, а це означає, що може виникнути пауза між тим, коли ви запитуєте `std::cout` вивести інформацію, і тим, коли вона це зробить. Якщо ви виводите дані за допомогою `std::cout`, а потім ваша програма аварійно завершує роботу, це може означати, що `std::cout` ще не встигла вивести дані. Це може ввести вас в оману щодо того, у чому полягає проблема. З іншого боку, `std::cerr` не буферизується, а це означає, що все, що ви надсилаєте до неї, буде виведено негайно. Це допомагає гарантувати, що всі налагоджувальні дані будуть виведені якнайшвидше (за рахунок деякого зниження продуктивності, яке зазвичай не є важливим під час налагодження).
> 
> Використання `std::cerr` також допомагає пояснити, що інформація, яка виводиться, стосується саме випадку помилки, а не нормального стану.

Розглянемо наступну просту програму, яка працює неправильно:

```cpp
#include <iostream>

int getValue()
{
	return 4;
}

int main()
{
    std::cout << getValue << '\n';

    return 0;
}
```

Можливо, вам доведеться вимкнути параметр "Вважати попередження за помилки" для компіляції наведених вище даних.

Хоча ми очікуємо, що програма виведе значення 4, вона повинна вивести це значення:

```
1
```

У Visual Studio (і, можливо, деяких інших компіляторах) замість цього може бути виведено наступне:

```
00101424
```

Додамо до цих функцій декілька налагоджувальних операторів:

```cpp
#include <iostream>

int getValue()
{
std::cerr << "getValue() called\\n";
	return 4;
}

int main()
{
std::cerr << "main() called\n";
    std::cout << getValue << '\n';

    return 0;
}
```

> [!NOTE]
> Під час додавання тимчасових операторів налагодження може бути корисним не робити відступів. Це полегшить їх пошук для подальшого видалення.
> 
> Якщо ви використовуєте clang-формат для форматування вашого коду, він спробує автоматично відступити ці рядки. Ви можете вимкнути автоматичне форматування у такий спосіб:
> 
> ```cpp
> // clang-format off
> std::cerr << "main() called\n";
> // clang-format on
> ```

Тепер, коли ці функції будуть виконуватися, вони виводитимуть свої імена, вказуючи на те, що їх було викликано:

```
main() called
1
```

Тепер ми бачимо, що функція getValue ніколи не викликалася. Мабуть, у коді, який викликає цю функцію, є якась проблема. Давайте подивимося на цей рядок уважніше:

```cpp
std::cout << getValue << '\n';
```

О, подивіться, ми забули про дужки у виклику функції. Вона повинна бути:

```cpp
#include <iostream>

int getValue()
{
std::cerr << "getValue() called\n";
	return 4;
}

int main()
{
std::cerr << "main() called\n";
    std::cout << getValue() << '\n'; // added parenthesis here

    return 0;
}
```

Тепер буде виведено правильний результат

```
main() called
getValue() called
4
```

І ми можемо видалити тимчасові налагоджувальні оператори.
## Тактика налагодження #3: Друк значень
При деяких типах помилок програма може обчислювати або передавати неправильне значення.

Ми також можемо вивести значення змінних (включаючи параметри) або виразів, щоб переконатися, що вони правильні.

Розглянемо наступну програму, яка має додавати два числа, але працює неправильно:

```cpp
#include <iostream>

int add(int x, int y)
{
	return x + y;
}

void printResult(int z)
{
	std::cout << "The answer is: " << z << '\n';
}

int getUserInput()
{
	std::cout << "Enter a number: ";
	int x{};
	std::cin >> x;
	return x;
}

int main()
{
	int x{ getUserInput() };
	int y{ getUserInput() };

	int z{ add(x, 5) };
	printResult(z);

	return 0;
}
```

Ось деякі результати роботи цієї програми:

```
Enter a number: 4
Enter a number: 3
The answer is: 9
```

Це неправильно. Бачите помилку? Навіть у цій короткій програмі її може бути важко помітити. Давайте додамо трохи коду для налагодження наших значень:

```cpp
#include <iostream>

int add(int x, int y)
{
	return x + y;
}

void printResult(int z)
{
	std::cout << "The answer is: " << z << '\n';
}

int getUserInput()
{
	std::cout << "Enter a number: ";
	int x{};
	std::cin >> x;
	return x;
}

int main()
{
	int x{ getUserInput() };
std::cerr << "main::x = " << x << '\n';
	int y{ getUserInput() };
std::cerr << "main::y = " << y << '\n';

	int z{ add(x, 5) };
std::cerr << "main::z = " << z << '\n';
	printResult(z);

	return 0;
}
```

Ось наведений вище результат:

```
Enter a number: 4
main::x = 4
Enter a number: 3
main::y = 3
main::z = 9
The answer is: 9
```

Змінні x та y набувають правильних значень, а змінна z - ні. Проблема має бути між цими двома точками, що робить функцію add ключовим підозрюваним.

Давайте модифікуємо функцію add:

```cpp
#include <iostream>

int add(int x, int y)
{
std::cerr << "add() called (x=" << x <<", y=" << y << ")\n";
	return x + y;
}

void printResult(int z)
{
	std::cout << "The answer is: " << z << '\n';
}

int getUserInput()
{
	std::cout << "Enter a number: ";
	int x{};
	std::cin >> x;
	return x;
}

int main()
{
	int x{ getUserInput() };
std::cerr << "main::x = " << x << '\n';
	int y{ getUserInput() };
std::cerr << "main::y = " << y << '\n';

	int z{ add(x, 5) };
std::cerr << "main::z = " << z << '\n';
	printResult(z);

	return 0;
}
```

Тепер ми отримаємо результат:

```
Enter a number: 4
main::x = 4
Enter a number: 3
main::y = 3
add() called (x=4, y=5)
main::z = 9
The answer is: 9
```

Змінна y мала значення 3, але чомусь наша функція add отримала значення 5 для параметра y. Мабуть, ми передали неправильний аргумент. Звісно, що так:

```cpp
int z{ add(x, 5) };
```

Ось воно. Ми передали літерал 5 замість значення змінної y як аргумент. Це легко виправити, а потім ми можемо видалити налагоджувальні оператори.
## Ще один приклад
Ця програма дуже схожа на попередню, але також працює не так, як повинна:

```cpp
#include <iostream>

int add(int x, int y)
{
	return x + y;
}

void printResult(int z)
{
	std::cout << "The answer is: " << z << '\n';
}

int getUserInput()
{
	std::cout << "Enter a number: ";
	int x{};
	std::cin >> x;
	return --x;
}

int main()
{
	int x{ getUserInput() };
	int y{ getUserInput() };

	int z { add(x, y) };
	printResult(z);

	return 0;
}
```

Якщо ми запустимо цей код, то побачимо наступне:

```
Enter a number: 4
Enter a number: 3
The answer is: 5
```

Щось не так. Але де?

Давайте налагодимо цей код за допомогою налагодження:

```cpp
#include <iostream>

int add(int x, int y)
{
std::cerr << "add() called (x=" << x << ", y=" << y << ")\n";
	return x + y;
}

void printResult(int z)
{
std::cerr << "printResult() called (z=" << z << ")\n";
	std::cout << "The answer is: " << z << '\n';
}

int getUserInput()
{
std::cerr << "getUserInput() called\n";
	std::cout << "Enter a number: ";
	int x{};
	std::cin >> x;
	return --x;
}

int main()
{
std::cerr << "main() called\n";
	int x{ getUserInput() };
std::cerr << "main::x = " << x << '\n';
	int y{ getUserInput() };
std::cerr << "main::y = " << y << '\n';

	int z{ add(x, y) };
std::cerr << "main::z = " << z << '\n';
	printResult(z);

	return 0;
}
```

Тепер запустимо програму ще раз з тими самими вхідними даними:

```
main() called
getUserInput() called
Enter a number: 4
main::x = 3
getUserInput() called
Enter a number: 3
main::y = 2
add() called (x=3, y=2)
main::z = 5
printResult() called (z=5)
The answer is: 5
```

Тепер ми одразу бачимо, що щось йде не так: користувач вводить значення 4, а змінна x у main отримує значення 3. Мабуть, щось йде не так між тим місцем, де користувач вводить значення, і тим, де це значення присвоюється змінній main'а x. Давайте переконаємося, що програма отримує правильне значення від користувача, додавши до функції getUserInput трохи відладочного коду:

```cpp
#include <iostream>

int add(int x, int y)
{
std::cerr << "add() called (x=" << x << ", y=" << y << ")\n";
	return x + y;
}

void printResult(int z)
{
std::cerr << "printResult() called (z=" << z << ")\n";
	std::cout << "The answer is: " << z << '\n';
}

int getUserInput()
{
std::cerr << "getUserInput() called\n";
	std::cout << "Enter a number: ";
	int x{};
	std::cin >> x;
std::cerr << "getUserInput::x = " << x << '\n'; // added this additional line of debugging
	return --x;
}

int main()
{
std::cerr << "main() called\n";
	int x{ getUserInput() };
std::cerr << "main::x = " << x << '\n';
	int y{ getUserInput() };
std::cerr << "main::y = " << y << '\n';

	int z{ add(x, y) };
std::cerr << "main::z = " << z << '\n';
	printResult(z);

	return 0;
}
```

І вихід:

```
main() called
getUserInput() called
Enter a number: 4
getUserInput::x = 4
main::x = 3
getUserInput() called
Enter a number: 3
getUserInput::x = 3
main::y = 2
add() called (x=3, y=2)
main::z = 5
printResult() called (z=5)
The answer is: 5
```

За допомогою цього додаткового рядка налагодження ми бачимо, що користувацьке введення коректно надходить до змінної x getUserInput. Але чомусь змінна x main отримує невірне значення. Проблема має бути десь між цими двома точками. Єдиним винуватцем залишається значення, що повертається з функції getUserInput. Давайте подивимось на цей рядок уважніше.

```cpp
return --x;
```

Хм, це дивно. Що це `--` символ перед x? Ми ще не розглядали його у цих підручниках, тому не хвилюйтеся, якщо ви не знаєте, що він означає. Але навіть якщо ви не знаєте, що він означає, завдяки вашим зусиллям з налагодження, ви можете бути достатньо впевненими, що саме цей рядок несправний `--` а отже, цілком ймовірно, що саме цей - символ спричиняє проблему.

Оскільки ми дійсно хочемо, щоб getUserInput повертала лише значення x, давайте видалимо `--` і подивимося, що станеться:

```cpp
#include <iostream>

int add(int x, int y)
{
std::cerr << "add() called (x=" << x << ", y=" << y << ")\n";
	return x + y;
}

void printResult(int z)
{
std::cerr << "printResult() called (z=" << z << ")\n";
	std::cout << "The answer is: " << z << '\n';
}

int getUserInput()
{
std::cerr << "getUserInput() called\n";
	std::cout << "Enter a number: ";
	int x{};
	std::cin >> x;
std::cerr << "getUserInput::x = " << x << '\n';
	return x; // removed -- before x
}

int main()
{
std::cerr << "main() called\n";
	int x{ getUserInput() };
std::cerr << "main::x = " << x << '\n';
	int y{ getUserInput() };
std::cerr << "main::y = " << y << '\n';

	int z{ add(x, y) };
std::cerr << "main::z = " << z << '\n';
	printResult(z);

	return 0;
}
```

А тепер результат:
```
main() called
getUserInput() called
Enter a number: 4
getUserInput::x = 4
main::x = 4
getUserInput() called
Enter a number: 3
getUserInput::x = 3
main::y = 3
add() called (x=4, y=3)
main::z = 7
printResult() called (z=7)
The answer is: 7
```

Тепер програма працює коректно. Навіть не розуміючи, що саме робив `--`, ми змогли визначити конкретний рядок коду, який спричиняв проблему, а потім виправити її.
## Чому використання операторів друку для налагодження не дуже добре

Хоча додавання налагоджувальних операторів до програм з метою діагностики є поширеною рудиментарною технікою і функціональною (особливо, коли відладчик з якихось причин недоступний), це не так вже й добре з ряду причин:
- Оператори налагодження захаращують ваш код.
- Оператори налагодження захаращують вивід вашої програми.
- Налагоджувальні оператори вимагають модифікації вашого коду як для додавання, так і для видалення, що може призвести до появи нових помилок.
- Налагоджувальні оператори повинні бути видалені після того, як ви закінчите з ними, що робить їх не придатними для повторного використання.

Ми можемо зробити краще. На наступних уроках ми дізнаємося, як це зробити.