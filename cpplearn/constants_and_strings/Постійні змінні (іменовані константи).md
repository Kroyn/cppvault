---
date: 2024-09-15
tags:
  - Константи_та_рядки
  - Процедурне_програмування
---
## Вступ до констант
У програмуванні **константа** - це значення, яке не може змінюватися під час виконання програми.

C++ підтримує два різних типи констант:
- **Іменовані константи** - це постійні значення, які пов'язані з ідентифікатором. Їх також іноді називають символьними константами або просто константами.
- **Літеральні константи** - це константні значення, які не пов'язані з ідентифікатором.
## Типи іменованих констант
У C++ існує три способи визначення іменованої константи:
- Постійні змінні (розглядаються в цьому уроці).
- Об'єктні макроси з текстом підстановки.
- Перераховані константи.
Константні змінні є найпоширенішим типом іменованих констант, тому ми почнемо з них.
## Постійні змінні
Досі всі змінні, які ми розглядали, були непостійними - тобто їхні значення можуть бути змінені в будь-який момент (як правило, шляхом присвоєння нового значення). Наприклад:
```cpp
int main()
{
    int x { 4 }; // x is a non-constant variable
    x = 5; // change value of x to 5 using assignment operator

    return 0;
}
```
Однак є багато випадків, коли корисно визначити змінні зі значеннями, які не можуть бути змінені. Наприклад, розглянемо силу тяжіння Землі (біля поверхні): 9,8 метрів/секунду^2. Навряд чи це зміниться найближчим часом (а якщо зміниться, то у вас, швидше за все, виникнуть більші проблеми, ніж вивчення C++). Визначення цього значення як константи допомагає гарантувати, що це значення не буде випадково змінено. Константи також мають інші переваги, які ми розглянемо у наступних уроках.

Незважаючи на те, що це відомий оксюморон, змінна, значення якої не може бути змінено після ініціалізації, називається **константною змінною**.
## Оголошення константної змінної
Щоб оголосити константну змінну, ми розміщуємо ключове слово `const` поруч з типом об'єкта:
```cpp
const double gravity { 9.8 };  // preferred use of const before type
int const sidesInSquare { 4 }; // "east const" style, okay but not preferred
```
Хоча C++ приймає кваліфікатор `const` як до, так і після типу, набагато поширенішим є використання `const` перед типом, оскільки це краще відповідає стандартній англійській мові, де модифікатори стоять перед об'єктом, який модифікується (наприклад, "a green ball", а не "a ball green").
> [!NOTE]
> Через те, як компілятор розбирає більш складні оголошення, деякі розробники вважають за краще розміщувати `const` після типу (тому що це трохи більш послідовно). Цей стиль називається "східна константа". Хоча у цього стилю є прихильники (і деякі розумні зауваження), він не набув значного поширення.

> [!tip]
> Поставте const перед типом (тому що так прийнято робити).
## Змінні Const мають бути ініціалізовані
Змінні типу `const` мають бути ініціалізовані під час їх визначення, після чого це значення не може бути змінене за допомогою присвоєння:
```cpp
int main()
{
    const double gravity; // error: const variables must be initialized
    gravity = 9.9;        // error: const variables can not be changed

    return 0;
}
```
Зверніть увагу, що константні змінні можуть бути ініціалізовані з інших змінних (у тому числі неконстантних):
```cpp
#include <iostream>

int main()
{
    std::cout << "Enter your age: ";
    int age{};
    std::cin >> age;

    const int constAge { age }; // initialize const variable using non-const value

    age = 5;      // ok: age is non-const, so we can change its value
    constAge = 6; // error: constAge is const, so we cannot change its value

    return 0;
}
```
У наведеному вище прикладі ми ініціалізуємо константну змінну `constAge` неконстантною змінною `age`. Оскільки age все ще не є константною змінною, ми можемо змінити її значення. Однак, оскільки `constAge` є константною, ми не можемо змінити її значення після ініціалізації.
> [!NOTE]
> Ініціалізатор константної змінної може бути непостійним значенням.
> 
## Іменування константних змінних
Існує декілька різних угод про імена, які використовуються для константних змінних.

Програмісти, які перейшли з C, часто надають перевагу підкресленим іменам у верхньому регістрі для константних змінних (наприклад, `EARTH_GRAVITY`). У C++ більш поширеним є використання інтеркапсульованих імен з префіксом 'k' (наприклад, `kEarthGravity`).

Однак, оскільки змінні типу `const` поводяться як звичайні змінні (за винятком того, що їм не можна присвоювати значення), немає жодної причини, чому вони потребують спеціальної угоди про імена. Тому ми надаємо перевагу використанню тієї самої угоди про імена, яку ми використовуємо для неконстантних змінних (наприклад, `earthGravity`).
## Параметри функції Const
Параметри функції можна зробити константами за допомогою ключового слова `const`:
```cpp
#include <iostream>

void printInt(const int x)
{
    std::cout << x << '\n';
}

int main()
{
    printInt(5); // 5 will be used as the initializer for x
    printInt(6); // 6 will be used as the initializer for x

    return 0;
}
```
Зверніть увагу, що ми не надали явного ініціалізатора для нашого параметра `const` `x` - значення аргументу у виклику функції буде використано як ініціалізатор для `x`.

Оголошення параметра функції константним потребує допомоги компілятора, щоб гарантувати, що значення параметра не зміниться всередині функції. Однак у сучасній C++ ми не робимо параметри-значення `const`, тому що нам, як правило, байдуже, чи змінює функція значення параметра (оскільки це лише копія, яка все одно буде знищена в кінці роботи функції). Ключове слово `const` також додає невелику кількість непотрібного безладу до прототипу функції.
> [!tip]
> Не використовуйте `const` при передачі за значенням.

Пізніше в цьому циклі уроків ми поговоримо про два інші способи передачі аргументів у функції: передача за посиланням та передача за адресою. При використанні будь-якого з цих способів важливим є правильне використання const.
## Значення, що повертаються константами
Значення, що повертається функцією, також можна зробити константою:
```cpp
#include <iostream>

const int getValue()
{
    return 5;
}

int main()
{
    std::cout << getValue() << '\n';

    return 0;
}
```
Для фундаментальних типів кваліфікатор `const` у типі, що повертається, просто ігнорується (компілятор може згенерувати попередження).

Для інших типів (які ми розглянемо пізніше) зазвичай немає сенсу повертати об'єкти типу const за значенням, оскільки вони є тимчасовими копіями, які все одно будуть знищені. Повернення значення const також може перешкоджати певним видам оптимізації компілятора (пов'язаним із семантикою переміщення), що може призвести до зниження продуктивності.
> [!NOTE]
> Не використовуйте `const` при поверненні за значенням.
## Об'єктні макроси з текстом підстановки
```cpp
#include <iostream>

#define MY_NAME "Alex"

int main()
{
    std::cout << "My name is: " << MY_NAME << '\n';

    return 0;
}
```
Коли препроцесор обробляє файл, що містить цей код, він замінить `MY_NAME` (у рядку 7) на `"Alex"`. Зверніть увагу, що `MY_NAME` - це ім'я, а текст заміни - константне значення, тому об'єктні макроси з текстом заміни також називаються константами.
## Надавати перевагу константним змінним перед макросами препроцесора
Чому б не використовувати макроси препроцесора для іменованих констант? Існує (принаймні) три основні проблеми.

Найбільша проблема полягає у тому, що макроси не підпорядковуються звичайним правилам визначення області видимості у C++. Після того, як макрос оголошено `#defined`, усі наступні входження імені макросу у поточному файлі будуть замінені. Якщо це ім'я використовується деінде, ви отримаєте заміну макросу там, де ви цього не хотіли. Це, найімовірніше, призведе до дивних помилок компіляції. Наприклад:
```cpp
#include <iostream>

void someFcn()
{
// Even though gravity is defined inside this function
// the preprocessor will replace all subsequent occurrences of gravity in the rest of the file
#define gravity 9.8
}

void printGravity(double gravity) // including this one, causing a compilation error
{
    std::cout << "gravity: " << gravity << '\n';
}

int main()
{
    printGravity(3.71);

    return 0;
}
```
Під час компіляції GCC видає таку помилку:
```
prog.cc:7:17: error: expected ',' or '...' before numeric constant
    5 | #define gravity 9.8
      |                 ^~~
prog.cc:10:26: note: in expansion of macro 'gravity'
```
По-друге, за допомогою макросів часто складніше налагоджувати код. Хоча у вихідному коді буде вказано ім'я макросу, компілятор і налагоджувач ніколи не побачать макрос, оскільки його вже було замінено до запуску. Багато налагоджувачів не можуть перевірити значення макросу і часто мають обмежені можливості при роботі з макросами.

По-третє, заміна макросу поводиться інакше, ніж все інше у C++. В результаті можна легко припуститися ненавмисних помилок.

Константні змінні не мають жодної з цих проблем: вони підпорядковуються звичайним правилам визначення області видимості, їх бачать компілятор і відладчик, і вони поводяться послідовно.
> [!tip]
> Надавайте перевагу константним змінним перед об'єктними макросами з текстом підстановки.
## Використання константних змінних у багатофайловій програмі
У багатьох програмах задану іменовану константу потрібно використовувати в усьому коді (а не лише в одному файлі). Це можуть бути фізичні або математичні константи, які не змінюються (наприклад, число Пі або число Авогадро), або специфічні для програми значення "налаштування" (наприклад, коефіцієнти тертя або гравітації). Замість того, щоб перевизначати їх щоразу, коли вони потрібні, краще оголосити їх один раз у центральному місці і використовувати, де це потрібно. Таким чином, якщо вам коли-небудь знадобиться змінити їх, вам потрібно буде змінити їх лише в одному місці.
## Кваліфікатори типу
**Кваліфікатор типу** (іноді його скорочено називають **кваліфікатором**) - це ключове слово, яке застосовується до типу і змінює поведінку цього типу. `const`, що використовується для оголошення константної змінної, **називається кваліфікатором типу const** (або **скорочено кваліфікатором const**).

Починаючи з версії C++23, у C++ є лише два кваліфікатори типу: `const` та `volatile`.
> [!NOTE]
> Кваліфікатор `volatile` використовується для того, щоб вказати компілятору, що значення об'єкта може бути змінено у будь-який момент. Цей рідковживаний кваліфікатор відключає певні типи оптимізацій.
> 
> У технічній документації кваліфікатори `const` та `volatile` часто називають **cv-кваліфікаторами**. Наступні терміни також використовуються у стандарті C++:
> - **Cv-некваліфікований тип** - це тип без кваліфікаторів типу (наприклад, `int`).
> - **Cv-кваліфікований тип** - це тип з одним або більше кваліфікаторами типу (наприклад, `const int`).
> - **Можливо cv-кваліфікований тип** - це тип, який може бути cv-некваліфікованим або cv-кваліфікованим.
> 
> Ці терміни мало використовуються за межами технічної документації, тому вони наведені тут для довідки, а не як щось, що вам потрібно запам'ятати.