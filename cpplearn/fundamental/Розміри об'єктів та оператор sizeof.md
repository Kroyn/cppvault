---
date: 2024-09-07
tags:
  - Процедурне_програмування
  - Фундаментальні_типи_дани
---
Вступ до основних типів даних, пам'ять на сучасних комп'ютерах, як правило, організовано у вигляді блоків розміром у байт, кожен байт пам'яті має унікальну адресу. До цього моменту було корисно думати про пам'ять як про купу комірчин або поштових скриньок, куди ми можемо записувати і отримувати інформацію, а про змінні - як про імена для доступу до цих комірчин або поштових скриньок.

Однак ця аналогія не зовсім коректна в одному відношенні - більшість об'єктів насправді займають більше 1 байта пам'яті. Один об'єкт може використовувати 1, 2, 4, 8 або навіть більше послідовних адрес пам'яті. Обсяг пам'яті, який використовує об'єкт, залежить від його типу даних.

Оскільки ми зазвичай звертаємося до пам'яті через імена змінних (а не безпосередньо через адреси пам'яті), компілятор може приховати від нас деталі того, скільки байт використовує даний об'єкт. Коли ми звертаємося до деякої змінної x, компілятор знає, скільки байт даних потрібно отримати (на основі типу змінної x), і може впоратися з цим завданням за нас.

Незважаючи на це, є кілька причин, чому корисно знати, скільки пам'яті використовує об'єкт.

По-перше, чим більше пам'яті використовує об'єкт, тим більше інформації він може зберігати.

Один біт може містити 2 можливих значення: 0 або 1:

|bit 0|
|---|
|0|
|1|
2 біти можуть містити 4 можливих значення:

|bit 0|bit 1|
|---|---|
|0|0|
|0|1|
|1|0|
|1|1|
3 біти можуть містити 8 можливих значень:

| bit 0 | bit 1 | bit 2 |
| ----- | ----- | ----- |
| 0     | 0     | 0     |
| 0     | 0     | 1     |
| 0     | 1     | 0     |
| 0     | 1     | 1     |
| 1     | 0     | 0     |
| 1     | 0     | 1     |
| 1     | 1     | 0     |
| 1     | 1     | 1     |

Узагальнюючи, об'єкт з n бітами (де n - ціле число) може зберігати 2n (2 в степені n, також часто записується 2^n) унікальних значень. Таким чином, об'єкт розміром 8 біт може зберігати 28 (256) різних значень. Об'єкт, який використовує 2 байти, може зберігати 2^16 (65536) різних значень!

Таким чином, розмір об'єкта накладає обмеження на кількість унікальних значень, які він може зберігати - об'єкти, які використовують більше байт, можуть зберігати більшу кількість унікальних значень. Ми розглянемо це далі, коли будемо говорити про цілі числа.

По-друге, комп'ютери мають обмежений обсяг вільної пам'яті. Кожного разу, коли ми визначаємо об'єкт, невелика частина цієї вільної пам'яті використовується до тих пір, поки об'єкт існує. Оскільки сучасні комп'ютери мають багато пам'яті, цей вплив зазвичай незначний. Однак для програм, які потребують великої кількості об'єктів або даних (наприклад, гра, яка рендерить мільйони полігонів), різниця між використанням об'єктів розміром 1 байт і 8 байт може бути значною.

> [!NOTE]
> Програмісти-початківці часто занадто багато уваги приділяють оптимізації свого коду, щоб використовувати якомога менше пам'яті. У більшості випадків це дає незначну різницю. Зосередьтеся на написанні коду, який можна підтримувати, і оптимізуйте тільки тоді, коли і де вигода буде суттєвою.
## Фундаментальні розміри типів даних
Очевидним наступним питанням є "скільки пам'яті займають змінні різних типів даних?".

Як не дивно, стандарт C++ не визначає точний розмір (в бітах) для жодного з фундаментальних типів. char повинен мати розмір 1 байт, але не робиться припущення, що байт має 8 біт. Інтегральні типи мають мінімальний розмір (у бітах), але можуть бути більшими.

У цій серії уроків ми розглядатимемо їх у спрощеному вигляді, роблячи деякі розумні припущення, які, як правило, є вірними для сучасних архітектур:
- Байт складається з 8 біт.
- Пам'ять має байтову адресацію, тому найменший об'єкт має розмір 1 байт.
- Підтримка плаваючої точки відповідає стандарту IEEE-754.
- Ми працюємо на 32-бітній або 64-бітній архітектурі.

З огляду на це, ми можемо констатувати наступне:

|Category|Type|Minimum Size|Typical Size|Note|
|---|---|---|---|---|
|Boolean|bool|1 byte|1 byte||
|character|char|1 byte|1 byte|always exactly 1 byte|
||wchar_t|1 byte|2 or 4 bytes||
||char8_t|1 byte|1 byte||
||char16_t|2 bytes|2 bytes||
||char32_t|4 bytes|4 bytes||
|integer|short|2 bytes|2 bytes||
||int|2 bytes|4 bytes||
||long|4 bytes|4 or 8 bytes||
||long long|8 bytes|8 bytes||
|floating point|float|4 bytes|4 bytes||
||double|8 bytes|8 bytes||
||long double|8 bytes|8, 12, or 16 bytes||
|pointer|std::nullptr_t|4 bytes|4 or 8 bytes||

> [!NOTE]
> Для максимальної портативності не слід припускати, що змінні більші за вказаний мінімальний розмір.
> 
> Крім того, якщо ви хочете припустити, що тип має певний розмір (наприклад, int має щонайменше 4 байти), ви можете використовувати `static_assert`, щоб змусити компілятор зупинити збірку, якщо вона скомпільована на архітектурі, де це припущення не відповідає дійсності.

> [!NOTE]
> Якщо ви використовуєте C++ у системі, яка не відповідає нашим припущенням, або вам просто цікаво, ви можете знайти більше інформації про те, що говорить стандарт C++ про мінімальний розмір різних типів [тут](https://en.cppreference.com/w/cpp/language/types).
## Оператор sizeof
Для визначення розміру типів даних на конкретній машині в C++ передбачено оператор `sizeof`. **Оператор** **sizeof** - це унарний оператор, який отримує тип або змінну і повертає її розмір у байтах. Ви можете скомпілювати і запустити наступну програму, щоб дізнатися розмір деяких типів даних:

```cpp
#include <iomanip> // for std::setw (which sets the width of the subsequent output)
#include <iostream>

int main()
{
    std::cout << std::left; // left justify output
    std::cout << std::setw(16) << "bool:" << sizeof(bool) << " bytes\\n";
    std::cout << std::setw(16) << "char:" << sizeof(char) << " bytes\\n";
    std::cout << std::setw(16) << "short:" << sizeof(short) << " bytes\\n";
    std::cout << std::setw(16) << "int:" << sizeof(int) << " bytes\\n";
    std::cout << std::setw(16) << "long:" << sizeof(long) << " bytes\\n";
    std::cout << std::setw(16) << "long long:" << sizeof(long long) << " bytes\\n";
    std::cout << std::setw(16) << "float:" << sizeof(float) << " bytes\\n";
    std::cout << std::setw(16) << "double:" << sizeof(double) << " bytes\\n";
    std::cout << std::setw(16) << "long double:" << sizeof(long double) << " bytes\\n";

    return 0;
}
```

Ось результат роботи авторської машини:

```
bool:           1 bytes
char:           1 bytes
short:          2 bytes
int:            4 bytes
long:           4 bytes
long long:      8 bytes
float:          4 bytes
double:         8 bytes
long double:    8 bytes
```

Ваші результати можуть відрізнятися залежно від компілятора, архітектури комп'ютера, операційної системи, налаштувань компіляції (32-розрядна чи 64-розрядна) тощо...

Спроба використання `sizeof` для неповного типу (наприклад, `void`) призведе до помилки компіляції.

Ви також можете використовувати оператор `sizeof` з іменем змінної:

```cpp
#include <iostream>

int main()
{
    int x{};
    std::cout << "x is " << sizeof(x) << " bytes\\n";

    return 0;
}
```

> [!NOTE]
> `sizeof` не включає динамічно виділену пам'ять, що використовується об'єктом.
## Фундаментальна продуктивність типів даних
На сучасних машинах об'єкти фундаментальних типів даних працюють швидко, тому продуктивність при використанні або копіюванні цих типів зазвичай не повинна викликати занепокоєння.

> [!NOTE]
> Можна припустити, що типи, які використовують менше пам'яті, будуть швидшими за типи, які використовують більше пам'яті. Це не завжди так. Процесори часто оптимізовані для обробки даних певного розміру (наприклад, 32 біти), і типи, які відповідають цьому розміру, можуть оброблятися швидше. На такій машині 32-бітовий int може бути швидшим за 16-бітовий short або 8-бітовий char.

