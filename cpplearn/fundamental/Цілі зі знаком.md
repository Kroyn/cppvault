---
date: 2024-09-07
tags:
  - Процедурне_програмування
  - Фундаментальні_типи_дани
---
Ціле число - це інтегральний тип, який може представляти додатні та від'ємні цілі числа, включаючи 0 (наприклад, -2, -1, 0, 1, 2). У C++ є 4 основних фундаментальних цілих типи, доступних для використання:

|Type|Minimum Size|Note|
|---|---|---|
|short int|16 bits||
|int|16 bits|Typically 32 bits on modern architectures|
|long int|32 bits||
|long long int|64 bits||
Ключова відмінність між різними типами цілих чисел полягає в тому, що вони мають різний розмір - більші цілі числа можуть містити більші числа.

> [!NOTE]
> C++ гарантує лише те, що цілі числа матимуть певний мінімальний розмір, а не те, що вони матимуть конкретний розмір, та оператор `sizeof` для отримання інформації про те, як визначити розмір кожного типу на вашій машині.

> [!NOTE]
> Технічно типи `bool` і `char` вважаються цілими типами (оскільки вони зберігають свої значення як цілі числа).

## Цілі зі знаком
Записуючи від'ємні числа в повсякденному житті, ми використовуємо знак "мінус". Наприклад, -3 означає "від'ємне 3". Ми також зазвичай розпізнаємо +3 як "додатне 3" (хоча за загальноприйнятими правилами ми зазвичай опускаємо префікс "плюс").

Ця властивість числа бути додатним, від'ємним або нульовим називається знаком числа.

За замовчуванням цілі числа у C++ є знаковими, що означає, що знак числа зберігається як частина значення. Таким чином, ціле число зі знаком може містити як додатні, так і від'ємні числа (і 0).

У цьому уроці ми зосередимося на цілих числах зі знаком. Про беззнакові числа (які можуть містити лише невід'ємні числа) ми поговоримо у наступному уроці.
## Визначення знакових цілих чисел
Нижче наведено найкращий спосіб визначення чотирьох типів цілих чисел зі знаком:

```cpp
short s;      // prefer "short" instead of "short int"
int i;
long l;       // prefer "long" instead of "long int"
long long ll; // prefer "long long" instead of "long long int"
```

Хоча короткі імена `short int`, `long int` або `long long int` працюватимуть, ми надаємо перевагу коротким іменам для цих типів (які не використовують суфікс `int`). Крім того, що додавання суфікса `int` ускладнює введення, тип складніше відрізнити від змінних типу `int`. Це може призвести до помилок, якщо випадково пропустити модифікатор `short` або `long`.

Цілі типи також можуть мати необов'язкове ключове слово sign, яке за домовленістю зазвичай ставиться перед назвою типу:

```cpp
signed short ss;
signed int si;
signed long sl;
signed long long sll;
```

Однак це ключове слово не слід використовувати, оскільки воно є надлишковим, оскільки за замовчуванням цілі числа мають знак.

> [!tip]
> Надавайте перевагу типам скорочень, які не використовують суфікс int або префікс signed.
## Цілочисельні діапазони зі знаком
Як ви дізналися з попереднього розділу, змінна з n бітами може мати 2n можливих значень. Але які саме значення? Ми називаємо множину конкретних значень, які може приймати тип даних, діапазоном. Діапазон цілочисельної змінної визначається двома факторами: її розміром (у бітах) і тим, чи є вона знаковою.

За визначенням, 8-бітове ціле число зі знаком має діапазон від -128 до 127. Це означає, що ціле число зі знаком може безпечно зберігати будь-яке ціле значення між -128 і 127 (включно).

> [!NOTE]
> Час обчислень: 8-бітне ціле число містить 8 біт. 28 дорівнює 256, тому 8-бітне ціле число може мати 256 можливих значень. Існує 256 можливих значень від -128 до 127 включно.
> 
> 7 бітів використовуються для зберігання величини числа, а 1 біт використовується для зберігання знаку.

Нижче наведено таблицю, яка містить діапазон знакових цілих чисел різного розміру:

|Size/Type|Range|
|---|---|
|8 bit signed|-128 to 127|
|16 bit signed|-32,768 to 32,767|
|32 bit signed|-2,147,483,648 to 2,147,483,647|
|64 bit signed|-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807|
Для тих, хто схильний до математики, n-розрядна змінна зі знаком має діапазон від -(2n-1) до 2n-1-1.

Для тих, хто не схильний до математики... використовуйте таблицю :)
## Переповнення
Що станеться, якщо спробувати присвоїти значення 140 8-бітному цілому зі знаком? Це число знаходиться за межами діапазону, який може містити 8-бітне ціле число зі знаком. Для представлення числа 140 потрібно 9 бітів (8 бітів величини і 1 біт знаку), але у 8-бітному знаковому числі доступно лише 8 бітів (7 бітів величини і 1 біт знаку).

Стандарт C++20 містить таке загальне твердження: "Якщо під час обчислення виразу результат не є математично визначеним або не знаходиться в діапазоні допустимих значень для його типу, поведінка є невизначеною". У розмовній мові це називається переповненням.

Отже, присвоєння значення 140 8-бітному цілому зі знаком призведе до невизначеної поведінки.

Якщо арифметична операція (наприклад, додавання або множення) намагається створити значення за межами діапазону, який може бути представлений, це називається цілочисельним переповненням (або арифметичним переповненням). Для цілих чисел зі знаком цілочисельне переповнення призведе до невизначеної поведінки.

```cpp
#include <iostream>

int main()
{
    // assume 4 byte integers
    int x { 2'147'483'647 }; // the maximum value of a 4-byte signed integer
    std::cout << x << '\\n';

    x = x + 1; // integer overflow, undefined behavior
    std::cout << x << '\\n';

    return 0;
}
```

На авторській машині надруковано вищезгадане:

```
2147483647
-2147483648
```

Однак, оскільки другий вивід є результатом невизначеної поведінки, значення, що виводиться, може відрізнятися на вашому комп'ютері.

Загалом, переповнення призводить до втрати інформації, що майже ніколи не є бажаним. Якщо є підозра, що об'єкту може знадобитися зберігати значення, яке виходить за межі його діапазону, використовуйте тип з більшим діапазоном!
## Ділення цілих чисел
При діленні двох цілих чисел C++ працює так, як ви очікуєте, коли частка є цілим числом:

```cpp
#include <iostream>

int main()
{
    std::cout << 20 / 4 << '\\n';
    return 0;
}
```

Це дає очікуваний результат:

```
5
```

Але давайте подивимося, що відбувається, коли ціле ділення призводить до дробового результату:

```cpp
#include <iostream>

int main()
{
    std::cout << 8 / 5 << '\\n';
    return 0;
}
```

Це призводить до неочікуваного результату:

```
1
```

При виконанні ділення двох цілих чисел (так зване цілочисельне ділення) C++ завжди видає цілий результат. Оскільки цілі числа не можуть містити дробові значення, будь-яка дробова частина просто відкидається (не округляється!).

Якщо поглянути на приклад вище, то 8 / 5 дає значення 1.6. Дробова частина (0,6) відкидається, і залишається результат 1. Або ми можемо сказати, що 8 / 5 дорівнює 1 з остачею 3. Залишок відкидається, і залишається 1.

Аналогічно, -8 / 5 призводить до значення -1.

> [!caution]
> Будьте обережні при діленні цілих чисел, оскільки ви втратите всі дробові частини частки. Однак, якщо це те, чого ви хочете, цілочисельне ділення безпечно використовувати, оскільки результати передбачувані.