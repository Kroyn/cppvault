---
date: 2024-09-07
tags:
  - Процедурне_програмування
  - Фундаментальні_типи_дани
---
## Цілі числа без знаку
C++ також підтримує цілі числа без знаку. **Цілі числа без знаку** - це цілі числа, які можуть містити лише невід'ємні цілі числа.
## Визначення цілих беззнакових чисел
Для визначення цілого числа без знаку використовується ключове слово `unsigned`. За домовленістю, воно розміщується перед типом:
```cpp
unsigned short us;
unsigned int ui;
unsigned long ul;
unsigned long long ull;
```
## Беззнаковий цілочисельний діапазон
1-байтне ціле число без знаку має діапазон від 0 до 255. Порівняйте це з діапазоном 1-байтового цілого зі знаком від -128 до 127. Обидва типи можуть зберігати 256 різних значень, але цілі зі знаком використовують половину свого діапазону для від'ємних чисел, тоді як цілі без знаку можуть зберігати додатні числа, що вдвічі більше.

Ось таблиця, яка показує діапазон для цілих без знаку:

|Size/Type|Range|
|---|---|
|8 bit unsigned|0 to 255|
|16 bit unsigned|0 to 65,535|
|32 bit unsigned|0 to 4,294,967,295|
|64 bit unsigned|0 to 18,446,744,073,709,551,615|
N-розрядна беззнакова змінна має діапазон від 0 до (2^n)-1.

Коли не потрібні від'ємні числа, цілі без знаку добре підходять для мереж і систем з невеликою пам'яттю, оскільки цілі без знаку можуть зберігати більше додатних чисел, не займаючи додаткової пам'яті.
## Пам'ятайте про підписані та непідписані умови
Програмісти-початківці іноді плутають знакові та беззнакові числа. Простий спосіб запам'ятати різницю: щоб відрізнити від'ємні числа від додатних, ми використовуємо від'ємний знак. Якщо знак відсутній, ми вважаємо, що число додатне. Отже, ціле число зі знаком (ціле число зі знаком) може відрізняти додатні числа від від'ємних. Ціле число без знака (беззнакове число) передбачає, що всі значення додатні.
## Переповнення беззнакового цілого числа
Що станеться, якщо ми спробуємо зберегти число `280` (для представлення якого потрібно 9 біт) у 1-байтовому (8-бітному) беззнаковому цілому? Відповідь - переповнення.

> [!NOTE]
> Як не дивно, стандарт C++ явно говорить, що "обчислення з беззнаковими операндами ніколи не може призвести до переповнення". Це суперечить загальному консенсусу у програмуванні, що цілочисельне переповнення охоплює як знакові, так і беззнакові випадки використання (цитата). Враховуючи, що більшість програмістів вважатимуть це переповненням, ми будемо називати його переповненням, незважаючи на твердження стандарту C++ про протилежне.

Якщо беззнакове значення виходить за межі діапазону, воно ділиться на одиницю, більшу за найбільше число типу, і лише залишок зберігається.

Число `280` занадто велике, щоб поміститися у нашому 1-байтовому діапазоні від 0 до 255. На 1 більше за найбільше число типу - 256. Тому ми ділимо 280 на 256, отримуючи 1 залишок 24. Залишок від 24 і є тим, що зберігається.

Ось ще один спосіб подумати про те ж саме. Будь-яке число, більше за найбільше число, що може бути представлене типом, просто "обертається" (іноді це називають "обертанням по модулю"). `255` знаходиться в діапазоні 1-байтового цілого, тому `255` підійде. `256`, однак, знаходиться за межами діапазону, тому воно обертається до значення `0`. `257` обертається до значення `1`. `280` обертається до значення `24`.

Давайте розглянемо це на прикладі 2-байтових шортів:
```cpp
#include <iostream>

int main()
{
    unsigned short x{ 65535 }; // largest 16-bit unsigned value possible
    std::cout << "x was: " << x << '\n';

    x = 65536; // 65536 is out of our range, so we get modulo wrap-around
    std::cout << "x is now: " << x << '\n';

    x = 65537; // 65537 is out of our range, so we get modulo wrap-around
    std::cout << "x is now: " << x << '\n';

    return 0;
}
```
Яким, на вашу думку, буде результат цієї програми?

(Зауваження: якщо ви спробуєте скомпілювати вищенаведену програму, ваш компілятор видасть попередження про переповнення або усічення - вам потрібно буде вимкнути опцію "обробляти попередження як помилки", щоб запустити програму)
```
x was: 65535
x is now: 0
x is now: 1
```
Також можна обертати у зворотному напрямку. 0 можна представити у вигляді 2-байтового цілого числа без знаку, тому все гаразд. Значення -1 не може бути представлено, тому воно обертається до верхньої межі діапазону, отримуючи значення 65535. -2 обертається до 65534. І так далі.
```cpp
#include <iostream>

int main()
{
    unsigned short x{ 0 }; // smallest 2-byte unsigned value possible
    std::cout << "x was: " << x << '\n';

    x = -1; // -1 is out of our range, so we get modulo wrap-around
    std::cout << "x is now: " << x << '\n';

    x = -2; // -2 is out of our range, so we get modulo wrap-around
    std::cout << "x is now: " << x << '\n';

    return 0;
}
```
```
x was: 0
x is now: 65535
x is now: 65534
```
Вищенаведений код викликає попередження у деяких компіляторах, оскільки компілятор виявляє, що цілочисельний літерал знаходиться за межами діапазону для даного типу. Якщо ви все одно хочете скомпілювати код, тимчасово вимкніть опцію "Вважати попередження за помилки".

> [!NOTE]
> Багато відомих багів в історії відеоігор сталося через поведінку з беззнаковими цілими. В аркадній грі Donkey Kong неможливо пройти далі 22 рівня через помилку переповнення, яка залишає користувачеві недостатньо бонусного часу для завершення рівня.
> 
> У комп'ютерній грі Civilization Ганді був відомий тим, що часто першим застосовував ядерну зброю, що суперечило його очікуваній пасивній натурі. У гравців була теорія, що спочатку агресивність Ганді була встановлена на 1, але якби він обрав демократичний уряд, то отримав би модифікатор агресії -2 (зменшивши поточне значення агресії на 2). Це призведе до того, що його агресія переповниться до 255, що зробить його максимально агресивним! Однак нещодавно Сід Мейєр (автор гри) пояснив, що насправді це не так.
## Суперечка щодо беззнакових чисел
Багато розробників (і деякі великі компанії-розробники, такі як Google) вважають, що розробникам слід уникати цілих чисел без знаку.

Це здебільшого пов'язано з двома типами поведінки, які можуть спричинити проблеми.

По-перше, зі значеннями зі знаком потрібно трохи попрацювати, щоб випадково вийти за межі діапазону, оскільки ці значення далекі від 0. З беззнаковими числами набагато легше вийти за межі діапазону, оскільки нижня межа діапазону дорівнює 0, що є близьким до того, де знаходиться більшість наших значень.

Розглянемо віднімання двох беззнакових чисел, наприклад, 2 і 3:
```cpp
#include <iostream>

// assume int is 4 bytes
int main()
{
	unsigned int x{ 2 };
	unsigned int y{ 3 };

	std::cout << x - y << '\n'; // prints 4294967295 (incorrect!)

	return 0;
}
```
Ми з вами знаємо, що `2 - 3` дорівнює `-1`, але `-1` не може бути представлено як ціле число без знаку, тому ми отримуємо переповнення і наступний результат:
```
4294967295
```
Інша поширена небажана ситуація виникає, коли ціле беззнакове число багаторазово зменшується на 1, доки не спробує зменшитися до від'ємного числа. Ви побачите приклад цього, коли буде введено цикли.

По-друге, що більш підступно, неочікувана поведінка може виникнути при змішуванні цілих чисел зі знаком і без знаку. У C++, якщо математична операція (наприклад, арифметика або порівняння) має одне ціле число зі знаком і одне ціле число без знаку, то ціле число зі знаком зазвичай буде перетворено на ціле число без знаку. Таким чином, результат буде беззнаковим. Наприклад:
```cpp
#include <iostream>

// assume int is 4 bytes
int main()
{
	unsigned int u{ 2 };
	signed int s{ 3 };

	std::cout << u - s << '\n'; // 2 - 3 = 4294967295

	return 0;
}
```
Це також дає результат:
```
4294967295
```
У цьому випадку, якби `u` було беззнаковим, було б отримано правильний результат. Але оскільки `u` є беззнаковим (що легко не помітити), `s` перетворюється у беззнаковий тип, і результат (`-1`) обробляється як беззнакове значення. Оскільки `-1` не може зберігатися у беззнаковому значенні, ми отримуємо переповнення і неочікувану відповідь.

Ось ще один приклад, де все йде не так:
```cpp
#include <iostream>

// assume int is 4 bytes
int main()
{
    signed int s { -1 };
    unsigned int u { 1 };

    if (s < u) // -1 is implicitly converted to 4294967295, and 4294967295 < 1 is false
        std::cout << "-1 is less than 1\n";
    else
        std::cout << "1 is less than -1\n"; // this statement executes

    return 0;
}
```
Це відбиток:
```
1 is less than -1
```
Ця програма добре сформована, компілюється і логічно послідовна на око. Але вона виводить неправильну відповідь. І хоча ваш компілятор повинен попередити вас про невідповідність знакових/беззнакових чисел у цьому випадку, ваш компілятор також видасть ідентичні попередження для інших випадків, які не страждають від цієї проблеми (наприклад, коли обидва числа додатні), що ускладнює визначення того, коли існує справжня проблема.

Крім того, є й інші проблемні випадки, які складно виявити. Розглянемо деякі з них:
```cpp
#include <iostream>

// assume int is 4 bytes
void doSomething(unsigned int x)
{
    // Run some code x times

    std::cout << "x is " << x << '\n';
}

int main()
{
    doSomething(-1);

    return 0;
}
```
Автор `doSomething()` очікував, що хтось буде викликати цю функцію лише з додатними числами. Але той, хто викликає функцію, передає `-1` - очевидно, що це помилка, але вона все одно зроблена. Що відбувається у цьому випадку?

Знаковий аргумент `-1` неявно перетворюється на беззнаковий параметр. Значення -1 не входить до діапазону беззнакових чисел, тому воно обертається до `4294967295`. Після цього ваша програма починає працювати як навіжена.

Ще більш проблематичним є те, що запобігти цьому може бути важко. Якщо ви не налаштували ваш компілятор на агресивну видачу попереджень про знакові/беззнакові перетворення (а ви повинні це зробити), ваш компілятор, ймовірно, навіть не поскаржиться на це.

Всі ці проблеми зустрічаються часто, призводять до неочікуваної поведінки і їх важко виявити навіть за допомогою автоматизованих інструментів, призначених для виявлення проблемних випадків.

Враховуючи вищесказане, дещо суперечливою найкращою практикою, яку ми будемо відстоювати, є уникнення використання беззнакових типів за винятком особливих обставин.

> [!tip]
> Надавайте перевагу знаковим числам перед беззнаковими для зберігання величин (навіть тих, що мають бути невід'ємними) та математичних операцій. Уникайте змішування знакових і беззнакових чисел.

> [!NOTE]
> Додатковий матеріал на підтримку вищезазначених рекомендацій (також охоплює спростування деяких поширених контраргументів):
> 1. [Interactive C++ panel](https://www.youtube.com/watch?v=_nrly6PH6NU) (дивиться 9:48-13:08, 41:06-45:26, і 1:02:50-1:03:15)
> 2. [Subscripts and sizes should be signed](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1428r0.pdf) (від Б'ярна Строуструпа, творця C+)
> 3. [Unsigned integers from the libtorrent blog](https://blog.libtorrent.org/2016/05/unsigned-integers/)
## Тож коли слід використовувати беззнакові числа?
У C++ все ще є кілька випадків, коли можна/необхідно використовувати беззнакові числа.

По-перше, беззнаковим числам надається перевага при роботі з бітовими маніпуляціями (описано у главі O - з великої літери, а не з "0"). Вони також корисні, коли потрібна чітко визначена поведінка обходу (корисна у деяких алгоритмах, таких як шифрування та генерація випадкових чисел).

По-друге, використання беззнакових чисел все ще неминуче у деяких випадках, головним чином тих, що пов'язані з індексацією масивів. Ми поговоримо про це докладніше в уроках, присвячених масивам та індексації масивів.

Також зауважте, що якщо ви розробляєте для вбудованої системи (наприклад, Arduino) або іншого контексту з обмеженим процесором/пам'яттю, використання беззнакових чисел є більш поширеним і прийнятним (а в деяких випадках і неминучим) з міркувань продуктивності.