---
date: 2024-09-07
tags:
  - Процедурне_програмування
  - Фундаментальні_типи_дани
---
У попередніх уроках, присвячених цілим числам, ми з'ясували, що C++ лише гарантує, що цілочисельні змінні матимуть мінімальний розмір - але вони можуть бути більшими, залежно від цільової системи.
## Чому розмір цілочисельних змінних не фіксований?
Коротка відповідь полягає в тому, що це пов'язано з ранніми днями C, коли комп'ютери були повільними і продуктивність була першочерговим завданням. У мові C було вирішено навмисно залишити розмір цілого числа відкритим, щоб реалізатори компілятора могли вибрати розмір int, який буде найкраще працювати на цільовій архітектурі комп'ютера.
## Хіба це не відстій?
За сучасними стандартами - так. Для програміста трохи смішно мати справу з типами, які мають невизначені діапазони.

Розглянемо тип int. Мінімальний розмір для int - 2 байти, але в сучасних архітектурах часто зустрічається і 4 байти.

Якщо ви вважаєте, що int має розмір 4 байти, оскільки це найбільш ймовірно, то ваша програма, ймовірно, буде працювати неправильно на архітектурах, де int насправді має розмір 2 байти (оскільки ви, ймовірно, будете зберігати значення, які вимагають 4 байти, у змінній розміром 2 байти, що спричинить переповнення або невизначену поведінку).

Якщо для забезпечення максимальної сумісності припустити, що int має розмір лише 2 байти, то діапазон значень, які ви можете безпечно зберігати в int, буде значно обмежено. А в системах, де int насправді має розмір 4 байти, ви не використовуєте і половини пам'яті, виділеної для int.

> [!NOTE]
> У більшості випадків ми створюємо лише невелику кількість змінних типу int за один раз, і вони, як правило, знищуються в кінці функції, в якій їх було створено. У таких випадках втрата 2 байт пам'яті на змінну не викликає занепокоєння (більшою проблемою є обмежений діапазон). Однак у випадках, коли наша програма виділяє тисячі або мільйони змінних типу int, втрата 2 байт пам'яті на змінну може мати значний вплив на загальне використання пам'яті програми.
## Цілі числа фіксованої ширини
Щоб вирішити вищезгадані проблеми, C99 визначив набір **цілих чисел фіксованої ширини** (у заголовку `stdint.h`), які гарантовано мають однаковий розмір на будь-якій архітектурі.

Ці числа визначено наступним чином:

|Name|Type|Range|Notes|
|---|---|---|---|
|std::int8_t|1 byte signed|-128 to 127|Treated like a signed char on many systems. See note below.|
|std::uint8_t|1 byte unsigned|0 to 255|Treated like an unsigned char on many systems. See note below.|
|std::int16_t|2 byte signed|-32,768 to 32,767||
|std::uint16_t|2 byte unsigned|0 to 65,535||
|std::int32_t|4 byte signed|-2,147,483,648 to 2,147,483,647||
|std::uint32_t|4 byte unsigned|0 to 4,294,967,295||
|std::int64_t|8 byte signed|-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807||
|std::uint64_t|8 byte unsigned|0 to 18,446,744,073,709,551,615|
C++ офіційно прийняв ці числа фіксованої ширини як частину C++11. Доступ до них можна отримати, включивши заголовок `<cstdint>`, де вони визначені у просторі імен `std`. Ось приклад:
```cpp
#include <cstdint> // for fixed-width integers
#include <iostream>

int main()
{
    std::int16_t i{5};
    std::cout << i << '\n';
    return 0;
}
```
Цілі числа з фіксованою шириною мають два недоліки, які зазвичай збільшуються.

По-перше, цілі фіксованої ширини не гарантовано визначені на всіх архітектурах. Вони існують лише у системах, де існують фундаментальні типи, що відповідають їхній ширині та мають певне двійкове представлення. Ваша програма не зможе скомпілюватись на будь-якій архітектурі, яка не підтримує ціле фіксованої ширини, що використовується у вашій програмі. Однак, враховуючи, що більшість сучасних архітектур стандартизовано для 8/16/32/64-бітних змінних, це навряд чи буде проблемою, якщо тільки вашу програму не потрібно переносити на якісь екзотичні мейнфрейми або вбудовані архітектури.

По-друге, якщо ви використовуєте ціле число фіксованої ширини, воно може бути повільнішим за ширший тип на деяких архітектурах. Наприклад, якщо вам потрібно ціле число, яке гарантовано має бути 32-бітним, ви можете вирішити використовувати `std::int32_t`, але ваш процесор може виявитися швидшим в обробці 64-бітних цілих чисел. Однак, якщо ваш процесор може обробляти певний тип швидше, це не означає, що ваша програма буде швидшою в цілому - сучасні програми часто обмежуються використанням пам'яті, а не процесора, і більший обсяг пам'яті може сповільнити вашу програму більше, ніж прискорити її за рахунок швидшої обробки на процесорі. Важко сказати, не провівши вимірювання.
## Швидкі та найменші цілі числа
Щоб допомогти усунути вищезгадані недоліки, C++ також визначає дві альтернативні множини цілих чисел, які гарантовано будуть визначені.

Швидкі типи (`std::int_fast#_t` та `std::uint_fast#_t`) забезпечують найшвидший знаковий/беззнаковий цілий тип з шириною не менше # біт (де # = 8, 16, 32 або 64). Наприклад, `std::int_fast32_t` надасть вам найшвидший знаковий цілочисельний тип шириною не менше 32 біт. Під найшвидшим ми маємо на увазі цілочисельний тип, який може бути оброблений процесором найшвидше.

Найменші типи (`std::int_least#_t` та `std::uint_least#_t`) надають найменший знаковий/беззнаковий цілий тип шириною не менше # біт (де # = 8, 16, 32 або 64). Наприклад, `std::uint_least32_t` надасть вам найменший беззнаковий цілий тип шириною щонайменше 32 біти.

Ось приклад з авторської Visual Studio (32-бітної консольної програми):
```cpp
#include <cstdint> // for fast and least types
#include <iostream>

int main()
{
	std::cout << "least 8:  " << sizeof(std::int_least8_t) * 8 << " bits\n";
	std::cout << "least 16: " << sizeof(std::int_least16_t) * 8 << " bits\n";
	std::cout << "least 32: " << sizeof(std::int_least32_t) * 8 << " bits\n";
	std::cout << '\n';
	std::cout << "fast 8:  " << sizeof(std::int_fast8_t) * 8 << " bits\n";
	std::cout << "fast 16: " << sizeof(std::int_fast16_t) * 8 << " bits\n";
	std::cout << "fast 32: " << sizeof(std::int_fast32_t) * 8 << " bits\n";

	return 0;
}
```
Це дало результат:
```
least 8:  8 bits
least 16: 16 bits
least 32: 32 bits

fast 8:  8 bits
fast 16: 32 bits
fast 32: 32 bits
```
Ви можете бачити, що `std::int_least16_t` має розмір 16 біт, тоді як `std::int_fast16_t` насправді має 32 біти. Це пов'язано з тим, що на машині автора 32-розрядні цілі числа обробляються швидше, ніж 16-розрядні.

Однак, у цих швидких і найменших цілих чисел є свої недоліки: По-перше, не так багато програмістів насправді використовують їх, і недостатня обізнаність може призвести до помилок. По-друге, швидкі типи можуть призвести до марнотратства пам'яті, оскільки їх фактичний розмір може бути більшим, ніж вказано у назві. Більш серйозно, оскільки розмір швидких/найменших цілих чисел може змінюватися, цілком можливо, що ваша програма може демонструвати різну поведінку на архітектурах, де вони мають різні розміри. Наприклад:
```cpp
#include <cstdint>
#include <iostream>

int main()
{
    std::uint_fast16_t sometype { 0 };
    sometype = sometype - 1; // intentionally overflow to invoke wraparound behavior

    std::cout << sometype << '\n';

    return 0;
}
```
Цей код дасть різні результати залежно від того, чи std::uint_fast16_t має розмір 16, 32 або 64 біти.

Важко сказати, де ваша програма може працювати не так, як очікується, доки ви не протестуєте її на таких архітектурах.
## `std::int8_t` та `std::uint8_t`, ймовірно, поводяться як символи, а не цілі числа
Через недогляд у специфікації C++ більшість компіляторів визначають і обробляють `std::int8_t` і `std::uint8_t` (і відповідні швидкі типи з найменшою фіксованою шириною) ідентично типам `signed char` і `unsigned char` відповідно. Це означає, що ці 8-розрядні типи можуть (або не можуть) поводитися інакше, ніж решта типів фіксованої ширини, що може призвести до помилок. Така поведінка є системно-залежною, тому програма, яка працює коректно на одній архітектурі, може не компілюватися або працювати некоректно на іншій архітектурі.

Для зберігання інтегральних значень, де важливим є конкретний розмір, зазвичай краще уникати `std::int8_t` та `std::uint8_t` (і пов'язаних з ними типів fast та least), а замість них використовувати `std::int16_t` або `std::uint16_t`.

> [!caution]
> 8-розрядні цілі типи з фіксованою шириною часто сприймаються як символи, а не як цілі значення (і це може відрізнятися в різних системах). У більшості випадків надавайте перевагу 16-бітним цілим типам з фіксованою шириною.
## Кращі практики для інтегральних типів
Враховуючи різні плюси і мінуси фундаментальних інтегральних типів, інтегральних типів фіксованої ширини, найшвидших/найменших інтегральних типів, а також знакових/беззнакових задач, існує мало консенсусу щодо найкращих інтегральних практик.

Наша позиція полягає в тому, що краще бути коректним, ніж швидким, і краще помилитися під час компіляції, ніж під час виконання. Тому, якщо вам потрібен інтегральний тип з фіксованим розміром, ми рекомендуємо уникати швидких/малих типів на користь типів з фіксованою шириною. Якщо пізніше ви виявите необхідність підтримки платформи, для якої певний тип фіксованої ширини не компілюється, ви можете вирішити, як перенести вашу програму (і ретельно перетестувати) в цей момент.

> [!tip]
> - Надавайте перевагу `int`, коли розмір цілого числа не має значення (наприклад, число завжди вкладається в діапазон 2-байтового цілого зі знаком) і змінна є короткоживучою (наприклад, знищується в кінці функції). Наприклад, якщо ви просите користувача ввести свій вік або рахуєте від 1 до 10, не має значення, чи int має 16 або 32 біт (числа помістяться в будь-якому випадку). Це охоплює переважну більшість випадків, з якими ви, ймовірно, зіткнетеся.
> - Надавайте перевагу `std::int#_t`, коли зберігаєте кількість, яка потребує гарантованого діапазону.
> - Надавайте перевагу `std::uint#_t` для маніпуляцій з бітами або там, де потрібна чітко визначена поведінка з обгортанням.
> Уникайте наступного, коли це можливо:
> - `short` та `long` - використовуйте тип з фіксованою шириною.
> - Беззнакові типи для зберігання кількості.
> - 8-розрядні цілі типи з фіксованою шириною.
> - Найшвидші та найменш завантажені типи фіксованої ширини.
> - Будь-які цілі фіксованої ширини, визначені компілятором - наприклад, у Visual Studio визначено `__int8`, `__int16` і т.д...
## Що таке std::size_t?
Розглянемо наступний код:
```cpp
#include <iostream>

int main()
{
    std::cout << sizeof(int) << '\n';

    return 0;
}
```
На авторській машині це друкується:
```
4
```
Досить просто, чи не так? Ми можемо зробити висновок, що оператор sizeof повертає ціле значення - але якого цілого типу це значення? Ціле число? Короткий? Відповідь полягає у тому, що `sizeof` повертає значення типу `std::size_t`. `std::size_t` - це псевдонім для визначеного реалізацією беззнакового інтегрального типу. Іншими словами, компілятор вирішує, чи є `std::size_t` беззнаковим `int`, беззнаковим `long`, беззнаковим `long long` і т.д...

> [!NOTE]
> `std::size_t `- це псевдонім для визначеного реалізацією беззнакового цілого типу. Він використовується у стандартній бібліотеці для представлення розміру в байтах або довжини об'єктів.

`std::size_t` визначається у різних заголовках. Якщо вам потрібно використовувати `std::size_t`, найкращим заголовком буде `<cstddef>`, оскільки він містить найменшу кількість інших визначених ідентифікаторів.

Наприклад:
```cpp
#include <cstddef>  // for std::size_t
#include <iostream>

int main()
{
    int x { 5 };
    std::size_t s { sizeof(x) }; // sizeof returns a value of type std::size_t, so that should be the type of s
    std::cout << s << '\n';

    return 0;
}
```

> [!tip]
> Якщо ви явно використовуєте `std::size_t` у своєму коді, `#include` один із заголовків, що визначає `std::size_t` (ми рекомендуємо `<cstddef>`).
> 
> Використання sizeof не потребує заголовка (навіть якщо вона повертає значення з типом `std::size_t`).

Подібно до того, як ціле число може мати різний розмір залежно від системи, `std::size_t` також може мати різний розмір. `std::size_t` гарантовано має бути беззнаковим і щонайменше 16 біт, але на більшості систем він буде еквівалентний ширині адреси програми. Тобто, для 32-бітних програм `std::size_t` зазвичай буде 32-бітним цілим беззнаковим числом, а для 64-бітних програм `std::size_t` зазвичай буде 64-бітним цілим беззнаковим числом.
## `std::size_t` накладає верхню межу на розмір об'єкту, що створюється в системі `Необов'язково`

> [!NOTE]
> Цей розділ є необов'язковим для прочитання. Не є критично важливим, щоб ви розуміли те, що написано далі.

Цікаво, що ми можемо використовувати оператор `sizeof` (який повертає значення типу `std::size_t`) для запиту розміру самого `std::size_t`:
```cpp
#include <cstddef> // for std::size_t
#include <iostream>

int main()
{
	std::cout << sizeof(std::size_t) << '\n';

	return 0;
}
```
Скомпільований як 32-розрядний (4 байти) консольний додаток на системі автора, він друкує:
```
4
```
`sizeof` повинна мати можливість повертати розмір об'єкта у байтах як значення типу `std::size_t`. Таким чином, розмір об'єкта в байтах не може бути більшим за найбільше значення, яке може вмістити `std::size_t`.

Стандарт [C++20](https://isocpp.org/files/papers/N4860.pdf#subsection.6.8.2) ([basic.compound] 1.8.2) говорить: "Побудова типу таким чином, що кількість байт у його об'єктному представленні перевищує максимальне значення, яке можна представити у типі `std::size_t` (17.2), є погано сформованим".

Якби можна було створити більший об'єкт, функція `sizeof` не змогла б повернути його розмір у байтах, оскільки він був би за межами діапазону, який може утримувати `std::size_t`. Отже, створення об'єкта з розміром (у байтах) більшим за найбільше значення, яке може вмістити об'єкт типу `std::size_t`, є неприпустимим (і призведе до помилки компіляції).

Наприклад, припустимо, що у нашій системі `std::size_t` має розмір 4 байти. Беззнаковий 4-байтовий інтегральний тип має діапазон від `0` до `4,294,967,295`. Отже, 4-байтовий об'єкт `std::size_t` може містити будь-яке значення від `0` до `4,294,967,295`. Будь-який об'єкт з розміром в байтах від `0` до `4,294,967,295` може отримати свій розмір у значенні типу `std::size_t`, тому це нормально. Однак, якщо розмір об'єкта буде більшим за `4,294,967,295` байт, функція `sizeof` не зможе точно повернути розмір цього об'єкта, оскільки значення буде за межами діапазону `std::size_t`. Отже, у цій системі неможливо створити об'єкт, розмір якого перевищує `4,294,967,295` байт.

Коли 8-розрядні та 16-розрядні програми були нормою, це накладало значні обмеження на розмір об'єктів. В еру 32-бітних і 64-бітних додатків це рідко виникає, а отже, вам не варто про це турбуватися.

> [!NOTE]
> Розмір `std::size_t` накладає сувору математичну верхню межу на розмір об'єкта. На практиці, найбільший об'єкт, який можна створити, може бути меншим за цю величину (можливо, значно меншим).
> 
> Деякі компілятори обмежують найбільший створюваний об'єкт половиною максимального значення `std::size_t` (пояснення цього можна знайти [тут](https://stackoverflow.com/a/42428240)).
> 
> Інші фактори також можуть відігравати певну роль, наприклад, обсяг суміжної пам'яті, доступної для розподілу на вашому комп'ютері.