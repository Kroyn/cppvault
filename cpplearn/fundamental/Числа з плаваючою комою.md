---
date: 2024-09-08
tags:
  - Процедурне_програмування
  - Фундаментальні_типи_дани
---
Цілі числа чудово підходять для підрахунку цілих чисел, але іноді нам потрібно зберігати дуже великі (додатні або від'ємні) числа або числа з дробовою складовою. Змінна з плаваючою комою - це змінна, яка може зберігати число з дробовою частиною, наприклад, 4320.0, -3.33 або 0.01226. Плаваюча частина назви "з плаваючою комою" вказує на те, що десяткова кома може "плавати" - тобто підтримувати змінну кількість цифр до і після десяткової крапки.

> [!NOTE]
> При написанні чисел з плаваючою комою у вашому коді, десятковий роздільник повинен бути десятковою крапкою. Якщо ви з країни, де використовується десяткова кома, вам доведеться звикнути до використання десяткової крапки.

Існує три стандартні типи даних з плаваючою комою: `float` одинарної точності, `double` подвійної точності та `long double` розширеної точності. Як і у випадку з цілими числами, C++ не визначає фактичний розмір цих типів.

Типи даних з плаваючою комою завжди є знаковими (можуть містити додатні та від'ємні значення).

|Category|Type|Typical Size|
|---|---|---|
|floating point|float|4 bytes|
||double|8 bytes|
||long double|8, 12, or 16 bytes|
У сучасних архітектурах представлення чисел з плаваючою комою для `float` і `double` майже завжди відповідає двійковому формату IEEE 754 (створеному [Вільямом Каханом](https://en.wikipedia.org/wiki/William_Kahan)). У цьому форматі розмір числа з плаваючою комою становить 4 байти, а розмір числа з подвійною комою - 8 байт.

`long double` - це дивний тип даних. Залежно від реалізації, він може бути еквівалентним подвійному типу IEEE 754 (8 байт), може бути 16-байтовим значенням двійкового формату IEEE 754 або 80-бітним (зазвичай розширеним до 12 байт) значенням двійкового формату, відмінного від IEEE 754. Ми рекомендуємо уникати довгих подвоєнь.

> [!NOTE]
> У цих уроках з плаваючою комою передбачається, що ваш компілятор використовує формат IEEE 754 для чисел типу float і double.

> [!NOTE]
> Ви можете перевірити, чи використовують ваші типи з плаваючою комою формат IEEE 754, за допомогою наступного коду:

```cpp
#include <iostream>
#include <limits>

int main()
{
    std::cout << std::numeric_limits<float>::is_iec559 << '\n';
    std::cout << std::numeric_limits<double>::is_iec559 << '\n';
    std::cout << std::numeric_limits<long double>::is_iec559 << '\n';
}
```

Ось деякі визначення змінних з плаваючою комою:
```cpp
float fValue;
double dValue;
long double ldValue;
```
Використовуючи літерали з плаваючою комою, завжди вказуйте принаймні один десятковий знак (навіть якщо він дорівнює 0). Це допоможе компілятору зрозуміти, що число є числом з плаваючою комою, а не цілим.
```cpp
int a { 5 };      // 5 means integer
double b { 5.0 }; // 5.0 is a floating point literal (no suffix means double type by default)
float c { 5.0f }; // 5.0 is a floating point literal, f suffix means float type

int d { 0 }       // 0 is an integer
double e { 0.0 }  // 0.0 is a double
```
Зауважте, що за замовчуванням літерали з плаваючою комою мають тип double. Для позначення літералів типу float використовується суфікс f.

> [!tip]
> Завжди переконуйтеся, що тип ваших літералів відповідає типу змінних, яким вони присвоюються або використовуються для ініціалізації. Інакше відбудеться непотрібне перетворення, яке може призвести до втрати точності.
## Друк чисел з плаваючою комою
Тепер розглянемо цю просту програму:
```cpp
#include <iostream>

int main()
{
	std::cout << 5.0 << '\n';
	std::cout << 6.7f << '\n';
	std::cout << 9876543.21 << '\n';

	return 0;
}
```
Результати цієї, здавалося б, простої програми можуть вас здивувати:
```
5
6.7
9.87654e+06
```
У першому випадку `std::cout` вивела `5`, хоча ми ввели `5.0`. За замовчуванням `std::cout` не виводить дробову частину числа, якщо вона дорівнює `0`.

У другому випадку число виводиться так, як ми й очікували.

У третьому випадку він надрукував число в науковій нотації
## Діапазон з плаваючою комою
Припускаючи представлення за стандартом IEEE 754 для 4, 8 та 16-байтових представлень:

|Size|Range|Precision|
|---|---|---|
|4 bytes|±1.18 x 10-38 to ±3.4 x 1038 and 0.0|6-9 significant digits, typically 7|
|8 bytes|±2.23 x 10-308 to ±1.80 x 10308 and 0.0|15-18 significant digits, typically 16|
|80-bits (typically uses 12 or 16 bytes)|±3.36 x 10-4932 to ±1.18 x 104932 and 0.0|18-21 significant digits|
|16 bytes|±3.36 x 10-4932 to ±1.18 x 104932 and 0.0|33-36 significant digits|

> [!NOTE]
> 80-розрядний тип з плаваючою комою є певною мірою історичною аномалією. На сучасних процесорах він зазвичай реалізується з використанням 12 або 16 байт (що є більш природним розміром для обробки процесорами).
> 
> Може здатися трохи дивним, що 80-бітовий тип з плаваючою комою має той самий діапазон, що і 16-байтовий тип з плаваючою комою. Це тому, що вони мають однакову кількість бітів, призначених для експоненти - однак, 16-байтне число може зберігати більше значущих цифр.
## Точність з плаваючою комою
Розглянемо дріб 1/3. Десятковий запис цього числа - 0.33333333333333... з трьома цифрами, що йдуть до нескінченності. Якби ви писали це число на аркуші паперу, ваша рука в якийсь момент втомилася б, і ви б перестали писати. І число, яке б у вас залишилося, було б близьким до 0.333333333333.... (де 3 прямує до нескінченності), але не зовсім.

На комп'ютері для зберігання числа нескінченної точності потрібна нескінченна пам'ять, а ми зазвичай маємо лише 4 або 8 байт на одне значення. Ця обмеженість пам'яті означає, що числа з плаваючою комою можуть зберігати лише певну кількість значущих цифр - будь-які додаткові значущі цифри або втрачаються, або представляються неточно. Число, яке фактично зберігається, може бути близьким до бажаного, але не точним. Ми покажемо приклад цього у наступному розділі.

Точність типу з плаваючою комою визначає, скільки значущих цифр він може представити без втрати інформації.

Кількість розрядів точності типу з плаваючою комою залежить як від розміру (плаваючі числа мають меншу точність, ніж подвійні), так і від конкретного значення, що зберігається (деякі значення можуть бути представлені точніше, ніж інші).

Наприклад, число з плаваючою комою має точність від 6 до 9 цифр. Це означає, що число з плаваючою комою може точно представляти будь-яке число з 6 значущими цифрами. Число з 7 до 9 значущих цифр може бути представлено точно або не точно, залежно від конкретного значення. А число з точністю більше 9 знаків точно не буде представлено точно.

Подвійні значення мають від 15 до 18 значущих цифр, причому більшість подвійних значень мають щонайменше 16 значущих цифр. Довге подвійне значення має мінімальну точність 15, 18 або 33 значущі цифри, залежно від того, скільки байт воно займає.

> [!NOTE]
> Тип з плаваючою комою може точно відображати лише певну кількість значущих цифр. Використання значення з більшою кількістю значущих цифр, ніж мінімальна, може призвести до неточного збереження значення.
## Виведення значень з плаваючою комою
При виведенні чисел з плаваючою комою `std::cout` має точність за замовчуванням 6 - тобто вона припускає, що всі змінні з плаваючою комою мають значення лише до 6 цифр (мінімальна точність числа з плаваючою комою), і, отже, буде усікати все, що після цього.

У наведеній нижче програмі показано, як `std::cout` усікає до 6 цифр:
```cpp
#include <iostream>

int main()
{
    std::cout << 9.87654321f << '\n';
    std::cout << 987.654321f << '\n';
    std::cout << 987654.321f << '\n';
    std::cout << 9876543.21f << '\n';
    std::cout << 0.0000987654321f << '\n';

    return 0;
}
```
Ця програма виводить результати:
```
9.87654
987.654
987654
9.87654e+006
9.87654e-005
```
Зверніть увагу, що кожне з них має лише 6 значущих цифр.

Також зауважте, що у деяких випадках `std::cout` перемикається на виведення чисел у науковій системі числення. Залежно від компілятора, показник степеня зазвичай буде доповнено до мінімальної кількості цифр. Не бійтеся, `9.87654e+006` - це те саме, що і `9.87654e6`, просто з деякими додатковими 0. Мінімальна кількість цифр у показнику степеня залежить від компілятора (Visual Studio використовує 3, інші компілятори використовують 2 відповідно до стандарту C99).

Ми можемо перевизначити точність за замовчуванням, яку показує `std::cout`, за допомогою функції маніпулятора виводу `std::setprecision()`. Маніпулятори виводу змінюють спосіб виведення даних і визначаються у заголовку `iomanip`.
```cpp
#include <iomanip> // for output manipulator std::setprecision()
#include <iostream>

int main()
{
	    std::cout << std::setprecision(17); // show 17 digits of precision
    std::cout << 3.33333333333333333333333333333333333333f <<'\n'; // f suffix means float
    std::cout << 3.33333333333333333333333333333333333333 << '\n'; // no suffix means double

    return 0;
}
```
Вийде:
```
3.3333332538604736
3.3333333333333335
```
Оскільки ми встановили точність у 17 цифр за допомогою `std::setprecision()`, кожне з наведених вище чисел виводиться з 17 цифрами. Але, як ви можете бачити, числа, звичайно, не мають точності до 17 цифр! А оскільки числа з плаваючою комою є менш точними, ніж числа з подвійною комою, вони мають більшу похибку.

> [!NOTE]
> Маніпулятори виводу (і маніпулятори вводу) є липкими - тобто, якщо ви їх встановили, вони залишаться встановленими.
> 
> Єдиним винятком є `std::setw`. Деякі операції вводу-виводу скидають `std::setw`, тому `std::setw` слід використовувати щоразу, коли це потрібно.

Проблеми з точністю впливають не лише на дробові числа, вони впливають на будь-яке число з надто великою кількістю значущих цифр. Розглянемо велике число:
```cpp
#include <iomanip> // for std::setprecision()
#include <iostream>

int main()
{
    float f { 123456789.0f }; // f has 10 significant digits
    std::cout << std::setprecision(9); // to show 9 digits in f
    std::cout << f << '\n';

    return 0;
}
```
Виходе:
```
123456792
```
`123456792` більше за `123456789`. Значення `123456789.0` має `10` значущих цифр, але значення з плаваючою комою зазвичай мають `7` значущих цифр (а результат `123456792` має точність лише до `7` значущих цифр). Ми втратили деяку точність! Коли точність втрачається через те, що число не може бути збережене точно, це називається помилкою округлення.

Отже, потрібно бути обережним при використанні чисел з плаваючою комою, які вимагають більшої точності, ніж можуть зберігати змінні.

> [!tip]
> Віддавайте перевагу `double` поплавку перед `float`, якщо тільки не бракує місця, оскільки недостатня точність поплавка часто призводить до неточностей.
## Помилки округлення ускладнюють порівняння з плаваючою комою
З числами з плаваючою комою складно працювати через неочевидні відмінності між двійковими (як зберігаються дані) і десятковими (як ми думаємо) числами. Розглянемо дріб 1/10. У десятковій системі числення це легко представити як 0.1, і ми звикли думати про 0.1 як про число, яке легко представити з 1 значущою цифрою. Однак у двійковій системі числення десяткове значення 0.1 представляється нескінченною послідовністю: 0.00011001100110011... Через це, коли ми присвоюємо 0.1 числу з плаваючою комою, ми стикаємося з проблемами точності.

Ви можете побачити наслідки цього у наступній програмі:
```cpp
#include <iomanip> // for std::setprecision()
#include <iostream>

int main()
{
    double d{0.1};
    std::cout << d << '\n'; // use default cout precision of 6
    std::cout << std::setprecision(17);
    std::cout << d << '\n';

    return 0;
}
```
Це виходить:
```
0.1
0.10000000000000001
```
У верхньому рядку `std::cout` виводить `0.1`, як ми і очікували.

У нижньому рядку, де `std::cout` показує нам `17` цифр з точністю, ми бачимо, що d насправді не зовсім дорівнює `0.1`! Це тому, що через обмежену пам'ять `double` довелося урізати наближення. В результаті ми отримуємо число з точністю до `16` значущих цифр (що гарантує тип `double`), але це число не дорівнює `0.1`. Помилки округлення можуть зробити число або трохи меншим, або трохи більшим, залежно від того, де відбувається усічення.

Помилки округлення можуть мати неочікувані наслідки:
```cpp
#include <iomanip> // for std::setprecision()
#include <iostream>

int main()
{
    std::cout << std::setprecision(17);

    double d1{ 1.0 };
    std::cout << d1 << '\n';

    double d2{ 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 }; // should equal 1.0
    std::cout << d2 << '\n';

    return 0;
}
```
```
1
0.99999999999999989
```
Хоча ми могли б очікувати, що `d1` і `d2` повинні бути рівними, ми бачимо, що це не так. Якщо ми порівняємо `d1` і `d2` у програмі, то, ймовірно, програма не буде працювати належним чином. Оскільки числа з плаваючою комою мають тенденцію бути неточними, порівняння чисел з плаваючою комою є загалом проблематичним - ми обговоримо цю тему докладніше

Останнє зауваження щодо помилок округлення: математичні операції (такі як додавання та множення) мають тенденцію до зростання помилок округлення. Тому, хоча 0.1 має похибку округлення в 17-му значущому розряді, коли ми додаємо 0.1 десять разів, похибка округлення перекочувала в 16-й значущий розряд. Продовження операцій призведе до того, що ця помилка буде ставати все більш значущою.

> [!NOTE]
> Помилки округлення виникають, коли число не може бути збережене точно. Це може статися навіть з простими числами, такими як 0.1. Тому помилки округлення можуть траплятися і трапляються постійно. Помилки округлення - це не виняток, а норма. Ніколи не вважайте, що ваші числа з плаваючою комою є точними.
> 
> З цього правила випливає висновок: будьте обережні з використанням чисел з плаваючою комою для фінансових або валютних даних.

> [!NOTE]
> Щоб дізнатися більше про те, як числа з плаваючою комою зберігаються у двійковому форматі, скористайтеся інструментом [float.exposed](https://float.exposed/0x3dcccccd).
> Щоб дізнатися більше про числа з плаваючою комою та помилки округлення, на сайтах [floating-point-gui.de](https://floating-point-gui.de/) та [fabiensanglard.net](https://fabiensanglard.net/floating_point_visually_explained/index.html) є доступні посібники на цю тему.
## NaN та Inf
Існує дві спеціальні категорії чисел з плаваючою комою. Перша - це **Inf**, яка представляє нескінченність. Inf може бути додатним або від'ємним. Друга - **NaN**, що розшифровується як "не число". Існує декілька різних типів NaN (які ми не будемо обговорювати тут). NaN та Inf доступні лише у тому випадку, якщо компілятор використовує спеціальний формат (IEEE 754) для чисел з плаваючою комою. Якщо використовується інший формат, наведений нижче код призведе до невизначеної поведінки.

Ось програма, яка показує всі три варіанти:
```cpp
#include <iostream>

int main()
{
    double zero {0.0};
    double posinf { 5.0 / zero }; // positive infinity
    std::cout << posinf << '\n';

    double neginf { -5.0 / zero }; // negative infinity
    std::cout << neginf << '\n';

    double nan { zero / zero }; // not a number (mathematically invalid)
    std::cout << nan << '\n';

    return 0;
}
```
І результати з використанням Visual Studio 2008 на Windows:
```
1.#INF
-1.#INF
1.#IND
```
INF означає нескінченність, а IND - невизначеність. Зауважте, що результати друку Inf і NaN залежать від платформи, тому ваші результати можуть відрізнятися.

> [!tip]
> Уникайте ділення на 0.0 взагалі, навіть якщо ваш компілятор його підтримує.
## Висновок
Підводячи підсумок, можна виділити дві речі, які слід пам'ятати про числа з плаваючою комою:
1. Числа з плаваючою комою корисні для зберігання дуже великих або дуже малих чисел, в тому числі з дробовими компонентами.
2. Числа з плаваючою комою часто мають невеликі помилки округлення, навіть якщо число має менше значущих цифр, ніж число з точністю. Часто вони залишаються непоміченими, оскільки вони дуже малі, а також тому, що числа скорочуються при виведенні. Однак порівняння чисел з плаваючою комою може не дати очікуваних результатів. Виконання математичних операцій над цими значеннями призведе до зростання помилок округлення.