# 1 Розділ
**Оператор** - це тип інструкції, який змушує програму виконувати певну дію. Оператори часто закінчуються крапкою з комою.

**Функція** - це набір операторів, які виконуються послідовно. Кожна програма на C++ повинна містити спеціальну функцію, яка називається main. Коли ви запускаєте програму, виконання починається з вершини функції main.

У програмуванні ім'я функції (або об'єкта, типу, шаблону тощо...) називається її **ідентифікатором**.

Правила, за якими будуються елементи мови C++, називаються **синтаксисом**. Синтаксична помилка виникає при порушенні граматичних правил мови.

**Коментарі** дозволяють програмісту залишати нотатки в коді. C++ підтримує два типи коментарів. Рядкові коментарі починаються з `//` і доходять до кінця рядка. Блокові коментарі починаються з символу `/*` і закінчуються парним символом `*/`. Не вкладайте блокові коментарі.

Ви можете використовувати коментарі для тимчасового вимкнення рядків або ділянок коду. Це називається коментуванням коду.

**Дані** - це будь-яка інформація, яка може бути переміщена, оброблена або збережена комп'ютером. Окремий фрагмент даних називається **значенням**. Типовими прикладами значень є літери (наприклад, `a`), числа (наприклад, `5`) і текст (наприклад, `Hello`).

**Змінна** - це іменована частина пам'яті, яку ми можемо використовувати для зберігання значень. Щоб створити змінну, ми використовуємо інструкцію, яка називається **інструкцією опису**. Коли програма виконується, кожна визначена змінна є **екземпляром**, тобто їй присвоюється адреса в пам'яті.

**Тип даних** вказує компілятору, як інтерпретувати фрагмент даних в осмислене значення. **Ціле число** - це число, яке можна записати без дробової частини, наприклад, `4`, `27`, `0`, `-2` або `-12`.

**Присвоєння копіювання** (за допомогою `operator=`) можна використовувати для присвоєння значення вже створеній змінній.

Процес визначення початкового значення для об'єкта називається **ініціалізацією**, а синтаксис, який використовується для ініціалізації об'єкта, називається **ініціалізатором**.

Спрощено, C++ підтримує 6 основних типів ініціалізації:

|Тип ініціалізації|приклад|Примітка|
|---|---|---|
|Ініціалізація за замовчуванням|int x;|У більшості випадків залишає змінну з невизначеним значенням|
|Ініціалізація копії|int x = 5;||
|Пряма ініціалізація|int x (5);||
|Пряма ініціалізація списку|int x { 5 };|Звуження конверсій заборонено|
|Ініціалізація списку копій|int x = { 5 };|Звуження конверсій заборонено|
|Ініціалізація значення|int x {};|Зазвичай виконує нульову ініціалізацію|

Пряму ініціалізацію іноді називають ініціалізацією дужками, а ініціалізацію списком (включно з ініціалізацією значенням) іноді називають рівномірною ініціалізацією або ініціалізацією дужками. Вам слід надавати перевагу ініціалізації дужками над іншими формами ініціалізації, а також ініціалізації над присвоюванням.

Хоча ви можете визначити декілька змінних в одному операторі, краще визначати та ініціалізувати кожну змінну в окремому рядку, в окремому операторі.

**std::cout** та `operator<<` дозволяють виводити результат виразу на консоль.

**std::endl** виводить символ нового рядка, примушуючи курсор консолі переходити на наступний рядок, і змиває будь-який відкладений вивід на консоль. Символ `'\\n'` також виводить символ нового рядка, але дозволяє системі вирішувати, коли виводити вивід. Будьте обережні і не використовуйте `'/n'` (пряма похила риска).

**std::cin** і `operator>>` дозволяють отримати значення з клавіатури.

Змінна, якій не було надано значення, називається **неініціалізованою змінною**. Спроба отримати значення неініціалізованої змінної призведе до **невизначеної поведінки**, яка може проявлятися по-різному.

У C++ зарезервовано набір імен, які називаються **ключовими словами**. Вони мають особливе значення у мові і не можуть використовуватися як імена змінних.

**Буквальна константа** - це фіксоване значення, яке вставляється безпосередньо у вихідний код. Прикладами є `5` та `"Hello world!"`.

**Операція** - це процес, що включає нуль або більше вхідних значень, які називаються операндами. Конкретна операція, яку потрібно виконати, позначається відповідним оператором. Результатом операції є **вихідне значення**.

**Унарні оператори** приймають один операнд. **Бінарні оператори** приймають два операнди, які часто називають лівим і правим. **Тернарні оператори** приймають три операнди. **Нульові оператори** отримують нульові операнди.

**Вираз** - це послідовність літералів, змінних, операторів і викликів функцій, які обчислюються для отримання єдиного вихідного значення. Обчислення цього результату називається **обчисленням**. Отримане значення є **результатом виразу**.

**Оператор виразу** - це вираз, перетворений на оператор за допомогою крапки з комою в кінці виразу.

Під час написання програм додайте кілька рядків або функцію, скомпілюйте, виправте помилки і переконайтеся, що вона працює. Не чекайте, поки ви напишете цілу програму, перш ніж компілювати її вперше!

Зосередьтеся на тому, щоб ваш код працював. Якщо ви впевнені, що збережете частину коду, то можете витратити час на видалення (або коментування) тимчасового/налагоджувального коду, додавання коментарів, обробку помилок, форматування коду, дотримання найкращих практик, видалення надлишкової логіки і т.д...

Перші чернетки програм часто бувають безладними та недосконалими. Більшість коду потребує очищення та доопрацювання, щоб стати ідеальним!

**Функція** - це багаторазова послідовність операторів, призначена для виконання певної роботи. Функції, які ви пишете самостійно, називаються функціями користувача.

**Виклик функції** - це вираз, який вказує процесору виконати функцію. Функція, що ініціює виклик функції, називається caller, а функція, що викликається, називається callee або функція, що викликається. Не забудьте включити круглі дужки при виклику функції.

Фігурні дужки та оператори у визначенні функції називаються **тілом функції**.

Функція, яка повертає значення, називається **функцією, що повертає значення**. Тип повернення функції вказує на тип значення, яке функція поверне. Оператор `return` визначає конкретне значення, що повертається користувачеві. Значення, що повертається, копіюється з функції назад до викликаючої - цей процес називається поверненням за значенням. Якщо не повернути значення з функції, яка не є void, це призведе до невизначеної поведінки.

Значення, що повертається з функції main, називається **кодом стану** і повідомляє операційній системі (і будь-яким іншим програмам, які викликали вашу програму), чи успішно виконалася ваша програма, чи ні. За загальною домовленістю, значення, що повертається, рівне `0`, означає успіх, а ненульове значення означає невдачу.

Практикуйте **DRY**-програмування - "не повторюйтесь". Використовуйте змінні та функції для видалення надлишкового коду.

Функції з типом повернення `void` не повертають значення тому, хто їх викликає. Функція, яка не повертає значення, називається **функцією-пустотою** або **функцією, що не повертає значення**. Функції-пустоти не можна викликати там, де потрібне значення.

Оператор повернення, який не є останнім оператором у функції, називається **раннім поверненням**. Такий оператор змушує функцію негайно повернутися до того, хто її викликав.

**Параметр функції** - це змінна, що використовується у функції, значення якої надається користувачем, що викликає функцію. **Аргумент** - це конкретне значення, що передається від викликувача до функції. Коли аргумент копіюється в параметр, це називається передачею за значенням.

Параметри функції та змінні, визначені в тілі функції, називаються **локальними змінними**. Час, протягом якого існує змінна, називається **часом її існування**. Змінні створюються і знищуються під час виконання, тобто під час роботи програми. Область видимості змінної визначає, де її можна побачити і використовувати. Коли змінну можна бачити і використовувати, ми говоримо, що вона знаходиться в області видимості. Якщо її не видно, вона не може бути використана, і ми говоримо, що вона знаходиться за межами області видимості. **Область видимості** - це властивість часу компіляції, тобто вона встановлюється під час компіляції.

**Пробіли** - це символи, що використовуються для форматування. У C++ вони включають пробіли, табуляцію та переведення рядка.

**Пряме оголошення** дозволяє нам повідомити компілятору про існування ідентифікатора ще до того, як ми його визначимо. Для написання прямого оголошення для функції ми використовуємо **прототип функції**, який включає тип повернення, ім'я та параметри функції, але не містить тіла функції, за яким слідує крапка з комою.

**Визначення** фактично реалізує (для функцій і типів) або створює (для змінних) ідентифікатор. **Оголошення** - це інструкція, яка повідомляє компілятору про існування ідентифікатора. У C++ всі визначення є деклараціями. **Чисті декларації** - це декларації, які не є визначеннями (наприклад, прототипи функцій).

Більшість нетривіальних програм містять декілька файлів.

Коли два ідентифікатори вводяться в одну програму таким чином, що компілятор або компонувальник не може їх розрізнити, компілятор або компонувальник буде помилятися через колізію імен. Простір імен гарантує, що всі ідентифікатори у просторі імен є унікальними. Простір назв `std` є одним з таких просторів.

**Препроцесор** - це процес, який виконується над кодом до його компіляції. Директиви - це спеціальні вказівки препроцесору. Директиви починаються з символу `#` і закінчуються новим рядком. Макрос - це правило, яке визначає, як вхідний текст перетворюється на вихідний.

**Заголовні файли** - це файли, призначені для розповсюдження декларацій у файлах коду. При використанні директиви `#include` директива `#include` замінюється вмістом включеного файлу. При включенні заголовків використовуйте кутові дужки, коли включаєте системні заголовки (наприклад, ті, що є у стандартній бібліотеці C++), і подвійні лапки, коли включаєте користувацькі заголовки (ті, що пишете ви). При включенні системних заголовків включайте версії без розширення .h, якщо такі існують.
# 2 Розділ
Засоби захисту заголовків запобігають повторному включенню вмісту заголовка у певний файл коду. Вони не перешкоджають включенню вмісту заголовка у декілька різних файлів коду.

**Синтаксична помилка** - це помилка, яка виникає, коли ви пишете оператор, який не є допустимим відповідно до граматики мови C++. Компілятор перехоплює такі помилки.

**Семантична помилка** виникає, коли оператор є синтаксично правильним, але не виконує того, що задумав програміст.

Процес пошуку та усунення помилок у програмі називається **налагодженням**.

Ми можемо використовувати п'ятиступеневий процес для підходу до налагодження:
1. Знайти першопричину.
2. Зрозуміти проблему.
3. Визначте виправлення.
4. Усуньте проблему.
5. Повторне тестування.

Пошук помилки зазвичай є найскладнішою частиною налагодження.

Інструменти статичного аналізу - це інструменти, які аналізують ваш код і шукають семантичні проблеми, які можуть вказувати на проблеми у вашому коді.

Можливість надійно відтворити проблему - це перший і найважливіший крок у налагодженні.

Існує низка тактик, які ми можемо використовувати, щоб допомогти знайти проблеми:
- Коментування коду.
- Використання операторів виводу для перевірки потоку коду.
- Друк значень.

Якщо ви використовуєте оператори друку для налагодження, використовуйте std::cerr замість std::cout. Але ще краще уникати налагодження за допомогою операторів виводу.

Файл журналу - це файл, який записує події, що відбуваються у програмі. Процес запису інформації до лог-файлу називається логуванням.

Процес реструктуризації вашого коду без зміни його поведінки називається рефакторингом. Зазвичай це робиться для того, щоб зробити вашу програму більш організованою, модульною або продуктивною.

Модульне тестування - це метод тестування програмного забезпечення, за допомогою якого невеликі одиниці вихідного коду тестуються, щоб визначити, чи є вони коректними.

Захисне програмування - це метод, за допомогою якого програміст намагається передбачити всі способи зловживання програмним забезпеченням. Ці зловживання часто можна виявити та усунути.

Уся інформація, що відстежується в програмі (значення змінних, які функції були викликані, поточна точка виконання), є частиною стану програми.

Налагоджувач - це інструмент, який дозволяє програмісту контролювати виконання програми та досліджувати стан програми під час її роботи. Інтегрований налагоджувач - це налагоджувач, який інтегрується в редактор коду.

Покрокове виконання - це назва набору пов'язаних між собою функцій налагодження, які дозволяють вам виконувати оператор за оператором у вашому коді.

Крок виконує наступний оператор у звичайному шляху виконання програми, а потім призупиняє виконання. Якщо оператор містить виклик функції, step into призводить до переходу на початок функції, що викликається.

Step over виконує наступний оператор у звичайному шляху виконання програми, а потім призупиняє виконання. Якщо оператор містить виклик функції, step over виконує цю функцію і повертає вам керування після її виконання.

Step out виконує весь код, що залишився у функції, яка виконується в даний момент, і повертає вам керування, коли функція повернеться.

Виконати до курсору виконує програму доти, доки виконання не дійде до оператора, вибраного курсором миші.

Продовжити виконує програму, доки програма не завершиться або не буде досягнута точка зупинки. Start - це те саме, що й continue, тільки з початку програми.

Точка зупинки - це спеціальний маркер, який вказує відладчику зупинити виконання програми при досягненні точки зупинки.

Команда set next дозволяє змінити точку виконання на інший оператор (іноді неформально називається переходом). Це може бути використано для переміщення точки виконання вперед і пропуску деякого коду, який інакше виконувався б, або назад і повторного запуску того, що вже було виконано.

Спостереження за змінною дозволяє переглянути значення змінної під час виконання програми у режимі налагодження. Вікно спостереження дозволяє переглянути значення змінних або виразів.

Стек викликів - це список всіх активних функцій, які були виконані, щоб дістатися до поточної точки виконання. Вікно стеку викликів - це вікно відладчика, яке показує стек викликів.
# Розділ 3
